cpu 内存条 硬盘 显卡 主板 显示器之间的关系
1.主板就是这些东西都是插在主板上的
2.英雄本色是在硬盘中储存的，要打开英雄本色，就得把英雄本色放到内存条中，用cpu读取，显卡就是显示图像的，声卡就是显示声音的

当执行程序时
1.操作系统调用CPU把程序执行，所有的运行都是靠CPU来运行的

cpu 内存条 vc++6.0 操作系统之间的关系  int i
vc++把分配内存的请求发出给操作系统  操作系统分配空间   vc++会把操作系统所分配内存空间的地址和i构成某种关系



==========================================================================================
c语言常用符号的意思
1.文件的命名：first.c   c是扩展名

2.预处理指令（意思是把下面的文件包含在当前程序中）（头文件）
  #include<stdio.h>相当于把stdio.h文件中的所有内容都输入该行所在的位置
  要使用printf()函数必须包含include<stdio.h>的头文件
  #define DENSITY 62.4    开头的时候可以用这种方式定义常用的常量
  #define BEEP 'a'
  #define DOG "where is the anita"
  
  
3.所调用的函数
  int main()      //main()函数的名称    ()用于识别main是一个函数    int表示函数名返回一个整数     
  main函数必须是一个开始的函数
  通常int main()后要加return 0   0表示正常退出   1表示异常退出
  可以省略main()函数末尾的return语句，但是不要在其他有返回值的函数中遗漏掉，所以加return是一个好习惯
  
  void表明main()不带任何参数
  是一种十分不好的写法
  
4.getchar函数

  这行代码会让程序等待击键，窗口会在用户按下一个键后才关闭
  heros[count].sex = getchar(); //getchar的目的是在性别之后留一个空间让你写，并且按下空格之后完成输入
  answer = getch();//用户按下键后就立即触发下面语句，不会再让用户敲回车了  //getchar还得让用户敲一个回车
  getchar()是c语言中的一个函数,
  可以用它来赋一个字符的值.
  getchar的返回值时ASCII码
===========================================================================================================
第一种功能，赋一个字符的值
  例如:char a;
  a=getchar();
  当你在键盘上输入一个字符后按回车;(输入u)
  那么字符变量a的值就是'u'了.
  
  
  int main ()
{
   char c;

   printf("请输入字符：");
   c = getchar();

   printf("输入的字符：");
   putchar(c);

   return(0);
}
请输入字符：qwert
输入的字符：q           只能读取一个字符，其他的字符将会被存放在缓冲区里
==========================================================================================
第二种功能，暂停功能
getch的意思是全读，但不显示
#include <conio.h>  
int main ()
{
    printf("nijis");  
    getch();  //意思就是停顿一下，按任意键继续   如果这里是getchar，就是按回车键继续
    printf("nianidh");
}


  
5.%d告诉计算机以何种形式输出num的值，打印在何处

6.注释
①/*hello world*/
②/*
    hello world
 */
③/*hello
   world
  */
④// （好处：只对单行有效，不会产生代码消失问题————————问题详见23页3最下边）

7.
  花括号————c函数都使用{}表示函数的开始和结束
  声明int num;变量的声明   //之前必须放在顶端，现在想放在哪儿就放在那儿
  命名  编译器只能识别前63个字符  可以使用字母数字下划线
                                  第一个字符必须是字母或下划线
		尽量不要使用_开始的命名，一般使用一个或两个_开始的
        C语言区分大小写start和START不是一个
  赋值 num = 2;  之前int num就给num预留了空间
  
8.printf()函数———————()的意思是printf是一个函数名
  例如printf("i am anita ");  //意思就是把i am anita 从main()函数传递给printf()函数  printf()函数的意思是查看双引号中的内容，并将其打印在屏幕上
  当程序运行到printf()时控制权交给printf()函数，执行完，控制权交给main函数
  
  占坑：形式参数和实际参数
  
9.常用符号的意思
  \b代表backspace键  退格键
  \a     警报
  \f	 换页    ————移到下一页开始处
  \r	 回车
  \0oo   八位进制（每个o可表示0~7中的一个数）
  \xhh   十六位进制（hh可表示0~16中的一个数）
  \\ \' \" \?  虽然可以直接打出来  但是如果在printf中直接打，会分不清那个是哪个，为了避免造成歧义，用\加所需要的符号打
  printf("%zd\n",sizeof(int));测量大小，占几个字节
  
   
  
10.多个函数
**********************************************
//调用函数所包含的文件
#include<stdio.h>
**********************************************
//告诉编译器正在使用的函数————函数的声明
void butler(void);    //第一个void表明，此函数没有返回值    第二个void表明不带参数    void的意思时空的
                      //如果使用的是老的编译器，直接写成void butler();就可以
**********************************************
//在main函数中调用butler函数
//当butler执行完毕后，程序会继续执行main中的下一条语句
//无论main在什么位置，所有C程序都从main开始执行，c的惯例是吧main放在开头
//相当于一个输出到黑框框里的小可爱
int main(void)
{
	void butler();
}
***********************************************
//开始写出void函数里的具体内容
void butler(void)
{
	printf("i love anita\n");
}
***********************************************



11.数据类型
//整型 整数  ·int      %d 
printf("%d",2);  2的位置可以写一个变量，也可以直接写一个整型数字
long
short
unsigned

//字符型 字符是指计算机中使用的字母、数字、字和符号，包括：1、2、3、A、B、C、~！·#￥%……—*（）——+等等。
//最小的整数类型是char 
//signed char表示有符号类型，而unsigned char表示无符号而类型
//如果只用char处理字符，char前面无需要使用任何修饰符
·char    %c
ASCII码用来代表各种符号，范围0-127（既可以使用ASCII码，也可以不使用）
初始化 cat = 'a';   cat = 65;   65是A的ASCII码（但这种必须在系统认识ASCII码的情况下，尽量不要使用）
char grade = 'FATE';
printf("%c",grade);
最后打印出来的值是E   一个字符占8个字节，而char只有八位，所以只显示最后一个数字E   压栈和出栈

****浮点型****
//小数
//十六进制表示浮点型常量  最前边加上0x或0X，用p或P分别代表e和E，用2的幂代替10的幂（0xa.1fp10
//一般默认是double类型，在后边加一个f变成float常量（2.3f），在后边加l或L变成long double（但要注意一般写的是大写，小写容易被看成1）
//3.16E7表示3.16*10七次方   也可以表示为3.16e7     也可以表示为1，56e+12（加号有没有都可以，也可以是减号）
  书写规则
  1.可以没有小数点（2e5）或指数部分（19.28），但是不能同时省略两者
  2.可以省略小数部分（如：3.e16）或整数部分（。45e-6），但是不能同时省略两者
//计算机如何储存Π的值
符号    小数                                                指数
      就是把浮点数先改成整数，最前面加一个小数点       就是前面那个数×10的几次方可以变成浮点数，这个几次方就是它的指数
	  
float   %f      通常，系统储存一个浮点数要32位，其中8位表示指数的值和符号，剩下24位表示非指数部分的值和符号
double  %lf
使用%e打印指数计数法的浮点数  如果系统支持十六进制的浮点数，可用a和A分别代替e和E
//浮点值的上溢和下溢
  上溢：当计算的数字过大，会在printf中提示该值inf或infinity的现象（float只能算指数为6或7的，若是再大，就有可能出现错误）
//float f;
  printf("%d",f);//其值不会被转化成int类型 


12.位·字节·字
①位：最小的储存单位，可以储存0或1
②字节：1字节为8位，1位可以表示0或1，8位字节就有256（2的八次方）种组合方式，可以表示0~255的整数或一组字符
③字是设计计算机时给定的自然储存单位，16，32，64，计算机字长越大，其数据转移越快，允许的内存访问也越多
大多数的计算机用一个字节表示一个字符、数字或其他字符。一个字节也可以表示一系列二进制位。在一些计算机系统中，4 个字节代表一个字
这是计算机在执行指令时能够有效处理数据的单位。一些语言描述需要2个字节表示一个字符，这叫做双字节字符集


13.二进制（进位制，主要是有十六进制和八进制）
  C语言规定八进制前要加0，十六进制前要加0x或0X   //如int i = 0x5; int i = 05;
  输出 %d表示以十进制输出  %x或%X表示以十六进制输出  %啥 表示以八进制形式输出
  %#x  将输出的十六进制数字前加0x
   十进制              		二进制
   0						0
   1						1
   2						10
   3						11
   4						100
   5						101
   6						110
   7						111
   8						1000
   9						1001
   10						1010
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————   
   //十进制如何转二进制（各种进制都是这样算）  也可以十进制先转16进制，再转二进制
   除以二，看余数，从下往上读
   //二进制如何转十进制   二进制先转16进制，再转10进制（8  4  2  1 ）
   1011010
   1*2六次方+0*2五次方.........
   //负整数转二进制（记住 8 4 2 1）
   先求与该负数相对应的正整数的二进制代码，然后将所有位 取反 末尾加1，左边补0（整数占四个字节，一个字节有8位 0000 0000   0000 0000   0000 0000   0000 0000）
   /**如果是-3  0000 0000   0000 0000   0000 0000   0000 0011 
				1111 1111   1111 1111   1111 1111   1111 1100
				1111 1111   1111 1111   1111 1111   1111 1101
				  F    F     F     F      F    F      F    D
				  
	 如果是-100  100转化为16进制  除16  （64）  十六进制转换二进制容易
	            0000 0000   0000 0000   0000 0000   0110 0100   （是按位看的0110 6     0100  4）
				1111 1111   1111 1111   1111 1111   1001 1011
				1111 1111   1111 1111   1111 1111   1001 1100
				  F    F     F     F      F    F      9    c
				  			
   **/
   //求0的二进制  全是0
   //已知二进制求十进制
   如果首位是0，则表明是正整数，按普通方法求
   如果首位是1，则表明是负整数，将所有位取反，末尾加1，所得数字就是该负数的绝对值
   /**
		1111 1111   1111 1111   1111 1111   1110 1111 （ffffffef）
		0000 0000   0000 0000   0000 0000   0001 0000
		0000 0000   0000 0000   0000 0000   0001 0001   （-11）十六进制   （-17）十进制
		
		1111 1111   1111 1111   1111 1111   1100 1010
		0000 0000   0000 0000   0000 0000   0011 0101
		0000 0000   0000 0000   0000 0000   0011 0110   （36）   （48 + 6= -54）
   **/
   如果全是0，则对应的十进制就是0
   
   //8位二进制所代表十进制的示意图
   /**
		二进制                            十进制
		0000 0000      ————————————		    0
		0000 0001      ————————————         1
		........       ————————————		   ...
		0111 1111      ————————————        127              (先转化成16进制，7f，再转化成十进制，7*16+15 = 127)
		1000 0000      ————————————       -128             （先转化成10进制，取反，0111 1111 ，末尾加1 1000 0000，80，8*16 = 128）
		1000 0001      ————————————       -127
		1000 0010      ————————————       -126
		........       ————————————        ...
		1111 1111      ————————————        -1
		
		
		如果ch = -129  对应的16进制是81  1000 0001     0111 1110     0111 1111 7f  
   
   **/
   
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————  
   计算机以二进制储存整数   例如，整数7以二进制写是111.因此，要在8位字节中储存该数字，需把前五位都设置成0，后三位设置成1
   二进制全部为0的含义
				1.表示数值
				表示字符串结束标记符\0
				2.字符串结束的标记'\0'
				3.空指针NULL  NULL表示的是0，而这个0不代表数字0，而表示的是内存单元的编号0
			我们计算机规定了以0为编号的存储单元不可读，不可写                              
*常量以什么样的二进制代码储存在计算机中
整数是以补码的形式转化为二进制代码储存在计算机中的  
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
学习目标：
	1.在vc++6.0中一个int类型的变量所能储存的数字的范围是多少
	  在上面8位二进制中最大的数127 0111 1111 所以在4个字节中为 0111 1111   1111 1111   1111 1111   1111 1111  7fffffff
	2.最小负数的二进制代码是多少
	  同理可得1000 0000   0000 0000   0000 0000   0000 0000
	3.最大正数的二进制代码是多少
	  
	4.已知一个整数的二进制代码求出原始的数字
	5.数字超过最大正数会怎样
	6.不同类型数据的相互转化
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
1.什么是字节
  字节是储存数据的单位。并且是硬件所能访问的最小单位，CPU只能直接处理内存里的数据，硬盘里的不行，内存里存放的是01代码，1位
  但硬件只能精确到字节，如何控制到某一位，位运算符  char占一个字节  一字节 = 8位  1K = 1024字节  1M = 1024k   1G = 1024M
2.不同类型数据之间相互赋值的问题
  int i = 45;      
  long j = 102345;
  i = j;    //long占8个字节，i占4个字节，这样赋值，有可能会丢失数据
  printf("%d %ld", i, j);   //
  float x = 6.6;
  double y = 8.8;
  printf("%f %lf", x, y);
  
  int i =  
  
   
14.初始化变量
int hogs = 21;
int cows = 32,goats = 14;
int hogs的意思是为hogs分配空间       初始化变量是把空间填上
===========================================================================================================================================
*位运算符
&       ——      按位与
1&1 = 1  1&0 = 0  0&1 = 0  0&0 = 0  
例如：5 0101   7 0111    0101  5   所以5&7 = 5

|       ——      按位或 
1|0 = 1    1|1 = 1    0|1 = 1    0|0 = 0

~       ——    按位取反   
例如：3 0000 0011  取反 1111 1100（这是个负数）  已知二进制，求原始数据，取反加1  0000 0011—— 0000 0100——0000 4
^       ——    按位异或 相同位0，不同为1  1^0 = 1
              7 ^ 4 ^ 4 = 7
			  应用：7 ^ 4相当于加密   7 ^ 4 ^ 4相当于解密
<<      ——    左移   就是把数字整体左移，右边补0，相当于*2的n次方
>>      ——    右移   就是把数字整体右移，相当于/2的n次方，左边一般是补0，也可以补1，负数补1，正数补0，123只能移3次，不能移太多，前提是
                     数据不能丢失
     面试题：
	         i = i * 8
			 i = i<<3   这个执行更快   在硬件上有加法器，乘法器...... 要是用上面，得动用乘法器，慢
			 
如果是一个负数右移，最高位补1，永远移不光，所以负数右移用<<<
最有效率的方式算出2 * 8
2<<3

交换n和m
n = n ^ m;
m = n ^ m;
n = n ^ m;
=========================================================================================================================================== 
原码  
		也叫符号，绝对值码   最高位0表示正，1表示负，其余二进制位是该数字的绝对值的二进制位
		
		源码简单易懂
		加减运算复杂
		存在加减乘除四种运算，增加了CPU复杂度
		0的表示不唯一
反码
		反码运算不便，也没有在计算机中使用
移码    
		移码表示数字平移n位， n称为移码量
		移码主要用于浮点数阶码的储存
		
补码
		十进制转二进制
		二进制转十进制
        
===========================================================================================================================================
15.有符号还是没符号
最明显的区别就是二者表示的范围不同： 无符号数中，所有的位都用于直接表示该值的大小。
有符号数中最高位用于表示正负，所以，当为正值时，该数的最大值就会变小。我们举一个字节的数值对比： 无符号数： 1111 1111 
值：255 1* 27 + 1* 26 + 1* 25 + 1* 24 + 1* 23 + 1* 22 + 1* 21 + 1* 20 
有符号数： 0111 1111 值：127 1* 26 + 1* 25 + 1* 24 + 1* 23 + 1* 22 + 1* 21 + 1* 20 
同样是一个字节，无符号数的最大值是255，而有符号数的最大值是127。
原因是有符号数中的最高位被挪去表示符号了。
并且，我们知道，最高位的权值也是最高的（对于1字节数来说是2的7次方=128），所以仅仅少于一位，最大值一下子减半。
不过，有符号数的长处是它可以表示负数。因此，虽然它的在最大值缩水了，却在负值的方向出现了伸展。
我们仍一个字节的数值对比： 无符号数： 0 ----------------- 255 有符号数： -128 --------- 0 ---------- 127 
同样是一个字节，无符号的最小值是 0 ，而有符号数的最小值是-128。所以二者能表达的不同的数值的个数都一样是256个。
只不过前者表达的是0到255这256个数，后者表达的是-128到+127这256个数。 
无符号  1111 1111   ff 15*16 + 15 = 255  两边取等256


意思就是有符号中某些数字会用来表示符号，会导致数字变小，但可以表示负数

signed char表示有符号类型，而unsigned char表示无符号而类型
如果只用char处理字符，char前面无需要使用任何修饰符

unsigned/signed short、int、long、long long



16._Bool类型
需要包含头文件<stdbool.h>
c语言中_Bool是布尔类型的数据，其值为0或1，主要用来判断条件能否成立的真假。 
1表示真，0表示假


17.复数和虚数
 复数：a＋bi
 虚数：b≠0，复数除了实数
 复数：float_Complex  double_Complex long double_Complex
 虚数：float_Imaginary double_Imaginary long double_Imaginary
 如果包含complex.h头文件，便可用complex代替_Complex，用imaginary代替_Imaginary,还可以用I代替-1的平方根
 
 
 
 18.参数的含义
 printf("");无论双引号中包含多少个字符和标点符号，一个字符串就是一个参数    printf("%d  %d",cat,cat);有三个参数
 scanf("%d",&weight);有两个参数  %d  &weight
 而且printf函数和scanf函数一定要写对，因为系统检查不出来
 
  
  
 19.刷新输入，意思就是清空缓冲区
 printf先把语句发送到缓冲区，然后再由缓冲区发送到屏幕上  （发送的条件：缓冲区满   遇到换行字符或需要输入）
 从缓冲区发送到屏幕或文件被称为刷新缓冲区  例如：前两个printf语句既没有填满缓冲区，也没有换行符，但是下一条scanf语句要求用户输入，这迫使printf的输入
 被发送到屏幕上
 
 
 旧编译器遇到scanf也不会刷新缓冲区，可以使用换行字符刷新缓冲区printf("enter your monthly salary:\n);
 还有一种刷新缓冲区的办法使用fflush()函数
 
 
 
 ====================================================================================================================================================
 
 
*字符串
1.字符串是一个或多个字符的序列   "zing went the strings of my heart" 双引号不是字符串的一部分，双引号仅告知编译器它括起来的是字符串
  （例如#define PRAISE "You are an extraordinary being"）
单引号用于识别单个字符，所以只要有字符，都要用单引号括起来，比如说：'\n'
2.字符串和数组
  字符串都被储存在char类型的数组中，结尾还要空出一个储存单元来保存\0(\0的意思是空字符，标记字符串的结束，它的ASCII码等价于0)
  数组，一行储存单元
  字符串是东西   数组是放东西的
  char name[40];   name后面跟[]表明这是一个数组，方括号中的40表明该数组中的元素数量，char表明每个元素的类型
  如果char ch;  的意思是就分配一个字节
3.注意scanf("%s",name);  //不用取地址
4.scanf只会读取字符串中的一个单词，而不是一整句，意思就是如果输入的是anita mui 读取的只是Anita，它在碰到第一个空白（空格，制符表或换行符）
5.字符串和字符
"x"基本类型char数组，且有两个字符组成：'x'和空字符\0   'x'基本类型是char



*strlen()函数  (函数的头文件为#include <string.h>   如果使用ANSIC之前的编译器，必须移除这一行) 
1.sizeof()是以字节为单位给出对象的大小   （意思就是一般来说，一个字节就是一个字符）
  大多数的计算机用一个字节表示一个字符、数字或其他字符。
  一个字节也可以表示一系列二进制位。在一些计算机系统中，4 个字节代表一个字，这是计算机在执行指令时能够有效处理数据的单位。
  一些语言描述需要2个字节表示一个字符，这叫做双字节字符集
  
 
  strlen(name)
  
  而且要记住sizeof()  和strlen()函数所对应的都是%zd
  
  printf()和scanf()都属于stdio.h头文件
2.sizeof会把最后的空字符也算在内，而strlen则不会把最后的空字符算在内

  

*const限定符
1.用于限定一个变量为只读，就是它在整个程序中是不变的，不可更改
2.const类型限定符声明的是变量，不是常量  const int MONTHS = 12;//MONTHS在程序中不可更改，值为12


*打印较长字符串
1.正确的写法有
printf("i like anita because she is very beautiful and cute,she is a very good person%d",
        anita);//不能在双引号括起来的中间断行
printf("i like anita because she is very beautiful and cute,she is a \
very good person%d",anita);//如果要从双引号中间断开，得加\，而且要注意后面的句子必须跟printf对齐，如果没对齐，则多出来的空格也将被算在内
printf("i like anita because she is very beautiful" 
       "and cute,she is a very good person%d",anita);//用双引号将空白括起来,注意双引号的目的是消除双引号内的空白在双引号外的空白该打还得打，
	                                    //不要写成beautifuland  中间没有空格的形式
										
*使用scanf（把输入的字符串转换成整数，浮点数，字符或字符串）
1.printf的作用跟他相反，把整数，浮点数，字符，字符串转换成显示在屏幕上的文本
2.scanf()函数每次读取一个字符，跳过所有空白字符，直至遇到第一个非空白字符才开始读取
  scanf会根据所输入的字符形式来读取字符 %d，scanf会读取直到停留在小数点处，小数点作为下一次输入的首字符 只读取该读的，
  如果是%c scanf只会读取并储第一个字符
3.当scanf()把字符串放进指定数组中时，它会在字符序列的末尾加上'\0'
4.scanf会自动跳过待输入值前面的空白：如果要输入两个数字，下面的形式都可以
  88      ，88          88，
                              88
5.scanf()的返回值
  本来需要读取一个数字而用户输入一个非数值字符串，scanf便返回0.当scanf检测到文件结尾时，便会返回EOF
6.printf中*的作用
  int n;
  printf("please enter three number:");
  scanf("%*d %*d %d",&n);
  printf("the last number was%d\n",n)  
  
  
  结果：2013 2014 2015
        the last number was 2015
  所以*的意思就是跳过，在程序需要读取文件中特定列的内容时，这项跳过功能很有用
7.指定固定字段宽度
  printf("%9d %9d %9d",num1,num2,num3);
  就可以让
  123 2345 67891
  12345 5678 234
  变成
    123    2345      67891
  12345    5678        234
  记得是右对齐呀
 
****************************************************************************************************************************8
1.pow()函数可以用于指数运算。例如，pow(3.5，2.2)返回3.5的2.2次幂

*几个术语
1.用于储存值的数据储存区域统称为数据对象   就是放东西的盒子
2.左值是用于标识或定位储存位置的标签 就是一个人领着你去到指定的地方，左值就是领你的人 当用const就表示这个人领你去的地方是固定的，不用就是不固定
3.右值就是能赋给可修改左值的量 就是不用const，右值可以是常量，变量或其他可求值的表达式（如，函数调用）
4.const int TWO = 2;这里的=表示初始化而不是赋值
5，运算对象是指运算符操作的对象

*
2.cheeta = tarzan = jane = 69;
  首先把69赋给jane，然后再赋给tarzan ，最后赋给cheeta
  
3.+-运算符都被称为二元运算符，需要两个运算对象才能完成操作   加和减
4.+-正负  一元运算符
5.除法运算符
  浮点数除法：浮点数除法的结果是浮点数
  整数除法：整数除法的结果是整数   整数除法的小数部分被丢弃（专业术语：截断）
  混合类型：浮点值除以整数值（不符合规范，但系统会自动转化，所以尽量少使用不使用）
  规范printf("mixed division:7./4 is %1.2f \n",7./4.);
  
  3.8看成整数应该是3    C99规定使用趋零截断，所以，应该把-3.8转换成-3
  
*运算符优先级
1.和正常数学里教的一样

*sizeof运算符和size_t类型
1.C语言规定，sizeof返回size_t类型的值
  size_t intsize;
  intsize = sizeof(int);
 2.typedef
  typedef double real;  //real就是double的别名
  real deal;//就是把real创建成一个double类型的变量
  
  在c头文件系统可以使用typedef把size_t作为unsign int 或unsign long的别名，这样，在使用size_t类型时，编译器会根据不同系统替换标准类型
  用%zd显示   如果系统不支持%zd，可使用%u %lu
  
  
 *求模运算符
 取模
 %余数是几
 5%-3取余数	是2            若是-5%-3   是-2           取模的时候  和第一个一致
 1.求模运算只能用于整数，不能用于浮点数
 
 
 *递增运算符
 1.两种情况
   while(++shoe < 18.5);  //意思就是先让shoe++，再和18.5比较 
   post = a++； //先把a的值赋给post，再++（先使用，再递增）      post = ++b；//先让b++，再赋给post（先递增，再使用）
 2.递增运算符和递减运算符级别高，只有圆括号的优先级比他们高，老大
 3.注意
   如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符
   如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符 
   
   在我看来：如果在一个式子中有多种运算，+-×÷ 很复杂，不要加++   因为编译器不会按照正常从左到右算，它随心所欲1*2+3*4有可能先算3*4
   
   
   
*表达式和语句
1.q>3; 这种关系表达式的值不是0就是1，如果条件为真，表达式的值为1，如果条件为假，表达式的值为0
2。如果书写形式6 + （c=3+8）  最后的值是17  也是正确的
3.语句：大部分语句都以分号结尾   
  最简单的语句是空语句  ；
  int count;  //声明
  count = 0；//表达式语句
  while //语句是迭代语句
  return 0；//是跳转语句
 4.副作用
  state=50；它的副作用是将变量的值设置为50//使用它们的主要目的就是使用它们的副作用
 5.序列点
  分号标记了一个序列点
  任何一个完整表达式的结束也是一个序列点
 6.复合语句 
   是用花括号括起来的一条或多条语句，复合语句也称为块
   如果是循环只有一条语句，就不用加花括号
 7.表达式 
   由运算符和运算对象组成
 8.类型转换
  -unsigned和signed的char和short都会被自动转化成int   由小类型转换成大类型叫升级
  -类型从高至低分别是long double,double,float,unsigned long long,long long,unsigned long,long,unsigned int,int
    (例外的情况是：当long和int大小相同时，unsigned int比long级别高)
  -在赋值表达式的语句中，计算的最终结果会被转化成赋值变量的类型，这个过程可能会导致升级或降级，升级没啥事，降级会导致错误，数据的丢失
  
 *强制类型转换运算符
  mice = (int)1.6 +(int)1.7;  //最后的结果是2
  基本格式(type)
   
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————  
#include <stdio.h>
//定义一个带参数的函数
//pound()函数，打印指定数量的#号
void pound(int n);  //ANSI函数原型声明   如果函数不接受任何参数，函数头的圆括号中应该写上关键字void
                    //由于该函数接受一个int类型的参数，所以圆括号中包含一个int类型变量n的声明
					//该函数没有返回值，函数前面是void，该函数有一个int类型的参数
					//函数声明只指名了函数名和返回类型，没有指明参数类型
					/*如果用void pound(); 这种形式，第一次pound(times)没有问题，第二次pound(ch)也会自动转化，没问题
                      但是，第三次pound(f)系统会将float类型转化成double类型，在函数调用中使用强制类型转换，可以解决
                      pound((int)f);//当然，如果f的值太大了，超过了int类型表示的范围，这样做也不行
                    */
int main(void)
{
   int times = 5;
   char ch = '!';   //ASCII码是33
   float f = 6.0f;

   pound(times);   //int类型的函数   times的值5被赋给n
   pound(ch);      //和pound((int)ch);类型相同
   /*
	void pound(int n);函数原型是int型；而ch是char型，当执行到这里，函数会自动把char转化成int，也就是它对应的ASCII码
   */
   pound(f);       //和pound((int)f);类型相同

   return 0;
}
void pound(int n)
{
    while(n-->0)
        printf("#");
    printf("\n");
}
1.形式参数和实际参数
 形式参数：声明参数时就创建了被称为形式参数，例如void pound(int n)    这个n就是形式参数
 实际参数：函数调用传递的值为实际参数times 是pound()的实参，n是pound()的形参 

2.scanf的返回值  如果是书写的符号和规定的变量类型一致，真的返回1   不一致返回0 
#include <stdio.h>
int main()
{
    int num;
    int sum = 0;
    int status;
    printf("请输入一个数字：");
    status = scanf("%d",&num);
    while(status == 1)
    {
        sum = sum + num;
        printf("请再输入一个数字：");
        status = scanf("%d",&num);
    }
    printf("这些数字的总和为：%d\n",sum);
}

循环行为 status = scanf("%ld",&num);   可以用这些代码替换while(scanf("%ld",&num) == 1)

3.
#include <stdio.h>
int main()
{
    int n=3;
    while(n)     //我知道了，当n值是真，就执行循环，如果n的值不是0，就不执行循环
                 //根据结果可以看出，当n的值是0，就是假，除了0以外都是真
				 //很多都用while(goat)来代替while(goat =! 0)
        printf("%2d is true\n",n--);
    printf("%2d is false",n);
}

4._Bool类型的应用
int main()
{
    int num;
    int sum = 0L;
    _Bool status;
    printf("请输入一个数字：");
    status = (scanf("%ld",&num) == 1);//这里的scanf()外边得加个括号，提高代码可读性

    while(status == 1)
    {
        sum = sum + num;
        printf("请再输入一个数字：");
        status = (scanf("%ld",&num) == 1);
    }
    printf("这些数字的总和为：%d\n",sum);
}

C99提供了stdbool.h头文件，该头文件让bool成为_Bool的别名，而且还把true和false分别定义为1和0的常量


5。优先级和关系运算符
   关系运算符的优先级比算数运算符的优先级低，比赋值运算符高
   关系运算符的优先级  高级优先组 <<=  >>=   低级优先组==  ！=
  
6.不确定循环和计数循环
   一个是知道循环要执行多少次，另一个是不知道循环要执行多少次

   
   
for循环
1.for循环里面可以是不同的值
  for(x = 1;y <= 75;y = (++x + 5) + 50)
2.for(initialize;test;update)
  initialize表达式在执行for循环语句之前只执行一次，所以initialize可以是printf("i love anita")，这个语句可以是一条简单语句或复合语句
  test条件为真时才执行，为假退出循环

  
其他赋值运算符
1.运算符优先级
  （）
   ++ -- sizeof
   四则运算规则
   < > <= >=
   == !=   组合赋值运算符
   =
2.a += 3;  和    a=a+3;


逗号运算符
1.逗号运算符将两个表达式连接成一个表达式，并保证最左边的表达式最先求值。
  逗号运算符通常在for循环头的表达式中用于包含更多的信息，整个逗号表达式的值是逗号右侧表达式的值
2.int money1 = 46;
  int money2 = 20;
  int ounces,cost;
  printf("ounces cost\n");
  for(ounce = 1,cost = money1;ounce<=16;ounce++,cost += money2)
	printf("%5d   $%4.2f\n",ounce,cost/100);
	
	ounce cost
	1	  $0.46
	2     $0.66
	3	  $0.86
	4	  $1.06
	
	逗号运算符的作是从左往右算，如果cost的表达式中包含了ounces时，顺序就很重要
	
3.x = (y = 3,(z = ++y + 2) + 5); //整个逗号表达式的值是右侧的值，意思也就是将y = 3带入算出z=11，把11赋给x
  house = 249，500；//整个逗号表达式的值是右侧的值，左侧是赋值表达式
  houseprice = (249,500);//houseprice的值500
4，逗号也可以做分隔符


1.while循环和for循环都是入口条件循环  就是有可能根本不执行循环体中的内容
  do while循环是出口条件循环，就是至少执行循环体中的内容一次
  do while循环的格式
  do
	statemen
  while(expression);
2.如何选循环
  确定需要入口条件循环还是出口条件循环 当循环涉及初始化和更新变量时，用for循环比较合适，其他情况，while循环好
  while(scanf("%ld",&num) == 1)
  涉及索引计数的循环，用for循环更合适
  for(count = 1;count <= 100;count ++)
  
  
  
  
  
*嵌套循环
1.常用于按行和列显示数据

*数组简介
1.数组的第一个元素是debts[0]
2.scanf("%f",&debt[4]);//把一个值读入数组的第五个元素
3.如果debts[这个里面填的数超出去了]，这就是错误的，系统还检查不出来，只能乱放
4.如果char类型的数组末尾包含了一个表示字符串末尾的空字符，则该数组中的内容就构成了一个字符串
5.识别元素的数字被称为下标，索引，偏移量

   ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  
1.while(scanf("%f",&temperature) == 1)//这样的while循环经常见，如果用户输入正确，就一直执行循环，如果输入错误，就跳出循环
2.if语句只能执行测试和执行一次，if的好处就是可以执行，也可以不执行，而while语句可以测试和执行多次
*getchar()和putchar()
1. ch = getchar();   该语句和下面的语句效果相同 scanf("%c",&ch);
2.putchar(ch)该语句与下面的语句效果相同printf("%c",ch);
3.这两个函数只能处理字符    这两个函数通常定义在stdio.h头文件中


*ctype.h系列的字符函数
 专门处理字符的函数（有一堆，都是可以处理各种大写字母，小写字母，数字啥的） 头文件是ctype.h
 
 
*多重选择else if
1.if(num<2)
    .......;
 else if(num<3)  //这个的范围是2<num<3
    .......;
 else if(num<4)  //这个的范围是3<num<4
    .......;

也可以多用几个if    else 来写

2.如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来

*
1.if(ch != '"' && ch != '\'')注意它的格式
2.&&与 ||或 ！非   ！优先级比乘法高，与递增运算符相同，只比圆括号优先级低 &&比||高，但两者的优先级都比关系运算符低，比赋值运算符高
3.iso646.h头文件  可以用and代替&&、or代替||、not代替！
4.逻辑表达式的求职顺序是从左到右，一旦发现有使整个表达式为假的因素，立即停止求值
5.&&可用于测试范围
 if(range >= 90 && range <= 100)
 错误写法if(90 <= range <= 100)因为可以看成if((90 <= range) <= 100)   (90 <= range)为假输出0，为真输出1
 
 ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 1.条件运算符（三元运算符，C语言中唯一的三元运算符）
 x = (y < 0) ? -y : y;    //如果y小于0，那么x=-y，否则x=y，是if-else的另一种写法，比较简单
 需要把两个值中的一个赋给变量时，就可以用条件表达式 max = (a>b) ? a : b;
 
 *continue语句
 1.三种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分。并开始下一次迭代
 2.if(score < MIN || score > MAX)
 {
	 printf(".......");
	 continue; 
 }
 可以用以下两种方法来代替
 ①
 if(score < MIN || score > MAX)
 {
	 printf(".......");
 }
 else
 {
	 
 }
 ②
 if(score >= MIN && score <= MAX)
 {
	 printf(".......");
 }
3.continue还可以用作占位符，当程序已经读取一行中某些内容，要跳至下一行开始处时，用这种方法很简便
4.对于for循环先执行第三个，再用第二个进行判断


*break语句
1.终止循环，执行下一阶段
2.在for循环中，使用break只是跳出当前for循环，并没有跳出大循环，如果想跳出大循环，还需要一个break


*多重选择：switch和break
1.目的：在程序中进行多个选择
2.default的位置想放在哪里都行，且可以省略
3.switch(ch)
{
	case 1:statement 1;
		   break;
    default:statement 2;
}
4.break语句可用于循环和switch语句中，但是continue只能用于循环中
5.多重标签(就是a和A时都读取statement 1，其实是因为'A'后没有break)
switch(ch)
{
	case 'A':
	case 'a':statement 1;
			 break;
		   
		   break;
    default:statement 2;
}

使用ctype.h系列的toupper()函数可以把字母转换成大写字母   ch = toupper(ch);
    也可以switch(toupper(ch)) 


*只读取每行的首字符
1.while(getchar() != '\n')


*缓冲区
1.回显用户输入的字符后立即重复打印该字符是属于无缓冲（在游戏中，你希望按下一个键就执行相应的指令）hheello
2.有缓冲是先将字符放入缓冲区，用的时候再拿出来
3.缓冲的类型
  完全缓冲I/O：完全缓冲是将缓冲区全部填满时才刷新缓冲区（内容被发送到目的地），通常出现在文件输入中
  行缓冲I/O指的是在出现换行符时才刷新缓冲区（键盘输入通常是行缓冲输入所以在按下Enter键后才刷新缓冲区）
4.回显无缓冲输入getche函数     无回显无缓冲的getch函数


*结束键盘输入
1.文件时储存其中储存信息的区域，通常，文件都被保存在某种永久储存器中（硬盘，U盘，DVD）
2.c有许多用于打开 读取 写入和关闭文件的库函数，c可使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统
  的函数被称为底层I/O，c还可以通过标准I/O包来处理文件。这涉及创建用于文件处理的标准模型和一套标准I/O函数。具体的C
  实现负责处理不同系统的差异，以便用户使用统一的界面（IO就是函数，是连接主机和c程序的中转站）
3.流是一个实际输入或输出映射的理想化数据流，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成
4.键盘和显示时每个c程序自动打开的文件（stdin流表示键盘输入，stdout流表示屏幕输出），getchar(),putchar(),pritnf(),
  scanf()都是标准IO包的成员处理这两个流

  
*文件结尾
1.可以使用内置的Ctrl+Z字符来标记文件结尾
2.把文件储存满就表示到结尾了
3.用getchar()和scanf()读取文件检测到结尾的时候将返回一个特殊的值，即EOF（end of file）
4.#define EOF (-1)  //getchar的返回值通常都介于0-127之间，-1不对应任何字符，可以表示文件结尾,而且这个定义可以在stdio.h文件中找到
                    //所以不用再次定义EOF的值
5.EOF是一个值，标志着检测到文件结尾，并不是在文件中找的到的符号
  使用EOF
  int ch;     //ch类型从char变为int，小变大，因为char类型的变量只能表示0-255的无符号整数，但是EOF的值是-1
              //还好，getchar()函数实际返回值的类型是int，所以可以读取EOF字符
  while((ch = getchar()) != EOF)
	putchar(ch);  //ch是整数不会影响putchar(),该函数仍然会打印等价的字符
6.在大多数系统中，在一行开始处按下ctrl+d会传输文件结尾信号，许多微型计算机系统都把一行开始处的ctrl+z识别为文件结尾信号，
一些系统把任意位置的ctrl+z解释成文件结尾信号
7.该程序以int类型读取字符(这样做可以读取EOF)，但是却以char类型把字符传递给display()函数，因为char比int小，一些编译器会给出类型转换的警告
  或者以下面的强制类型转换来消除警告
  int ch;
  display(ch);//可以改成display(char(ch));
  


*重定向和文件
1.重定向输入让程序使用文件而不是键盘来输入，重定向输出让程序输出至文件而不是屏幕
2.<是重定向运算符（echo_eof < words），把文件中的内容导入echo_eof程序,echo_eof程序本身并不知道
  输入的内容是来自文件还是键盘，它只知道这是需要导入的字符流
3.在从定向符号和文件名之间不许有空格
4.重定向输出：用echo把键盘输入的内容发送到名为mywords的文件中（echo>mywords）

*缓冲输入
1.缓冲输入要求用户按下Enter键发送输入，这一动作也传递了换行符
  其实都是用一
  while(getchar() != '\n')
	continue;   //跳过剩余的输入行.之后只要遇到getchar()输入要换行的问题，也就是while((ch = getchar()) != '\n')
	            //之类需要输入的循环条件，都要加，都要加，都要加
2.输入验证
  必须当输入类型正确的时候，才可以执行循环操作
  while(scanf("%ld",&n) == 1 && n >= 0 ) //当输入是一个整数且该整数为时

  
  
1.  42
  如果在scanf()函数中使用%c转换说明，只会读取一个字符并将其储存在char类型的变量中
  如果使用%s转换说明，会读取好几个字符并将其储存在字符数组中
  如果使用%d转换说明，scanf()同样会读取两个字符，但随后会计算出他们对应的整数值4 × 10 + 2
            ，即42，然后将表示该整数的二进制数储存在int型的变量中
  如果使用%f转换说明，scanf()也会读取两个字符，计算出他们对应的数值42.0，用内部的浮点法表示
            该值，并将该结果储存在float类型的变量中
			
  getchar()和使用%c的scanf()接收所有的字符
  
  
*********************************************************************************************************************************************************************
函数
1.使用函数可以使程序更加模块化
2.函数原型 函数调用 函数定义
3，函数的返回值类型和函数接受的参数类型，称为函数的签名
4，函数原型可以放在main()函数前面，也可以放在main()函数里面
5.有没有返回值的区别   main()函数和其他函数的区别
  main()函数可以把自己当中的一些参数赋给其他函数中，其他函数可以调用这些参数，但其他函数中对这些参数所做的
  任何行为并不会改变main()函数中这些参数的值，如果要改变，就得使用指针，进行强制改变
  有返回值，就是本来这个数是在其他函数中的，跟main()函数没什么关系，通过返回值建立了一个桥梁，使得可以在main()
  函数中也可以调用这个函数，如果没用返回值，意思就是在main()函数中其他地方不需要用到这个数，直接进行其他函数中操作
  就行，这些操作，比如打印一些*也会显示在屏幕上
6.void num(int a,b,c)//这种写法是无效的    必须写成void num(int a,int b,int c)
   也可以表示成 void num(a,b,c)
                 int a,b,c;
7.函数的返回值也可以用作表达式的一部分
  answer = 2 * imin (z, zstar) + 25;
  printf("%d\n",imin(-32 + answer, LIMIT));
  
  *形式参数和实际参数
  1.形式参数就是void num(int a);这个a就是形式参数
  2.实际参数就是从main()函数输入到其他函数中的确定的值
  

  *返回函数最小值的函数
  int imin(int n,int m)
  {
	  return(n < m) ? n : m;
  }
  
  
   *return语句的使用方法
   1.return函数的返回值和函数前面标识的一致,如果没有声明函数的类型，旧版本会认为是int，c99不支持这种
   2.一个函数中可以有多个return语句，分属于在不同情况下的返回值，但一次只能返回给main()函数一个返回值
      int imin(int n, int m)
	  {
		  if(n < m)
			return n;
		  else
			return m;
		  printf("我们用多一点点的辛苦");
	  }
	  //因为前面的return语句，将导致后面的printf()语句永远不会执行

	*在main()函数中调用函数时，书写的实际参数错误的情况
	1.缺少参数
	  主调函数会把参数存在栈中，被调函数会从栈中读取这些参数，如果缺少参数，被调函数为了凑够
	  会读取栈中其他的数字补齐
	2.类型不一致，double类型转换成int类型，就是大类型转换成小类型，可能会出现一些无法用言语描述的错误
	   反正一定要注意类型的一致，但有可能也能正确执行
	   
	   
	   
	*递归
	1.函数自己调用它自己
	2.//递归函数演示
	void up_and_down(int);
	int main()
	{
	  up_and_down(1);
	  return 0;
	}
	void up_and_down(int n)
	{
		printf("低级：%d    地址：%p\n",n,&n);
		if(n < 4)
			up_and_down(n + 1);//如果要使用递归，①得用到这个函数 ②得有形式参数 ③得找出下一次递归的值和这一次的关系
							   //并且用含n的代数式表示，例如计算阶乘ans = n * rfact(n - 1);
		printf("高级：%d    地址：%p\n",n,&n);

	}
	
	低级：1    地址：0060FEF0 低级：2    地址：0060FED0
	低级：3    地址：0060FEB0 低级：4    地址：0060FE90
	高级：4    地址：0060FE90 高级：3    地址：0060FEB0
	高级：2    地址：0060FED0 高级：1    地址：0060FEF0
	 //因为一直小于四，所以就要反复一层一层套用循环，每一次执行完if前面的语句后，由于不满足n < 4
	   所以if前面的语句被一遍一遍执行，当执行到最后时，肯定if已经满足了，所以倒回去一遍一遍执行if
	   后面的语句
	 3.递归函数必须包含能让自己停止的语句，这里就是if(n < 4)
	 4.尾递归调用在函数的末尾，是最简单的递归形式，相当于循环
	 5.可以有if——else——else语句
	 6.递归的缺点：每一次递归都会创建一组变量，所以他使用的内存更多
	 7.斐波那契数列，第一个数字和第二个数字相加等于第三个数字
	   1  1 2  3 5 8 13
	   unsigned long Fibonaccci(unsigned n)
	   {
		   if(n > 2)
			return Fibonaccci(n - 1) + Fibonaccci(n - 2);
		   else
		    return 1;
	   }
	 8.main()函数也可以自己调用自己
	 
	 
*如何把函数和主函数之类分属不同的文件
1.一般分成三个文件
   文件>新建一个文件(新建文件的时候得建立一个sources文件和一个headers文件)
2.这三个文件
sources
①main.c文件
1.#include "hotel.h"

②hotal.c文件
1.各个函数的处理
2.处理非整数输入 scanf("%*s");
3.#include "hotel.h"

headers
①hotal.h
1.#定义所有的符号常量
2.定义所有的函数原型


*查找地址&运算符
1.指针用于储存变量的地址，是一个值
2.地址常用十六进制表示，所以是%p
3.指针是一个变量
  ptr = &pooh;  //把pooh的地址赋给ptr
  ptr = &bah;   //把bah的地址也可以赋给ptr
4.*取这个地址所对应的值
5.声明指针
  声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的储存空间
  int * pi;   //*表明声明的变量是一个指针，pi是一个指针，*pi是int类型
6.使用指针解决函数之间通信的问题
   void main(void)
   {
	   interchange(&x,&y);    //该函数传递的不是x和y的值，而是他们的地址
   }
   void interchange(int * u,int * v)
   {
	   int temp;
	   temp = *u;     //这里用到*，意思就是传递的是他们的值
	   *u = *v;
	   *v = temp;
   }
7.使用指针变量和使用普通变量的不同
  int function1(int num)   //把main函数中的值拿来用，不改变main函数中的值
  int function2(int * ptr) //更改main函数当中的值
  scanf("%d",&num);    //scanf()读取一个值，然后把该值储存到指定的位置上
8.变量：名称，地址，变量的值
9.如果返回值的类型与声明的返回类型不匹配，返回值将被转换成函数声明的返回类型




*数组
1.[]内的数字表明数组中元素的个数，数组元素的编号从0开始
2.初始化数组int powers[8] = {1,2,3,4,5,6,7,8,9};  //powers[0] = 1;
3.可以使用一个常量来表示数组的大小
4.使用const声明数组
  const int days[MONTHS] = {1,2,3};  //就是在以后的过程中不能修
5.当初始化列表的值少于元素的个数时，编译器会把剩余元素都初始化为0，如果完全不初始化数组，数组元素
  储存的都是垃圾值；如果初始化列表的项数多于数组元素的个数，就会报错；也可以省略方括号中的数字，让编译器自动匹配数组
  大小和初始化列表中的项数
6.sizeof days是整个数组的大小（以字节为单位）。sizeof day[0] 是数组中一个元素的大小。整个数组的大小除以单个元素的大小
    就是数组中元素的个数
7.想初始化特点的元素    int arr[6] = {[5] = 212};//把arr[5]初始化为212，对于一般的初始化，在初始化一个元素后，未初始化
  的元素都会被设置为0
8.int days[MONTHS] = {31，28，[4] = 31,30,31,[1] = 29};    //[4] = 31,30,31如果指定初始化器后更多的值，这些值将被用于初始化
                       指定元素后面的元素；如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化
                  输出31  29   0   0  31  30  31  0
9.给数组元素赋值
  使用循环给数组中的元素依次赋值，c不允许把数组作为一个单元赋给另一个数组
10.数组边界
  如果程序中有其他变量，数组可能会占用这些变量的地址，将越界的数组元素在这些位置进行赋值，而原本这些位置的数字将会被改成数组元素
11.指定数组的大小
  声明数组时只能在方括号中使用整型常量表达式，而且必须大于0（sizeof表达式被视为整型常量，所以可以在方括号中调用） 
12.多维数组
   float rain[5][12];  //内含五个数组元素的数组，每个数组元素内含12个float类型的元素
					   //rain是一个内含五个元素的数组，一个内含12个float类型元素的数组 
   5表示行，12表示列——对一行数据求和（外循环控制行，内循环控制列递增）    ——对一列数据求和（外循环控制列，内循环控制行递增）
   
   {
	   {},
	   {},
	   {},
	   {}
   }
   
   初始化二维数组①如果列表中有一列的元素个数多出来了，会出错，但这不会影响其他行的初始化
				 ②初始化时也可以省略内部的花括号，只要保证元素的个数正确，如果不够，按照顺序初始化，不够的最后几个元素是0
13.其他的多维数组
一维数组一行数据   二维数组数据表   三维数组一叠数据表
int box[10][20][30];  //box内含十个元素，每个元素是内含有二十个元素的数组，这20个数组元素中每个元素是内含三十个元素的数组






*指针和数组
1.数组表示法是在变相的使用指针
2.short类型占用2字节，double类型占用8字节，int4字节，指针＋1指的是增加一个储存单元（每次增加对应类型的字节）
  对数组而言，这意味着加1后的地址是下一个元素的地址，而不是下一个字节的地址，这就是为什么必须声明指针所指向
  对象类型的原因之一
3.各种类型的含义
  dates[0]  取第0个元素的值        &dates[0]取第0个元素的地址     dates + 2 == &dates[2] //相同的地址
  *(dates + 2) === dates[2]   //相同的值   
4.数组名是该数组首元素的地址
5.int *ar形式和int ar[]形式都表示ar是一个指向int的指针（我感觉，ar是指向首元素的地址，ar[]就是可以可以指向
  一个数组的指针）
6.使用指针形参
  如何知道数组何时开始，何时结束
  marbles[10]是一个数组
  answer = sump(marbles,marbles + 10);//假设marbles是1，则加10为11（指向数组末尾的下一个位置，如果指向末尾得-1）
  int sump(int * start, int * end)
  {
	  int total = 0;
	  while (start < end)//所以这个循环肯定是十次
	  {
		  total += *start;
		  start ++;   //指向数组的下一个元素，start递增1相当于其值递增int类型的大小
	  }
  }
7.指针表示法和数组表示法
  只有当ar是指针变量时，才能使用ar++这样的表达式
  指针也有地址
  ptr1 + 4与&urn[4]等价    ptr3 - 2与urn[2]等价
  ptr2 - ptr1得2，意思是这两个指针所指向的两个元素相隔两个int
  
 ******************************************************************************************************************************************** 

*const在数组中的应用
1.数组别无选择，必须传递指针，效率高，如果在一个函数中使用double ar[]  []的意思就是ar是个指针
  所以数组传递过程中必须使用指针，一旦使用指针，就会改变main()函数中某些数的值
  int sun(const int ar[], int n)//使用const的意思就是不可以改变main()函数中相应数组的内容
2.使用#define 可以声明一些常量，但const的使用范围更广
3.const可以保护数组
  const int days[4] = {1,2,3,4};//如果之后程序员想要修改数组元素的值，编辑器将会生成一个编辑错误的消息
4.const和指针
  double rates[5] = {1.3,2.6,3.8,4.2,5.5};
  
  /**我懂了，rates原本的类型为double类型，但在这里写成了const double类型，就是pd保存的地址的值是不可以通过pd来修改的**/
  const double * pd = rates;  //pd指向数组的首元素，pd指向一个double类型的值const，不可更改的
                              //不能使用pd来更改它所指向的值（*pd = 29.3;   pd[2] = 222.22）这些都是不允许的，只起指向作用
                              //rates[0] = 99.9//允许，因为rates未被const限定，就是如果用指针，不可以修改，但不用指针还是可以修改的
                              //可以让pd指向别处  pd++//让pd指向rates[1]
  double * const pd = rates;  //可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址
  const double * const pd = rates;  //该指针既不能修改它所指向的地址，也不能修改指向地址上的值
  
  const放在*左侧的任意位置，限定了指针指向类型不能改变；const放在*的右侧，限定了指针本身不能改变
  只能把非const数据的地址赋给指针，否则，通过指针就能改变const数组中的数据
  不应该把const数组名作为实参传递给函数
  
  
  
*指针和多维数组
1.int zippo[4][2];
  zippo  是首元素的地址，这个首元素是内含两个int值的数组，zippo是这个数组的地址
  zippo[0]  一层是下一层的地址，zippo是zippo[0]的地址，*zippo表示zippo[0],zippo[0]是zippo[0][0]的地址 *(zippo[0])表示zippo[0][0]的值
            所以*zippo就是&zippo[0][0],所以**zippo与*&zippo[0][0]等价，也就是zippo[0][0];zippo是地址的地址的地址
            所以说zippo[0]是一个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地址
            由于最开始都是从首元素开始指的，所以zippo和zippo[0]的值相同
 给指针或地址加1，zippo指向的对象占用两个int大小（加8字节），而zippo[0]指向的对象只占用一个int大小（加4字节），所以值并不同
 对二维数组名解引用两次，得到储存在该数组中的值，使用两个*和[]都能获得该值，还可以使用一个*和一对[]
 与zippo[2][1]等价的指针表示法是*(*(zippo + 2) + 1)  //但是获取数组当中的值时，最好的方法是用数组表示法，而不是指针表示法
 
2.指向多维数组的指针
①int (* pz)[2];    //pz指向一个内含两个int类型值的数组
 int * pax[2];     //pax是一个内含两个指针元素的数组，每个元素都指向int的指针
②pz[0][0] = 2   *pz[0] = 2   **pz = 2
 pz[2][1] = 3   *(*(pz + 2) + 1) = 3   //虽然pz是一个指针，不是数组名，但是也可以使用pz[2][1]这样的写法
 
3.指针的兼容性
①指针之间的赋值比数组类型之间的赋值要严格。例如，不用类型转换就可以把int类型的值赋给double类型的变量，但是两个类型的指针
 不能这样做
②int **p2;   //一个指向指针的指针
③int (*pa)[3];   int ar1[2][3];     int ar2[3][2];
 pa = ar1;//有效，pa指向一个内含3个int类型元素的数组，所以它与ar1的类型兼容，但是ar2指向一个内含2个int类型元素的数组，所以pa与ar2不兼容
④把const指针赋给非const指针不安全，但是把非const指针赋给const指针没问题
4.函数和多维数组
①int junk[3][4]=.......
 total += sum(junk[i], 4);
 如果junk是二维数组，junk[i]就是一维数组，可将其视为二维数组的一行
②void ant(int [][4]);//第一个方格是空的，空的方格表明ant是一个指针
 void ant(int (* pt)[4]);//junk是一个指向数组，内含4个int类型值的指针
③想在一个函数中使用二维数组(声明这样的指针形参要指定所有的数组维度)
 void sum2(int ar[][4] , int rows);   //junk，ar都是指向一个内含4个int类型值的数组的指针；rows是第一个[]里的数，只是通过int来传递
 void sum2(int ar[3][4] , int rows);  //有效声明，但是3将被忽略
 void ant(int (* pt)[4]);     //以上这三种形式都可以声明二维数组
④一般而言，声明一个指向n维数组的指针时，只能省略最左边方框中的值，因为第一对方框只用于表明这是一个指针，而其他的方括号则用于描述
  指针所指向数据对象的类型
  
  
  
  
*变长数组
1.void sum2(int ar[][4] , int rows); //这种的缺点就是，把列数固定为4，而行数被传给rows，如果要计算6行5列的数组，则不能使用这个函数
                                     //而且C语言规定，4那里必须是一个固定的量，是数组的维度，不能改变
2.变长数组允许使用变量来表示数组的维度
3.声明int sum2d(int rows,int cols,int ar[rows][cols])  //ar是一个变长数组
      int sum2d(int, int, int ar[*][*])//省略了维度形参名，而且必须加上*
4.int sum2d(int rows,int cols,int ar[rows][cols])
{
	ar[0][0] = 2;  //把main函数中的thing[0][0]设置为2
}
 

 *复合字面量
 1.字面量是除符号常量外的常量（5是int型字面量    81.3是double型字面量   'Y'是char型字面量     "apple"是字符串字面量）
 2.声明(int [2]){10, 20}  //正常int dive[2] = {10,20};  省略了dive就可以
 3.因为复合字面量是匿名的，所以不能先创建再使用它，必须在创建的同时使用它
   int * pt1;
   pt1 = (int [2]){10, 20};  //复合字面量的类型名也代表首元素的地址，所以可以把它赋给指向int的指针
 4.复合字面量和函数的结合
   int sum(const int ar[], int n);
   int total 3;
   total3 = sum((int []){4,4,4,5,5,5},6);
 5.把信息传时不必先创建数组，这是复合字面量的典型用法
 6.应用于二维数组
   int (*pt2)[4];  //声明一个指向二维数组的指针，该数组内含2个数组元素   每个元素是内含4个int值的数组
   pt2 = (int [2][4]){{1,2,3,4},{5,6,7,8}};//该复合字面量的类型是int [2][4]
   
   
*大概总结一下
1.无法简单声明一个数组，在声明数组时必须声明其元素的类型
2.为了处理数组，函数必须知道是从何时开始读取数据和要处理多少个数组元素。数组地址提供了地址，元素个数可以作为单独的参数传递
3.指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改变
4.第一个一维数组是sales[0]   第二个一维数组是sales[1]


*****************************************************************************************************************************************************************

*字符串
1.字符数组：char big[8] = {1,2,3,4,5,6};
  字符串：以空字符\0结尾的char类型数组
          char words[81] = "i love anita and stefanie";
		  const char * pt1 = "i love anita and stfanie"; //pt1储存的就是"i love anita and stfanie"的地址
		  conat char words[81] = {'i','','l','o','v','e','','a','n','i','t','a','\0'};  //末尾的\0也占一个字符
		  words[8] = 'p';  //8就是第9个元素，从右往左数，空格也算，数9个
		  char words[] = "i love anita and stfanie"; //编译器会自动确定数组的大小
          二维数组
		  //嘻嘻嘻，如果是mytalents[][5];就表示有5行，第一个[]表示是一个指针
          const char *mytalents[5] = {"i love anita","i love anita","i love anita","i love anita","i love anita"}; 
          char yourtalents[5][40] = {"i love anita","i love anita","i love anita","i love anita","i love anita"}; 
          mytalents[1][2]和yourtalents[1][2]都是一个意思，且都是从0开始数
          mytalents数组是一个内含5个指针的数组，且指针指向字符串字面量的位置，这些字符串字面量被储存在静态内存中，不可以更改
          yourtalents被储存在字符串字面量的副本，可以更改
          mytalents只规定了只有五个指针，并未规定每个字符串中放几个字符；yourtalents规定了字符串的数量，和字符串中可以放的最大元素个数
                  如果没有放满，其余位数都将会用\0来补齐，而mytalents只会在每个字符串末尾放一个\0
				  
2.输入函数（我的天哪，这些函数都是用来输入输出字符串的）
①char *name;
 scanf("%s",name);  //没有规定name的地址，意思就是可以把name放到任何地方。但是如果char name[80];就表示name是一个已分配块的地址
②gets()读取整行输入，直至遇见换行符，丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使它成为一个字符串
  char words[8];   gets(words);   puts(words);   //总的来说，这是一个不好的函数，已经被摒弃，不要使用，会出错
③fgets(words,9,stdin); //第二个参数指明了读取字符的最大数量，将会读8个，剩下一个存\0，或者读到遇到的第一个换行符为止，而且会把换行符储存在字符串中
                       //在正常情况下ggets()会返回第一个参数的地址，但是，如果读到文件结尾，将会返回空指针（NULL）
                       //如果超出了最大储存的字符，但是程序是使用循环进行读取的，就会让fgets先读取一部分，在末尾加\0，再读取一部分，最后读取在末尾加\n\0
					   //最好的选择
 fputs(words,stdout);  //fgets和fputs一个会储存换行符，一个不会显示换行符，这一对形成了互补
 fgets9();             //储存的时候 i love Anita\n\0
 
 如何处理掉换行符
 while(word[i] != '\n')
    i++;
 words[i] = '\0';    //在已储存的字符串中查找换行符，并将其替换成空字符
 
 丢弃多出来的字符(我废了，我实在是看不懂这个了)  //为什么要丢弃过长输入行中的余下字符，输入行中多出来的字符会被留在缓冲区中，成为下一次读取语句的输入，丢弃
                                                 //输入行余下的字符保证了读取语句与键盘输入同步
 while (getchar() != '\n')
    continue;
	
④gets_s(words,8)    //如果get_s读到换行符，会丢弃它，而不是储存他
					//如果读到最大字符数都没有读到换行符，会执行如下几步，首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换行符
					  或文件末尾，然后返回空指针，接着，调用依赖实现的“处理函数”（或你选择的其他函数），可能会终止或退出程序
					//只要输入行未超过最大字符数，和gets()几乎一摸一样



3.输出函数
①puts函数只显示字符串，而且自动在显示的的字符串末尾加上换行符，把字符串的地址作为参数传递给它即可，在遇到空字符时就停止输出，如果没有遇到空字符
 就会继续打印下头的字符串，直到遇到空字符
②scanf()函数返回一个整数值，该值等于scanf成功读取的项数或EOF，当scanf遇到空格或此数组储存空间已满的情况，将会把剩下的字符换到下一次读取
③fputs()函数，不会在输入的末尾添加换行符
 如果混合使用fgets输入和puts输出，每个待显示的的字符串末尾就会有两个换行符
④，只要遇到字符串，都得加""




4.用双引号括起来的内容称为字符串面量，也叫做字符串常量，双引号中的字符和编译器自动加入末尾的\0字符，都作为字符串储存在
  内存中
5.字符串常量被视为静态储存类别，只会被储存一次，在整个程序的生命期内存在，类似于把数组名作为指向该数组位置的指针
  字符串储存在静态储存区中，程序在开始时才会为该数组分配内存（此时的字符串有两个副本，一个是在静态内存区的字符串字面量
  另一个是储存咋数组中的字符串）
  printf("%c",*"space farers");  //*"space farers"表示该字符串所指向地址上储存的值，应该是字符串*"space farers"的首字符
6.[]里加的是数组的大小，数组的大小必须是整型常量，包括由整型常量组成的表达式（sizeof()）
7.字符数组名和其他数组名一样，是该数组首元素的地址
  char car[10] = "Tata";
  car == &car[0]   *car == 'T'    *(car + 1) = car[1] == 'a';
  
8.数组和指针
①例如上头的这个words字符串，words是一个地址常量，如果改变，就意味着改变了数组额储存位置，可以进行类似ar1 + 1这样的操作
 表示数组的下一个元素，但是不允许进行++ar1，意思就是让地址加1，地址是不能改的
②如果是上头这个指针形式，会把字符串的地址储存在指针变量中，该变量最初指向该字符串的首地址，但是它的值可以改变，指针嘛
 比较随便++pt1表示指向第二个字符
③如果在外头加const ，不能用const改变它所指向的数据，可以改变pt1指向的位置（const就是用来限定后面的字符串的）


9.数组和指针的区别
①char heart[] = "apple i like";
 const char *head = "i love anita";
 数组名是常量，而指针名是变量
②两者都可以使用数组表示法
 putchar (heart[i]);    putchar (head[i]);
③两者都能进行指针加法操作
 putchar(*(heart + i));    putchar(*(head + i));
④但是，只有指针表示法可以进行递增操作
 putchar(*(head++));
⑤不能heart = head; //赋值运算符的左侧必须是一个变量，是可修改的左值，这样做不会导致head指向的字符串消失，这样做
  只是改变了储存在head中的地址，当head指向别处时，就无法再访问该字符串
⑥还可以改变heart数组中元素的信息
 heart[7] = 'M';       *(heart + 7) = 'M';  //数组的元素是变量，但数组名不是变量
 head[1] = '1';     //如果head是没有加const的，不能使用这样指针的方法来改变数组中的元素
⑦建议指针初始化时加const限定符，之后不会出现一些问题
  但如果之后要修改值的话，就不要加const
 
10.指针和字符串
const char * mesg = "i love anita";
const char * copy;
copy = mesg;   //意思就是copy是一个指针，把mesg首元素的地址赋给copy，所以这两个指针的指向相同




10.空字符、空指针、EOF
   空字符：\0，是用来标记字符串末尾的字符，对应字符编码是0，空字符是一个字符，占一个字节
   空指针：指针类型，是一个地址，不会与任何数据的有效地址对应，占有四个字节，用于指针类型的末尾或错误
   EOF：是-1，普通的整型变量，当返回EOF时，代表函数出错，到达了文件尾


   

   
   
   
下面这几个函数头文件都是sting.h(strlen strcmp strcpy strcat strchr strstr)  
11. strcat()函数   //把两个字符串拼接，放在第一个里面，strcat()函数类型char，返回值是第一个地址
    strcat(flower, addon);
	但是它无法检查第一个数组是否能容纳第二个字符串，要给拼接后的字符串加1才够空间存放末尾的字符串
12.strncat(bugs,addon,13) //可以控制数组的大小    strncpy()  //同样可以控制数组的大小
   有两个字符串s和t，我们希望这两个字符串连接成单个字符串r
   char *r;
   strcpy(r, s);
   strcat(r, t);
   //不成功，不仅要让r指向一个地址，而且r所指向的地址处还应该有内存空间可容纳字符串
   
   char r[100];
   strcpy(r, s);
   strcat(r, t);
   //c强制要求我们必须声明数组大小为一个常量，因此我们不够确保r足够大
   char *r, *malloc();   //malloc的类型必须和r完全相同，声明一个malloc变量
   r = malloc(strlen(s) + strlen(t) + 1);  //strlen()是测量不包括空字符的长度
   if(!r)  //malloc函数有可能无法提供请求的内存，这种情况下malloc函数会返回一个空指针作为内存分配失败的信号
   {
	   complain();
	   exit(1);
   }
   strcpy(r, s);
   strcat(r, t);
   
   free(r);//分配内存使用之后应该及时释放
   
13.strcmp()函数。该函数通过比较运算符来比较字符串，就像比较数字一样,比较所有字母
  strcmp("A","B")is -1			strcmp("B","A")is 1     strcmp("C","A")is 2   strcmp('a','A')is 32    空格的ASCII码是32
  //strcmp比较两个字符串，并输出两个字符串的差值
    int idx = 0;
    while()
    {
        if(s1[idx] = s2[idx])
            break;
        else if(s1[idx] == '\0')
            break;
        idx++;
    }
    return s1[idx] - s2[idx];
    
    
    int idx = 0;
    while(s1[idx] == s2[idx] && s1[idx] != '0')
        idx++;
    return s1[idx] - s2[idx];
    
    
    while( *s1 == *s2 && *s1 != '\0')
    {
        s1++;
        s2++;
    }
    return *s1 - *s2;
    
14.
strncmp("apple","astro",1);  //比较这两个数组的第一个字符是否相等
14.sprintf()函数
把多个元素合成一个字符串，sprintf()的第一个参数是目标字符串的地址，其余参数和printf()相同的值
sprintf(formal,"%s  %s   %f",last,first,prize);   //formal是目标字符串的地址



   
    
14.strlen(返回字符串长度，不包括结尾的0)
15.strcpy()
拷贝整个字符串
如果是
char * str;
strcpy(str,"The c of");//str未被初始化，所以该字符串有可能被拷贝到任意地方
声明数组将分配储存数据的空间，而声明指针只分配储存一个地址的空间
strcpy返回的是第一个参数的值，即第一个字符的地址
ps = strcpy(copy + 7,orig);   //copy + 7(就是从第八个开始算) == be the best that you can be\0
							  //orig == beast\0
							  //连接起来  be the beaet\0hat you can be\0
							  //打印出来be the beast
使用const，函数不会更改字符串
char *strcpy(char * restrict, const char * restrict s2);  //第二个不能随便改，第一个可以改

    char *strcpy(char *restrict dst,const char *restrict src);
    把src的字符拷贝到dst    restrict表明src和dst不重叠(c99)     返回dst
    
    复制一个字符串
    char *dst = (char*)malloc(strlen(src) + 1);
    strcpy(dst,src);
    
    char* ret = dst;   //指向dst的指针
    while(*src != '\0')
    {
        *dst = *src;
        dst++;
        src++;
    }
    *dst = '\0';  此时dst指向的是末尾的地址
    return ret;
    
    
    while( *dst++ = *src++);
    *dst = '\0';
    return ret;
16.strncpy(target,source,n) 
   /*把source中的n个字符或空字符之前的字符拷贝到target中，如果字符数小于n，拷贝整个字符串，包括空字符，如果超出去
   就不会拷贝空字符*/

16.strchr
  int main(int argc, char const *argv[])
  {
    char s[] = "hello";
    char *p = strchr(s, 'l');
    p = strchr(p + 1, 'l');
    printf("%s\n", p);
  }  
   
  输出的值是lo
  
  int main(int argc, char const *argv[])
  {
    char s[] = "hello";
    char *p = strchr(s, 'l');
    char *t = (char*)malloc(strlen(p)+1);  //t所占的内存空间
    strcpy(t,p);
    printf("%s\n",t);
    free(t);    //头文件 malloc.h  释放malloc函数给指针变量分配的内存空间的函数，使用后该指针变量一定要从新指向NULL，防止野指针出现
    t = NULL;
  
  }  
  输出的值是llo
  
  
  int main(int argc, char const *argv[])
  {
    char s[] = "hello";
    char *p = strchr(s, 'l');
    char c = *p;
    *p = '\0';
    char *t = (char*)malloc(strlen(s)+1);
    strcpy(t,s);
    printf("%s\n",t);
    free(t);
  }  
  输出的值是he
  
  
  
  
  
  
  
  
  
  
  
  
  
  
14.地址和存放值之间的关系
   10000      'F'
   
   10005
   10006      123
   10007
   10008

15避免使用未初始化的指针.
int *a;
*a = 123;
16.char str[128];
   scanf("%s",str);     //因为str本身就是首元素的地址，所以不用取地址符号，所以说数组就是指针，指针就是数组
   
17.void
   void指针是通用指针，就是可以指向任意类型的数据，也就是说，任何类型的指针都可以赋值给void指针
   而且void指针可以强制类型转换
   int num = 1024;
   int *pi = &num;
   char *ps = "fishc";
   void *pv;
   pv = pi;
   printf("pi:%p pv:%p\n",pi,pv);
   
   //ps = (char *)pv;
    
   pv = ps;
   printf("ps:%p pv:%p\n",ps,pv);
   //printf("pv:%s\n",(char *)pv);
   
   
18.NULL指针（当还不清楚将指针初始化为什么地址时，将它初始化为NULL，防止他乱指）
  #define NULL((void *)0)
  int *p1;
  int *p2 = NULL;
  

19.char point[4][10] = {"语文","英语","数学","物理"};  //定义的时候这样定义
    找到语文    point[0];//就可以了   第二个括号里尽量写多  而且对应的是%s
	
	  
20.选择排序法
  利用for循环把每个元素与首元素进行比较，遍历每个元素，则第一个是最大
  再把每个元素与第二个元素进行比较，遍历每个元素，则第二个是最大

21.ctype.h字符函数和字符串
 toupper();      //把小写转换成大写
 ispunct();		 //计数标点符号
 
22.命令行参数
 在windows命令提示下的模式是
 c > fuss（一个文件中有一个名为fuss的程序）
 int main(int argc, char *argv [])    // *argv[]指针的指针
 {
	 for(count = 1; count < argc; count++)
	 {
		 printf("%d %s", count,argv{count});
	 }
 }
 
 
 repeat       i'm            fine
 argv[0] 	argv[1]         argv[2]
 repeat    "i am hungry"     now
 
 
 23.把字符串转换成数字
   数字既能以字符串形式储存（'2'、'3'、'\0'）
   以数字形式储存213
   atoi()函数（把字母数字转换成整数）
   atoi("42regular")  将返回整数42     如果一个数字都没有，返回0
   
   
   
====================================================================================================================================================================================  
   
*结构（一种数据形式能包含各种数据类型，还可以保持各信息的独立）
1.声明结构的形式
  struct point{                struct point{						struct{
	  int x;					 int x;							int x;
	  int y;					 int y;							int y;
  };						         } p1,p2;					  }p1,p2;
  struct point p1,p2;
  
2.结构变量
struct date{
	int month;
	int day;
	int year;
}

struct date today，yesterday;  //后面可以跟多个


date  是结构布局    today是结构变量

//可以这样赋值
today.month = 06;
today.day = 19;
today.year = 2005;

//也可以这样赋值
today = (struct date){07,31,2014};   
struct date day;
day = today;    //可以这样把today当中的值赋给day


//当然，也可以这样赋值
struct date today = {07,31,2014};
struct date thismonth = {.month = 7,.year = 2014};//没有初始化的值就是0

struct book gift = {
	.value = 18.90,
	.author = "anita with",
	0.25(是value的值)   //之前定义过value值，但.author的下一个就是value，所以最终value的值就是0.25
};

//意思就是虽然day中已经有值了，但是还可以修改了
day.year = 2015;


3.结构指针
①和数组不同，结构变量的名字并不时结构变量的地址，必须使用&运算符
  struct date *pDate = &today;
  &date.month  //若是scanf("%d",&date.month); 意思就是可以通过指针来改变main函数里的值，如果不用指针，就改不了
②big = cat;  //把一个结构赋给另一个结构
 struct names right_field = {"ruthie", "george"};
 struct names captain = right_field;
  
4.在函数内部声明只能在函数内部使用
  在函数外部声明就可以被多个函数使用
        
5.结构运算
①要访问整个结构，直接用结构变量的名字

6.int numberdays(struct date d)
  整个结构可以作为参数的值传入函数
  
7.指向结构的指针
  struct date{
	  int month;
	  int day;
	  int year;
  }myday;
  
  struct date *p = &myday;
  (*p).month = 12;
  p->month = 12;  //用->表示指针所指结构变量中的成员，是一个值，而不是地址
  指向结构的指针通常比结构本身更容易操作，指针传递更有效率
  7.1声明和初始化结构指针
  struct guy barney;
  struct guy * him;
  him = &barney;    
  如果
  him == &barney;  //那么him->income 即是 barney.income;  也就是(*him).income;
  him == &fellow[0]; //那么him->income 即是 fellow[0].income;  也就是(*him). income;
  
  
8.结构数组
  struct date dates[100];  //[]里的意思就是有5个这样的花括号
  struct date dates[] = {
	  {4,5,2005}{2,4,2005}
  }; 
  
  
  例如：
  struct time{
	  int hour;
	  int minutes;
	  int second;
  };

  int main(void)
  {
	  struct time testTimes[5] = {
		  {11,59,59},{12,0,0},{1,29,59},{23,59,59},{19,12,27}
	  };  //初始化数组，使用方式和数组一样
  }
  
8.1声明结构数组
struct book library[MAXBKS];
library[2].title[4];   //这是library数组的第三个结构变量中书名的第五个字符

//首先这个数量应该小于书籍的最大数量，需要输入的是library这个数组里面的title这个地址应该不为空，且title的首字符不为\0
//如果在一行开始处按下enter键，相当于输入了一个空字符，循环将结束
while(count < MAXBKS && s_gets(library[count].title, MAXTITL) != NULL && library[count].title[0] != '\0')
  

  结构数组中的值被储存在栈中，如果[]里的值很大，需要很大一块内存，如果出现错误，有可能导致溢出，可以创建静态或外部数组，这样编译器就不会吧数组放在栈中
  

9.结构中的结构
 struct point{
	 int x;
	 int y;
 };
 struct rectangle {
	 struct point pt1;
	 struct point pt2;
 };
 
 
 
10.如果有变量
     struct rectangle r;
 就可以有
     r.pt1.x   r.pt1.y     也可以写成 r->pt1.x   (r->pt1).x   但是没有r->pt1->x(因为pt1不是指针)
	 r.pt2.x   r.pt2.y
  
 初始化结构中的结构
struct rectangle rects[] = {
	{{1,2},{3,4}},
	{{5,6},{7,8}}
}; 
 
11.
typedef struct _myTime    /*使用typedef  struct _myTime（相当于变量名int char啥的） MyTime相当于一个变量名 
                             使用typedef就相当于用MyTime代替了struct _myTime*/
{
    int years;  int month;  int day;
}MyTime;



typedef struct _hero
{
    char name[50];     //或者是char *name; 用指针的方法
    char sex;
    char job[20];
    int life;
    double speed;
    char abillity[20];
    MyTime pubTime;   //英雄的上线时间      
}Hero;

Hero heros[] = {
    {"影流之主劫",'m',"刺客",579,0.644,"位移",{2012,8,15}},
    {"琴瑟天女娑娜",'f',"法师",482,0.644,"减速治疗",{2010,9,20}},
    {"疾风剑豪",'m',"战士",517,0.67,"护盾，位移",{2013,12,23}}
};

void Show()
{
    //如何知道结构数组的大小呢*******
    int len = sizeof(heros) / sizeof(Hero);  //sizeof(heros)就是一共有21个东西；sizeof(Hero)就是一个Hero里有七个元素
    printf("结构数组的元素个数：%d\n",len); 
	
	
	
	//数组元素使用指针时，动态赋值首先需要分配内存
    printf("请输入名称：");
    heros[0].name = (char *)malloc(50);
    scanf("%s",heros[0].name);

}

lifeOfSum += heros[i].life;     //指针写法lifeOfSum += (heros + i)->life;


typedef struct Student
{
	int sid;
	char name[100];
	char sex;
}*PST，ST;  //Pst等价于struct Student*      ST等价于struct Student

12.初始化结构和类别储存期
如果初始化静态储存期的变量，必须使用常量值。如果初始化一个静态储存期的结构，初始化列表中的值必须是常量表达式（静态就是一直存在，常量就是确定的值）

13.结构指针和结构返回值
//使用指针可以直接传指针来改变main函数里的那个值,传递的是person的地址，实际上是直接处理person的值
//不使用指针，可以通过返回值来改变  person先被拷贝到info中 函数处理的是这个副本
struct namect makeinfo(struct namect info)
{
	info.letters = strlen(info.fname) + strlen(info.lname);
	
	return info;
}
    13.1结构返回值和结构指针的选择
	    指针只需要传递一个地址，缺点是无法保护数据，但是加const就可以了
		结构优点是函数处理的是原始数据的副本，这保护了原始数据，代码风格也更加清楚
		    缺点：老版本无法使用，传递结构浪费时间和储存空间。尤其是把大型结构传递给函数
	13.2
		struct names{
			char first[LEN];
			char last[LEN];
		};
		
		struct pnames{
			char * first;
			char * last;
		};
		
		struct names veep = {"Talia", "Summers"};  //这个储存在结构内部，结构总共要分配40字节储存姓名
		struct pnames treas = {"anita", "mui"};    //这个字符串储存在编译器储存常量的地方，结构本身只储存了两个地址，总共占16字节
												   //在pnames结构变量中的指针应该只用来在程序中管理那些已分配和在别处分配的字符串
		struct names accountant;
		struct pnames attorney;
		scanf("%s", accountant.last);    //可以储存
		scanf("%s",sttorney.last);		//把字符串放到sttorney.last表示的地址上，由于这是未经初始化的变量，地址可以是任何值，有潜在危险
		
14.结构、指针、和malloc()   
struct namect
{
	char * fname;    //用指针代替数组
	char * lname;
	int letters;
};
void getinfo (struct namect * pst)
{
	char temp[20];       //定义一个临时数组
	s_gets(temp, 20);    //往这个临时数组里输入值
	pst->lname = (char *) malloc(strlen(temp) + 1);     //往这个实际的指针里分配内存，(char *)是lname的类型，强制类型转换，temp是临时数组的长度
	strcpy(pst->fname, temp);   //最后用复制函数，这个字符串并未储存在结构中，它们储存在malloc分配的内存中，结构中储存着这个字符串的地址，malloc的内存从虚拟储存器中来
	free(pst->fname);      //释放内存
};

15.复合字面量和结构
暂时理解的程度:现用现配，用完就没
if(score >= 84)
	readfirst = (struct book){
		"i love anita",
		"i love stefanie",
		11.25
	};
else
    readfirst = (struct book){
		"this is apple",
		"this is pear",
		22.34
	};
   
16.函数和指针
函数的指针常用作另一个函数的参数，指向函数的指针中储存着函数代码起始处的地址
区分
void (*fp)(char *);//fp是一个指向函数的指针
void *fp(char *);	//pf是一个返回字符指针的函数

声明函数指针后，可以把类型匹配的函数地址赋给它
void ToUpper(char *);
void ToLower(char *);
int round(double);
//这个是要在main函数里写的
void (*pf)(char *);
char mis[] = "anita mui";

pf = ToUpper;  //有效，都是void类型
pf = ToLower;  //有效
pf = round;   //无效 类型不匹配
pf = ToLower();     //无效，ToLower()不是地址
//这个是如何调用，分两步和某函数相等，第二步，调用函数输进去参数
pf = ToUpper;
(*pf)(mis);  //把ToUpper作用于语法1  *pf相当于ToUpper函数，
pf = ToLower;
pf(mis);   //把ToLower作用于语法2    pf也相当于ToUpper函数
                                   //pf和*pf等价

//调用函数使用传入的指针
show(pf, mis);
void show(void (* fp)(char *), char * str)  //也可以typedef void (* ABC)(char *);  那么这个可以写成void show(ABC fp, char * str)
{
	(*fp)(str);  //把函数作用于str
	puts(str);  //显示结果
}


functional(sqrt);    //传递函数的地址，可以在function调用这个函数
funcyional(sqrt(4.0));   //传递的是sqrt(4.0)的返回值，是一个值




****
联合
和struct几乎一样，就是把struct改成了union，struct是 内部变量独立内存空间，union是给他一块内存，只能放一种，这样节省空间
所有成员共享一个空间  同一时间只有一个成员是有效的  union的大小是其最大的成员
枚举类型(使用enum关键字)  //enum是int类型

//这个声明在外边
enum spectrum {red, orange, yellow, green, blue, violet}; //red代表整数0，orange代表整数1.......  是一个有名称的常量
int main()
{
	enum spectrum color;
	if(color == yellow)
	 ......;
	for(color = red; color <= violet; color++)
	  ......;
}
如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被赋予后续的值，例如:
enum feline {cat, lynx = 10, puma, riger};  //cat == 0,puma,tiger 11,12






=======================================================================================================================
1.typedef的意思  定义了一个别名
typedef int a[10];    //把a声明为具有10个int元素的数组的类型别名
typedef void(*Fun)(void);    /*把Fun定义为一个可以指向任意地方的指针，没有加上typedef，fun为类型名
                      加上typedef，fun为类型名*/
typedef char (*FRPTC ()) [5]; //把FRPTC声明为一个函数类型，该类型返回一个指针，该指针指向内含5个char类型元素的数组
**********************
*复杂的声明([]和()具有相同的优先级，比*高，[]和()都是从左往右结合)
int *risks[10];//  相当于(int *) risk[10];  //声明一个内含10个元素的数组，每个元素都是一个指向int的指针
int (*rusks)[10];  //声明一个指向数组的指针，该数组内含10个int类型的值
int (*uuf)[3][4];   //声明指向二维数组的指针，该数组中内含int类型值
int (*uof[3])[4];   //声明一个内含3个指针元素的数组，其中每个指针都指向一个内含4个int类型元素的数组
float *pf;  /*我终于懂了float相当于浮点型，是一个数字，*pf 是取pf的值      也就是*pf是一个浮点数  pf是一个指向浮点数的指针*/
float *g(), (*h)(); //g是一个函数，该函数的返回值类型为指向浮点数的指针，h是一个函数指针，h所指向函数返回值的类型为浮点类型
  
  

2.char unit[10][4]={"零","壹","贰","叁","肆","伍","陆","柒","捌","玖"};  //汉字和数字不一样，汉字相当于两个字母，所以用二维数组
  
3.
//如何将1234转换成壹仟贰佰叁拾肆元整
    int money,count=0;//count是数字的位数
    int i=0;
    int moneys[6];//默认支持6位数字
    //写数组时就应该这样写，10是代表有几个，4是表示这个可以包含多少
    char unit[10][4]={"零","壹","贰","叁","肆","伍","陆","柒","捌","玖"};  //汉字和数字不一样，汉字相当于两个字母，所以用二维数组
    printf("请输入金额：");
    scanf("%d",&money);
    //判断用户输了几位数字，并将每一位数字取出来
    while(money != 0)
    {
        moneys[i]=money % 10;
        money /= 10;
        i++;
        count++;                                                         //问题就是为什么count是局部变量，还可以改变值
    }
    printf("用户输入的数字一共有%d位！\n",count);
    printf("数组中的内容：\n");
    for(i=0;i<count;i++)
    {
         printf("%d - %s\n",moneys[i],unit[moneys[i]]);
    } 
  
4.
	//ceil-进一法  floor-退一法   只要不是整数，不管四舍五入ceil就进一位，floor就退一位
    //如果是负数，规律相反
    printf("%.2lf\n",ceil(-98.1));
    printf("%.2lf\n",floor(-98.1));
    printf("%.2lf\n",sqrt(9));
    printf("%.2lf\n",pow(5,2));//求第一个数字的第二个数字次幂
    printf("%.2d\n",abs(-98));//求绝对值
	exit(0); //0.正常退出应用程序 非零就是非正常退出
 

5.动态分配内存，编译的时候，没有内存，程序运行的时候，再分配内存
	malloc (int*)malloc(4*5);
	calloc calloc(5,4) //刚好是反过来的，总共有5个元素，占四个字节空间//不需要强转，返回值直接就是一个数组，
	                   //好处是可以把每个元素初始化
	free 释放动态分配的内存
	realloc 从新分配内存
	
	
	 system("color 7D");
    int * nums;
    int i;
    nums = (int * )malloc(20);//1.为前面的指针动态分配了20个字节的空间
                              //2.为指针动态分配空间后，指针就变成了数组
                              //3.上面两句话等价于：int num[5];
							  
	 nums = (int * )malloc(sizeof(int)*5);//1.为前面的指针动态分配了20个字节(5个整型)的空间
                                         //2.好处：不用关心int有几个字节，就是要5个元素					
  
  free(nums);  //free()函数的参数是之前malloc()返回的地址，释放内存
  nums = NULL;  //nums是一个指针，只有在指针内才经常使用NULL，而且直接等于就好，不用加其他
①有些内存是自动分配的float x;   //静态数据在程序载入内存时分配，自动数据在程序执行块时分配。并在程序离开该块时销毁
②malloc返回动态分配内存块的首字节地址，可以把改地址赋给一个指针变量，并用指针访问这块内存，如果分配内存失败，返回空指针
③void指针不用考虑类型匹配
 double * ptd;
 ptd = (double *) malloc (30 * sizeof(double));   //为30个double类型的值请求内存空间，30可以是任意值，ptd的使用方法和数组一样
 ***********
 声明数组的三种方法
 ①int side[10];
 ②声明变长数组
	*变长数组
	1.void sum2(int ar[][4] , int rows); //这种的缺点就是，把列数固定为4，而行数被传给rows，如果要计算6行5列的数组，则不能使用这个函数
										 //而且C语言规定，4那里必须是一个固定的量，是数组的维度，不能改变
	2.变长数组允许使用变量来表示数组的维度
	3.声明int sum2d(int rows,int cols,int ar[rows][cols])  //ar是一个变长数组
		  int sum2d(int, int, int ar[*][*])//省略了维度形参名，而且必须加上*
	4.int sum2d(int rows,int cols,int ar[rows][cols])
	{
		ar[0][0] = 2;  //把main函数中的thing[0][0]设置为2
    }
 ③声明一个指针，调用malloc，将其返回值赋给指针，使用指针访问数组的元素
 ************
④free()的重要性
动态分配的内存数量只会增加，除非用free()释放，free和malloc储存的地址必须相同，参数可以不相同
函数结束时，动态分配的内存还会在，由于指针已被销毁，所以无法继续访问这块内存，这样循环下去，就会耗尽所有的内存
不能释放同一块内存两次









  
*储存类别、链接和内存管理
1.使用的数据都存在内存中，储存值的一块内存称为对象。对象可以储存一个只会或多个值。一个对象可能并未储存实际的值
  但是它在储存适当的值时一定具有相应的大小
2.int *a = b;  //a、b是标识符，也是左值   *a不是标识符，是表达式，也是左值  
  const char * pc = "i love anita";  //每个字符也是一个对象，标识符pc是一个可以修改的左值
3.储存期是指对象在内存中保留了多长时间，不同的额储存类别有不同的储存期
  标识符用于访问对象，可以用作用域和链接描述标识符
4.作用域
——块作用域（就是加{}的）
①
int main()
{
    int i;
    for(i = 0;i < 5;i++);
    printf("%d",i);
}

i的值是5，i是全局变量，可以通过for循环来改变i的值
②
int main()
{
	while(1)
	{
		int i;
		for(i = 0;i < 5;i++);  //只能在这个作用域内使用i，在块中就近定义方便
	}
}
③
具有块作用域的变量都必须声明在块的开头，C99允许在块中的任意位置声明变量
for(int i = 0;i < 10;i++)
④如果内层块中声明的变量和外层块中的同名，内层块会隐藏外层块中的含义，但是离开外层块后，外层块变量的作用域又回到了原来的作用域
int x = 30;
while(x++ < 33)   //而这个可以改变外部x的值，最后是34
{
	int x = 100;
	x++;  //这个输出来的x一直都是101
	
}

——函数作用域


——函数原型作用域
①函数原型作用域的范围是从形参定义处到原型声明结束，编译器在处理函数原型中的形参只关心它的类型
  只有在变长数组中，形参名才有用
1.void sum2(int ar[][4] , int rows); //这种的缺点就是，把列数固定为4，而行数被传给rows，如果要计算6行5列的数组，则不能使用这个函数
                                     //而且C语言规定，4那里必须是一个固定的量，是数组的维度，不能改变
2.变长数组允许使用变量来表示数组的维度
3.声明int sum2d(int rows,int cols,int ar[rows][cols])  //ar是一个变长数组
      int sum2d(int, int, int ar[*][*])//省略了维度形参名，而且必须加上*
4.int sum2d(int rows,int cols,int ar[rows][cols])
{
	ar[0][0] = 2;  //把main函数中的thing[0][0]设置为2
}
 
  
  
——文件作用域
  
5.链接
——外部链接
可以在多个文件中使用
外部链接的文件作用域简称为全局作用域或程序作用域
——内部链接
只能在一个翻译单元中使用
内部链接的文件作用域简称为文件作用域
——无链接
函数作用域或函数原型作用域 

6.储存期
——静态储存期
在程序执行期间一直存在
以static声明的文件作用域具有内部链接，所有的文件作用域变量都具有静态储存期（静态的意思该变量在内存中原地不动，并不是说它的值不变）
void more(int number)
{
	int index;
	static int ct = 0;         //ct从程序被载入到程序结束期间都存在，但只能被用在more()函数里，可以通过指针用到别的函数里
}


——线程储存期
程序可以被分为多个线程，在每个线程中，具有线程储存期的对象，从被声明时到线程结束一直存在
而用_Thread_local声明一个对象时，每个线程都获得该变量的私有备份


——自动储存期
块作用域的变量通常具有自动储存期，当程序进入定义这些变量的块时，为这些变量分配内存，当退出这个块时，释放刚才为变量分配的内存
且该变量原来占用的内存位置现在可做它用
变长数组稍有不同，他们的储存期从声明处到块的末尾，而不是从快的开始处到块的末尾
①自动变量
属于自动储存类别具有自动储存期，块作用域且无链接，声明在块或函数头中的任何变量都属于自动储存类别，默认就是自动存储类别


——动态分配储存期
  
6.一些说明符的类型
①static   
定义全局的静态变量 
void trystat(void)
{
	int fade = 1;//每次调用这个函数，fade的值每次被重新弄成1
	static int stay = 1;//静态储存期，在整个程序中保留了stay递增以后的值，这个声明并不是trystat函数的一部分，这个声明在程序刚开始
	                    //运行，在程序结束后结束，放到这个函数里，是只有在这个函数里能用，别地不能用，但一直存在
	
	
}
  
②auto
不要把该变量改为其他储存类型 
是为了明确表达要使用与外部变量同名的局部变量的意图
局部变量之前加的，加不加都一样，系统默认的   auto int num=0；

③registr
声明寄存器变量 就是很快的那个 
 
④extern，使用了外部变量，意思就是我要从别的文件中调用变量了，加一个extern
  
⑤_Thread_local
程序可以被分为多个线程，在每个线程中，具有线程储存期的对象，从被声明时到线程结束一直存在
而用_Thread_local声明一个对象时，每个线程都获得该变量的私有备份
7.寄存器变量
①变量通常储存在内存中，寄存器变量储存在CPU的寄存器中（储存在最快的可用内存中）
②是块作用域、无链接和自动储存期
③使用registr便可声明寄存器变量
④寄存器变量就是一个请求，人家可能答应，也可能不答应
⑤处理器中的寄存器可能没有足够大的空间来储存double类型的值


8.外部链接的静态变量
——具有文件作用域  外部链接和静态储存期    （有时称为外部储存类别）
——extret，使用了外部变量
——书写格式
int errupt;    //外部定义的变量，外部变量具有文件作用域 **定义式声明
extern char coal;     //如果coal被定义在另一个文件中
double up[100];
 
int main(void);
{
	extern int errupt;  //可以写，也可以不写，如果去掉extern，就相当于创建了一个只能在这个函数里使用的自动变量
						//引用式声明
	extern double up[];   //在main中声明up数组时，不应该声明数组的大小，因为上面已经声明过，也可以省略不写
	
}
——errupt实际的定义在该程序的别处，也许在别的文件中，该声明并不会引起分配储存空间，不要用extern创建外部定义，只用它来引用现有的
  外部定义的变量
  //file_two.c
  extern char permis = 'Y';   //在其他文件中已经初始化了permis，不能再一次初始化，只能引用
 
9.初始化外部变量
——如果未初始化外部变量，他们将会被自动初始化为0
——只能使用常量表达式初始化文件作用域变量
  int x2 = 2 * x;   //x是变量  
  
**********

小贴士
size_t是sizeof的返回值，其返回值是一种整型类型，里面保存的是一个整数（size_t z = sizeof(int)）;
time_t是time()函数的返回值    time_t time(time t *); //time在有的系统里是unsigned类型，在另一个系统可以是unsigned long long类型，包含time.h头文件，可以让系统自动选择合适的类型

********** 
  
10.内部链接的静态变量
——具有静态储存期，文件作用域和内部链接
——意思就是只能在这个文件中使用，不可调用到别的文件中 
  
11.储存类别和函数
——外部函数
一般默认是外部函数，就是哪个文件都能用extern调用

——静态函数
加static，属于特定模块私有

——内联函数  
 
  
12.随机数函数和静态变量
①随机数函数：一个使用内部链接的静态变量
②rand是伪随机数生成器，可预测生成数字的实际序列
  开始于一个种子，该函数使用种子生成新的数，这个新数有成为新的种子
 ③头文件stdlib.c
srand((unsigned) time(NULL));	//unsigned 可以换成unsigned int制类
printf("%d\n",rand());

随机函数
srand();使用时间作为种子，产生不一样的随机数字
rand();
srand(time(NULL));
printf("随机数字：%d\n",rand());

rand()%10 取个位
若是10    0-9             若是19    0-18  除以19的余数
若要取5-15      16：  0-15  ＋   55-20		所以%11+5
例如：roll = rand() % sides + 1;   //则这个roll产生的是某个范围内的随机数

产生随机数的范围			  
  
  
13.calloc()函数     也可以分配内存
返回值是指向void的指针，如果要储存不同的类型，应使用强制类型转换符
newmen = (long *)calloc(100, sizeof (long));   //第一个是所需出储单元的数量，第二个参数是储存单元的大小（以字节为单位）
calloc()函数还有一个特性，他把所有的位都设置为0
free()函数也可用于释放calloc()分配的内存

14.动态分配内存和变长数组
都可以用于创建在运行时确定大小的数组
变长数组是自动存储类型，变长数组占用的内存空间会被自动释放，不必使用free()
——使用变长数组方便，也可以使用malloc()创建二维数组
int ar2[3][4];


把这块内存分配完之后，和指针一模一样，就是可以控制n而已
int (* p2) = (int *) malloc(n * 6 * sizeof(int));  //malloc只能返回第一个字节地址前面的是强制类型转换  
如果说是p2[1] = 10，相当于第二个数是10
//动态分配内存和结构的结合
struct Student
{
	int sid;
	int age;
};
int main(void)
{
	struct Student *ps;
	ps = CreatStudent();
	ShowStudent(ps);
	return 0;
}

void ShowStudent(struct Student *pst)
{
	printf("%d %d\n",pst->sid,pst->age);
}
struct Student *CreatStudent(void)
{
	struct Student *p = (struct Student *)malloc(sizeof(struct Student));
	p->sid = 99;
	p->age = 88;
	return p;
}

   
15.储存类别和动态分配内存
静态储存类别所用内存数量在编译时确定，在程序开始执行时被创建，在程序结束时被销毁，这部分内存常用栈来处理，意味着创建的变量
按顺序加入内存，然后以相反的顺序销毁

动态分配的内存在调用malloc()或相关函数时存在，在调用free()后释放

16.
int main()
{
	int *p = malloc(10);  //这个函数调用完p没啦，但分配的内存还在
}

16.ANSIC类型限定量（const恒常量    volati限定量）
*const
const const const int n = 6; //与const int n = 6;相同
1.const int chchange;   
  nochange = 12; //不允许
  
  const int chchange = 12;//允许

2.使用全局变量
暴露了数据，可能让任何部分随意篡改数据，使用const，避免这样的危险，没有做初始化的全局变量会得到0值，指针会得到NULL
*****
使用头文件的好处就是不用extern
*****  
  
*volatile类型限定符，可以改变变量的值
多次调用一个数字，且这个数字不改变，为了节约时间，临时储存在寄存器中 
  
  
*****************************************************************************************************************************
*如何从函数中传回两个数据（也可以使用数组）
typedef struct{
	int date;
	int length;
}plate; 
  
传回plate  用plate.date     plate.length
*****************************************************************************************************************************
*常量符号化
用符号而不是具体的数字来表示程序中的数字
const int red = 0;

*枚举（很少用）
本来应该是#define MON 1     //如果要写七个的话，就太多了
enum COLOR {RED,YELLOW,GREEN};     //格式  enum 枚举名 {枚举元素1，枚举元素2........};
enum DAY {MON = 1,TUE,WED,THU,FRI,SAT,SUN};  //如果定义了第一个，后面每个依次递增1
enum DAY {MON,TUE = 1,WED,THU,FRI,SAT,SUN};	 //从TUE开始依次递增1，MON = 0

——枚举变量的定义
和结构差不多，唯一不同就是没有加数据类型（它的数据类型只是int）

enum DAY
{
	MON = 1,TUE,WED,THU,FRI,SAT,SUN
};
enum DAY day;

enum DAY
{
	MON = 1,TUE,WED,THU,FRI,SAT,SUN
}day;

enum 
{
	MON = 1,TUE,WED,THU,FRI,SAT,SUN
}day;

int main()
{
	enum DAY day;
	day = WED;
	printf("%d",day);
}
//还可以遍历枚举元素，必须是连续的1，2，3，4，5，6，
case 1;//也可以换成case red; //如果red的值代表的是1的话
  
  
*__func__  这个的意思就是函数的名称
void main(void)
printf("%s",__func__);  //打印出来就是main
 
*****************************************************************************************************************************  
                                               ***数组问题大归类***
*****************************************************************************************************************************
数组 
*数组（啥是数组了，就是存数字的，数字有啥类型了，int double float）（要是往数组里录入元素的话，就得用循环一门一门录了）
1.数组元素的编号从0开始
2.初始化数组int powers[8] = {1,2,3,4,5,6,7,8,9};  
6.sizeof days是整个数组的大小（以字节为单位）。sizeof day[0] 是数组中一个元素的大小。整个数组的大小除以单个元素的大小
  就是数组中元素的个数（这是个啥意思了，意思就是sizeof = 数据类型所占字节数 * 所含元素总数）只要出现sizeof都用这个就行了
  double test[] = {1,2,3,4,5,6,4};
  printf("test数组的元素个数：%d\n",sizeof(test)/size(test[0]));
7.多维数组
   float rain[5][12];  //内含五个数组元素的数组，每个数组元素内含12个float类型的元素
					   //rain是一个内含五个元素的数组，一个内含12个float类型元素的数组 
   5表示行，12表示列——对一行数据求和（外循环控制行，内循环控制列递增）    ——对一列数据求和（外循环控制列，内循环控制行递增）
   
   {
	   {},
	   {},
	   {},
	   {}
   }
8.字符数组（啥是字符数组了，就是放字符的，但是末尾不加\0）
    char names1[]={'A','n','i','t','a'};
    char names2[]="jack";  //和上面那个一摸一样
    char *names3 = "jack";  

   
字符串（啥是个字符串了，就是s1乱七八糟符号啥的，都是字符串,可以是apple，也可以是i love apple）
1.经过实验验证strlen若是1234 ，返回值是5，只要是字符串了，我就用strlen
2.scanf("%s",name);//可以输进去一个单词
3.字符串是东西   数组是放东西的
  char name[40];   name后面跟[]表明这是一个数组，方括号中的40表明该数组中的元素数量，char表明每个元素的类型 

4.字符串的输入和输出
===============
输入函数（我的天哪，这些函数都是用来输入输出字符串的）
①char *name;
 scanf("%s",name);  //没有规定name的地址，意思就是可以把name放到任何地方。但是如果char name[80];就表示name是一个已分配块的地址
②gets()读取整行输入，直至遇见换行符，丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使它成为一个字符串
  char words[8];   gets(words);   puts(words);   //总的来说，这是一个不好的函数，已经被摒弃，不要使用，会出错
③fgets(words,9,stdin); //第二个参数指明了读取字符的最大数量，将会读8个，剩下一个存\0，或者读到遇到的第一个换行符为止，而且会把换行符储存在字符串中
                       //在正常情况下ggets()会返回第一个参数的地址，但是，如果读到文件结尾，将会返回空指针（NULL）
                       //如果超出了最大储存的字符，但是程序是使用循环进行读取的，就会让fgets先读取一部分，在末尾加\0，再读取一部分，最后读取在末尾加\n\0
					   //最好的选择
 fputs(words,stdout); //fgets和fputs一个会储存换行符，一个不会显示换行符，这一对形成了互补
 fgets9();  //储存的时候 i love Anita\n\0
 
 如何处理掉换行符
 while(word[i] != '\n')
    i++;
 words[i] = '\0';    //在已储存的字符串中查找换行符，并将其替换成空字符
 
 丢弃多出来的字符(我废了，我实在是看不懂这个了)  //为什么要丢弃过长输入行中的余下字符，输入行中多出来的字符会被留在缓冲区中，成为下一次读取语句的输入，丢弃
                                                 //输入行余下的字符保证了读取语句与键盘输入同步
 while (getchar() != '\n')
    continue;
	
④gets_s(words,8)    //如果get_s读到换行符，会丢弃它，而不是储存他
					//如果读到最大字符数都没有读到换行符，会执行如下几步，首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换行符
					  或文件末尾，然后返回空指针，接着，调用依赖实现的“处理函数”（或你选择的其他函数），可能会终止或退出程序
					//只要输入行未超过最大字符数，和gets()几乎一摸一样



3.输出函数
①puts函数只显示字符串，而且自动在显示的的字符串末尾加上换行符，把字符串的地址作为参数传递给它即可，在遇到空字符时就停止输出，如果没有遇到空字符
 就会继续打印下头的字符串，直到遇到空字符
②scanf()函数返回一个整数值，该值等于scanf成功读取的项数或EOF，当scanf遇到空格或此数组储存空间已满的情况，将会把剩下的字符换到下一次读取
③fputs()函数，不会在输入的末尾添加换行符
 如果混合使用fgets输入和puts输出，每个待显示的的字符串末尾就会有两个换行符
④，只要遇到字符串，都得加""
================

*strchr函数的用法
char * find = strchr(str,'\n'); ，   //可以查找字符串s中首次出现字符c的位置  返回该位置的指针  没找到  返回0
    if(find)  //如果找到了
        *find = '\0';       //根据找到的指针，修改指向元素为\0  
  
*字符串的读法  char ch3[] = "abc";   应该是把右边常量的地址赋给左边

*
int main()
{
    char password[50] = "\(￣︶￣*\))胖塔塔";
    encrypt(password);
    printf("加密后的字符串为：%s\n",password);
    dencrypt(password);
    printf("解密后的字符串为：%s\n",password);
}


char * encrypt(char password[])
{
    int i = 0;
    int count = strlen(password); //字符串的长度
    for(;i < count;i++)
    {
        password[i] = password[i] + i + KEY;
    }
    return password;//函数返回值，就是执行完函数之后，返回给调用者的值，就是password现在的值已经变了
}



*
int num = 9;(这个不是数组，所以下面得取地址)
	int * ptr_num = &num;
*char allly[50] = "apple";	//当用"apple"圈起来时，就表示一个地址了
  
==========================================================================================================================
宏定义函数
1.比较两个数的大小
  #define MAX(a, b) ((a) > (b) ? (a) : (b))   //如果只有一行，可以用括号表示，如果好多行，加大括号
2.函数的调用会带来额外的开销，它需要开辟一片栈空间，记录返回地址，将形参压栈，从函数返回还要记录堆栈
  降低代码效率，代码量大大增加；且函数的声明必须为一种特定的类型，只能在合适类型的表达式上使用
3.宏与类型无关
  #define MALLOC(n, type) ((type *) malloc ((n) * sizeof(type)))  //type就是类型的意思，就是它的类型啥都行
  使用
  int *ptr;
  ptr = MALLOC(5, int);  //是不是太好用了
4.宏定义函数中换行要加\ 每一行都加
  #define INITIAL(n) {unsigned long i;\
                        for(i = 2;i <= n; i++)\
                            previous[i] = i - 1, next[i] = i + 1;\
                        previous[2] = next[n] = NULL;\
                   }
5.一个函数如果不带参数，在调用时只需要在函数名后面加上一对括号即可以调用了，而一个宏如果不带参数，则只需要使用宏名即可，括号无关紧要
6.#define f (x) ((x) - 1)  //会把x和x - 1看成一个整体，而不是fx，所以在宏定义不能加空格
i = 1
7.a = ((biggest) > (x[i++]) ? (biggest) : (x[i++]));    //biggesst和x比较，比较完后i++值为2，所以错了
8.小写转换成大写
toupper(int c)
{
	if(c >= 'a' && c <= 'z')
		c += 'A' - 'a';
	return c;
}
9.有时候写成宏可能会占用太大的内存就是在一中要比较三个四个，甚至五个数的大小 max(a, max(b, max(c, d)))//第一步将参数换成代数式，最后求值
10.
#define T1 struct foo *      
typedef struct foo *T2;

T1 a, b;    //这个声明被扩展为struct foo * a, b;  a被定义为一个指向结构的指针，而b却被定义为一个结构
T2 a, b;    //aheb都是指向结构的指针


=============================================================================================================================
*在C语言中，单个的&和|和&& ||的区别
|和&都是位数运算值，在C语言中只要不等于0就是真
4 & 6，4的二进制数是10，6的二进制数是110，第一位是0 & 0的结果是0，第二位是0 & 1的结果是0，第三位是1 & 1，结果是1，所以最后的
二进制值是100，值是4，逻辑判断是ture；
如果是4 && 6，4是ture，6也是ture，值是1
但不一定都是这样，有可能&是false 而&&是ture
  
*
//要改变值，必须通过指针
main()
{
	int *p;
	fun(&p);   //当这个函数调用完毕后，s的值就没了，所以p就是指向一个不存在的值
} 
//函数的调用，调用一次分配一次空间，调用完毕，函数里面的啥都没了，s的值也没了 
int fun(int **q)   //int *p；类型，又取了地址，所以是**p类型
{
	int s;
	*q = &s;  //*q就是p
}
  
 *
main()
{
	int *p;
	fun(&p);   
} 
 
int fun(int **q)   
{
	*q = (int *)malloc(4);   //动态分配内存，没有free就一直分配的，可以跨函数分配内存
} 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
===================================================================================================================================================
*链表 （离散存储）
1.定义
  n个节点离散分配
  彼此通过指针相连
  每个节点只有一个前驱节点，每个节点只有一个后续节点
  首节点没有前驱节点，尾节点没有后续节点
  
  专业术语：
			首节点：第一个有效的节点
			尾节点：最后一个有效的节点
			头结点：头结点的数据类型和首节点类型一样
			        第一个有效节点之前的那个节点
			        头节点并不存放有效数据
					头节点的目的是为方便对链表的操作
			头指针：
					指向头节点的指针变量
			尾指针：
					指向尾节点的指针变量
					
*如果希望通过一个函数来对链表进行处理，我们至少需要接收链表的哪些信息：头指针
确定一个链表需要几个参数
只需要一个参数：头指针     因为我们通过头指针可以推算出链表的其他所有信息

2.每一个节点的数据类型如何表示
保存变量和下一个数据的地址
struct Node
{
    int date;  //数据域
    struct Node * pNext;  //指针域，相当于带着一个指针箭头的具有特定指向对象的方块
}NODE, *PNOTE;


2.分类
单链表：
双链表：每一个节点有两个指针域

循环链表：能通过任何一个节点找到其他所有的节点
非循环链表

3.算法
遍历
查找
清空
销毁
求长度
排序
删除节点
r = p->pNext;
p->pNext = p->pNext->pNext
free(r);//如果不释放，内存会越来越少，删除的是p指向结点所占的内存，不是删除p本身的内存



插入节点
想把q插入到p后，p是指向一个东西的指针，q也是指向一个东西的指针
r = p->pNext; p->pNext = q; q->pNext = r;   //如果直接是p->pNext = q;  q->pNext=p->Next;是错误的
第二种方法
q->pNext = p->pNext; p->pNext = q;   //①改变了q的指针域的指向，但没有改变q本身的指向  ②将q指针的指向赋给了p的指针与域

1.
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>


typedef struct Node
{
    int date;  //数据域
    struct Node * pNext;  //指针域
}NODE, *PNODE;   //变量名是PNODE，数据类型是struct Node *

PNODE create_list(void);
void traverse_list(PNODE pHead);

int main()
{
    PNODE pHead = NULL;//等价于struct Node *pHead = NULL;  加p表示指针
    pHead = create_list();//创建一个非循环单链表，并将该链表的头结点的地址赋给pHead
    traverse_list(pHead);
}

PNODE create_list(void)
{
    int len;    //用来存放有效节点的个数
    int i;
    int val;    //用来临时存放用户输入的节点的值

    //分配了一个不存放有效数据的头节点
    PNODE pHead = (PNODE)malloc(sizeof(NODE)); //动态分配内存，并强制类型转换为指针类型
    if(NULL == pHead)
    {
        printf("分配失败，程序终止！\n");
        exit(-1);
    }

    PNODE pTail = pHead;
    pTail->pNext = NULL;  //这个指针指向链表的尾节点


    printf("请输入您需要生成的链表节点的个数：len = ");
    scanf("%d", &len);

    for(i = 0; i < len; i++)
    {
        printf("请输入第%d个节点的值：",i + 1);
        scanf("%d",&val);

        PNODE pNew = (PNODE)malloc(sizeof(NODE));  //来存放输入节点中的数据
        if(NULL == pNew)     //如果用malloc函数，得判断内存是否分配成功
        {
            printf("分配失败，程序终止");
            exit(-1);   //退出程序
        }
        pNew->date = val;  //把val赋给pNew中的date
        pTail->pNext = pNew;   //把pnew的地址赋给末尾的地址
        pNew->pNext = NULL;    //因为末尾的指针是空指针，所以还得把末尾设成空指针
        pTail = pNew;     //把new的地址赋给tail，现在new相当于末尾了
    }
    return pHead;  //这个和这个函数没关系，main函数只是要返回链表头节点的地址
}

void traverse_list(PNODE pHead)  //头节点的地址
{
    PNODE p = pHead->pNext;      //p指向头节点的指针域，注意不是首节点

    while(NULL != p)     //如果指针域不为空，就是不是尾节点
    {
        printf("%d ",p->date);     //输出数据
        p = p->pNext;   //p指向下一个节点的指针域
    }
    printf("\n");
    return;
}



****************************************************************************************************************************************************************************************
*栈
1.堆是程序员手动分配内存的，就是malloc，是动态内存malloc(200)  200就是堆
  栈是静态的或局部变量  int q;   q就是栈
2.分类
  静态栈：数组为基本内核
  动态栈：不连续的，类似于链表，但不是链表
3.栈都是先进后出，把书放在盒子里
  队列只能从一个口进，从一个口出，先进先出
4.对栈就有两个操作，往进放，往出取 
  出栈    压栈
5.    O   <——————ptop
      |
	  O
	  |
	  O
	  |
	  O
	  |
	  O
	  |
	  O   <——————pbottom   （这里是头节点， 先放进来的）
  
  在这里，竖杠的箭头都是向下的，
6.应用
  函数调用：调用一个函数时，当前函数暂停并处于未完成状态。该函数所有变量的值都还存在内存中
            //当前函数是一个砖头，调用函数也是一个砖头，调用函数时，调用函数的砖头压在当前函数的砖头上
			//当这个函数用完后，从当前函数上边弹出
	  调用栈被用来储存多个函数的变量
	       1）递归函数的调用栈
		      例如：fact(3)
			    int fact(int x)
				{
					if x == 1;
						return 1;
					else
						return x * fact(x - 1);
				}
				
				第一次   3 * fact(2)
				第二次   2 * fact(1)
				第三次   return 1； //返回给fact(1)为1
				第四次   return 2 * 1； //返回给fact(2)为2
				第五次   return 3 * 2;   //最终返回6
				
				
				调用一次函数，进行一次压栈，当最顶上的函数return时，这个函数从最上边弹出
7.如果栈很高，就意味着函数储存了大量函数调用的信息
  解决方法
    重新编写代码，转而使用循环
	使用尾递归（这个高级，难）
				
			  
    

********************************************************************************************************************************************************************************************* 
*c预处理库
1.编译器把文本划分为预处理记号序列、空白序列、注释序列（记号是由空格、制表符、或换行符分隔的项）
  int                fox;  //就是int fox;一个空格可以替换所有的空白字符序列（不包括换行符）
2.明示常量#define
  允许#号前面有空格或制表符，而且还允许在#和指令的其余部分之间有空格
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  反斜杠可以把定义延续到下一行,但第二行和第一行之间要对齐，否则中间会有空格，这是一条语句，如果是int又一个int
  #define OW "i\
  love anita"
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  #define(预处理指令) PX(宏) printf("X is %d.\n",x)(替换体)   //宏的名称中不允许有空格，从宏变成最终替换文本的过程宏展开
															  //每条空格都会被一条空格代替
  预处理 x = FOUR;  变成了 x = TWO * TWO;  即是：x = 2 * 2 //宏展开此处为止，不做计算，不对表达式求值，它只进行替换
  编译   在编译过程中求值
  *预处理也可以用char类型代替 const char * fmt = "X is %d.\n" 
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  #define HAL 'A'   //定义了一个字符常量
  #define HAP "Z"   //定义了一个字符串  ，后面有\0
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  
  如果宏用双引号括起来
  printf("TWO:OW");  //打印的是TWO:OW  不指TWO和OW所对应宏中的值
  
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  宏定义的是一个没有数据类型的常量，只能在本文件中使用，并且在编译预处理时会被替换
        宏定义的本质只是一段字符，在编译的时候被替换到引用的位置
  全局变量要在运行时替换，且为它分配了一块内存，可以在工程所有文件中使用，宏定义不支持extern
        全局变量的变量，不是固定的，可以改变
  #define LIMIT 20
  const int LIM = 50;
  static int data1[LIMIT];    //有效
  static int data2[LIM];    //无效
  const int LIM2 = 2 * LIMIT;	//有效
  const int LIM# = 2 * LIM;		//无效
  //非自动数组的大小应该是整型常量表达式，这意味着表示数组大小的必须是整型常量的组合（如：5）、枚举常量、和sizeof表达式，不包括const的声明
  
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  *记号
  可以把宏的替换体看作是记号型字符串，而不是字符型字符串
  #define FOUR 2*2   //该宏定义有一个记号：2*2序列
  #define SIX 2 * 3  //该宏定义有三个记号：2、*、3
  
  字符型字符串和记号型字符串不同
  #define EIGHT 4 * 8  //如果这个是字符型字符串，把空格视为替换体的一部分
					   //如果是记号型字符串，把空格视为替换体中各记号的分隔符
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  *重定义常量
  先把LIMIT定义为20，稍后又在该文件中把它定义为25，这个过程称为冲顶一样常量
  ANSI标准采用第一种方案，只有新定义和旧定义完全相同才允许重定义，具有相同的定义意味着替换体中的记号必须相同，且顺序也相同
  #define SIX 2 * 3
  #define SIX 2 * 3   //这两条定义都有3个相同的记号，额外的空格不算替换体的一部分
  #define SIX 2*3     //这条宏定义中只有一个记号，与上面两条定义不同
  
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  *在define中使用参数
  #define MEAN(x,y) (((x)+(y))/2)    //xy是宏参数，函数中每一个参数，每一次运算都要加括号,还有所有运算符之间都不要加空格
  z = MEAN(2,3)   //调用，使用该宏时，既可以使用x，也可以使用其他符号，宏定义中的x由宏调用中的符号代替，xy起到传递参数的作用
  
  #define SQUARE(X) X*X
  SQUARE(x+2);   //的值时17，预处理器不做计算、不求值，只替换字符序列5+2*5+2 = 5 + 10 + 2 = 17
				 //所以要多加几个圆括号
				 //而且要避免使用++x作为宏参数，不要在宏中使用递增或递减运算符
				 
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  #运算符
  #作为预处理字符串，可以把记号转换成字符串
  
  #define PSQR(x) printf("anita is #x and %d",(((x)*(x)))
  #PSQR(2)   //anita is 2 and 4.
  
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  ##运算符
  ##运算符可用于类函数宏的替换部分，就是把2个东西粘一块了
  #define XNAME(n) x ## n
   int XNAME(1) = 14;   //也就是x1 = 14；
  
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  变参宏：...和__VA_ARGS__
  ...表示可变
  #define PR(...) printf(__VA_ARGS__)
  PR("Howdy");   //printf("Howdy");
  PR("weight = %d, shipping = %d",wt,sp);  //printf("weight = %d, shipping = %d",wt,sp);
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  宏和函数的选择
  宏生成内联代码，即在程序中生成语句，如果调用了20次，即在程序中插入20行代码，宏不用担心变量类型，因为宏处理的时字符串，而不是实际的值，在嵌套循环中使用宏更有利于提高效率
  如果调用函数20次，程序中只有一份函数语句的副本，所以节省了空间，程序的控制必须跳转至函数内，随后再返回主调程序，花费更多的时间
  
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  文件包含 #include
  #include <stdio.h> //文件名在尖括号内
  #include "myself.h"  //文件名在双引号内，先查找本地目录
  
  头文件中包含的内容
  //常量  #include #define
  //结构声明  
  //类型定义  int
  //函数原型
  
  
********************************************************************************************************************************************************************************************* 
线性结构的两种常见应用之二  队列
  定义：一种可以实现先进先出的储存结构
  如何定义常量：front（前头的） rear（后头的）   |    进去叫入队  出去叫出队
  分类：链式队列——用链表实现
  
		静态队列——用数组实现
		          静态队列通常都必须是循环队列
				  
		循环队列的讲解：
		     
			    来，左边跟我画一个圈，把这个圈从0-5标好，最开始f和r都指向0，且0上的值啥都没有，终于来了一个数字了，他要开始存数字了呀
				把它存向r所指向的0，然后r再向后指向1，现在r指的又是啥都没有，如此反复，直到r指向5，此时这个5是空的；如果要出队，就是把
				f向后移一个就可以啦
		
				1.静态队列为什么必须是循环队列
				2.循环队列需要几个参数来确定
				  需要两个参数来确定
						front
						rear
						两个参数不同场合有不同的含义
				  1）队列初始化
					  front和rear的值都是0
				  2）队列非空
					  front代表的是队列的第一个元素
					  rear代表的是队列的最后一个有效元素的下一个元素
				  3）队列空
					  front和rear的值相等，但不一定是0
				3.循环队列各个参数的含义
				3.循环队列入队伪算法讲解
				  两部完成（先存后递增）
				      将值存入r所代表的位置
				      r = (r + 1) % 数组的长度（错误的写法r = r + 1）数组的长度就是数组里有几个元素
				4.循环队列出队伪算法讲解
					  f = (f + 1) % 数组的长度
				5.如何判断循环队列是否为空
				      如果front和rear的值相等
					  该队列就一定为空（我觉得前提是使用队列已满的第二种方法）
				6.如何判断循环队列是否已满
				  预备知识：
						front的值可能比rear大
						也完全有可能比rear小
						当然也有可能相等
				  两种方式：
				        1）多增加一个标识符参数，就是r移动一次，i++，判断i 等于5是否成立
						2）少用一个元素(一般用这个)
						   如果r和f的值紧挨着，则队列已满（(r + 1) % 数组长度 == f）
						   
			队列的具体应用：
						所有和时间有关的操作都有递归的影子
						   
1.						   
			
		
*********************************************************************************************************************************************************************************************	
*今天咱来学学递归，咱现在也没太搞懂
1.
关于递归： 一定不要试图跟踪大型递归的过程！ 要写出递归
关键就是找出递归的递归方程式： 也就是说，要完成最后一步
那么最后一步的前一步要做什么。


关于递归：

1）在求f(n, other variables)的时候，你就默认f(n -1, other variables)已经被求出来了——至于怎么求的，这个是计算机通过回溯求出来的。

PS:这里用到了一种叫做栈(stack)的先进后出的数据结构，所以递归输出的答案一般是自下而上的。

2）递归和二叉树是密切相关的。可以尝试通过二叉树的数据结构来理解递归是如何将一个问题拆分成若干子问题，求解再回溯的。
这里可以参考以下快速排序(QuickSort)的过程（快速排序的核心思想是分治，分治即分而治之，通过递归将原问题分解为若干容易求解的子问题，
再通过递归将这些子问题联系起来并向二叉树的上层回溯，最终求解出原问题）

函数的调用
·当在一个函数的运行期间调用另一个函数时，在运行被调函数之前，系统需要完成三件事
1.将所有的实际参数，返回地址（就是保存被调用函数下头的那个语句的地址printf("1111");）等信息传递给被调函数保存
2.为被调函数的局部变量（也包括形参）分配储存空间
3.将控制转移到被调函数的入口

·从被调函数返回到主调函数之前，系统也要完成三件事
1.保存被调函数的返回结果
2.释放被调函数所占的储存空间
3.依照被调函数保存的返回地址将控制转移到调用函数

·当有多个函数相互调用时，按照后调用先返回的原则，上述函数之间的信息传递和控制转移必须借助栈来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当
调用一个函数时，就在栈顶分配一个储存区，进行压栈操作，每当一个函数退出时，就释放它的储存区，进行出栈操作，当前运行的函数永远都在栈顶位置

`递归满足三个条件
	1.递归必须得有一个明确的终止条件
	2.该函数所处理的数据规模必须在递减，不是参数递减，是规模递减
	3.这个转化必须是可解的   
·递归的应用
	树和森林就是以递归的方式定义的
	数和图的很多算法都是以递归来实现的
	很多数列公式就是以递归的方式定义的
		斐波那契数列

void f();
void g();
void k();

void f()
{
	printf("FFFF\n");   
	g();
	printf("1111\n");
}
  
void g()
{
	printf("GGGG\n");
	k();
	printf("2222\n");
}  
void k()
{
	printf("KKKK\n");
}
  
  
int main(void)
{
	f();  //再main函数里先调用f()，f()先输出FFFF,再调用g()，g先输出GGGG，然后调用k，同时记录下1111的地址，k先输出KKKK，同时记录下2222的地址，将控制转移到
		  //g函数，输出2222，刚才记录下1111地址，把控制返回f函数，输出1111；
} 
  
输出结果是
FFFF
GGGG
KKKK  
2222
1111

递归之求阶乘

long f(long n)
{
	if(1 == n)    //判断相等的时候必须这样写，数字写左边，就像之前NULL
		return 1；
	else
		return f(n - 1) * n;
	
} 
  
int main(void)
{
	printf("%d\n", f(6));
	
	return 0;
}
  

递归（recursion）：递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在函数定义中使用函数自身的方法。（A调用A）
迭代（iteration）：重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B）

递归是一个树结构，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。
迭代是一个环结构，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。

  
  
  
*分治算法
1.将问题分解为规模更小的子问题
2.将这些规模更小的子问题逐个击破
3.将已解决的子问题合并，最终得出母问题的解
  ·减而治之（每次让问题的规模减一）
  ·分而治之（每次让问题的规模减半）（归并排序的思想）
  
        走楼梯
		题目描述：一个台阶总共有n级，如果一次可以跳一级，也可以跳两级，求总共有多少种跳法（如果是3级，可以分为2级和1级，两级有2种，1级有1种）
		
		int solve(int n)
		{
			if (n == 1)
				return 1;
			if (n == 2)
				return 2;
			return solve(n - 1) + solve(n - 2);  //总共分为两种情况，第一种情况是第一次跳一级，第二种情况是第一次跳两级，总共的情况是这两种情况的和
		}
		
		int main()
		{
			int T;
			scanf("%d", &T);
			while(T--)
			{
				int n;
				scanf("%d", &n);
				int ans = solve(n);
				printf("%d\n", ans);
			}
			return 0;
		}
//输出一组数中的最大值,分堆法，把第一个数字看成一个，把最后的一堆数字看成一个，把第一个数字和最后一堆数字比较，第一个数字比完啦，开始第二个和第二个后面一堆的数字比较
//同时，如果需要用到堆的概念的话，就是要调用函数了
//总的想法就是用第一个数和第一个数之后的一堆数进行比较
int findMax(int arr[], int L, int R) //L数组最左边的元素，R数组最右边的元素
{
	if(L == R)
		return arr[L];
	else
	{
		int a = arr[L];
		int b = findMax(arr, L + 1,R);
		if(a > b)
		{
			return a;
		}
		else
			return b;
	}
}  

//需要遍历数组中每个元素的设置left和right
int main()
{
	int arr[10] = {8,2,3,4,6,5,1,10,9,7};
	int m = findMax(arr, 10);
	printf("m = %d\n", m);
	
	return 0;
}  
  
  
 //求和
int sum(int arr[], int L, int R)
{
	if(L == R)      //如果只有一个数，直接返回
	{
		return arr[L];
	}
	else       //第一个数加上后面的一堆数
	{
		return arr[L] + sum(arr, L + 1, R);
	}
} 
 
int main()
{
	int arr[5] = {1,2,3,4,5};
	int s = sum(arr, 0, 4);
	printf("s = %d\n", s);
	
	return 0;
} 
  
  
  
//冒泡排序
2 7 3 1 6 5
两对两对比，一轮比完之后，最大值在最后
这个函数完成的是冒泡排序，啥是冒泡排序，就是比较完一轮后最大值在后面，所以这个函数就得实现这个目标，还得设置退出循环的条件
void bubble(int arr[], int L, int R)
{
	if(L < R)  //调用这个函数的时候，意思就是选出最左边一个数，和它右边的一堆数，和它之后的每个数比较，进行交换
	{
		int i;
		for(i = L; i <= R - 1; i++)   
		{
			if(arr[i] > arr[i + 1])
			{
				int temp = arr[i];
				arr[i] = arr[i + 1];
				arr[i + 1] = temp;
			}
		}
		bubble(arr, L, R - 1);  //如果说一轮比完之后，最大的数字在最后，那么就不管这个数字了，让右节点往左移一个，再开始比较，这个所实现的就是外层循环
	}
}
 
int main()
{
	int i;
	int arr[7] = {6, 1, 2, 9, 7, 3, 4};
	bubble(arr, 0, 6);
	for(i = 0; i < 7; i++)
	{
		printf("%d\n", arr[i]);
	}
}
  
  
//最大公约数

72 \ 56 = 1 .......16
56 \ 16 = 3 .......8
16 \ 8 = 2 .......0

a是除数   b是被除数

int gcd(int a, int b)
{
	int r = a % b;  //余数
	if(r == 0)
	{
		return b;
	}
	else
	{
		return gcd(b, r);
	}
}
 
 int main()
 {
	 int a, b;
	 scanf("%d", &a);
	 scanf("%d", &b);
	 int g = gcd(a, b);
	 
	 printf("%d\n", g);
	 return 0;
 } 
  
  
  
  
  
  
1.如果使用循环，程序的性能可能更高，如果使用递归，程序可能更容易理解
2.每个递归函数有两部分：基线条件和递归条件。递归条件指的是函数自己调用自己。基线条件指的是函数不再调用自己，从而避免形成无限循环

  
===================================================================================================================================================================
1.在C语言中，符号之间的空白（空格符，制表符，换行符）可以被忽略，但是符号是一个整体的，两个符号之间不可以有空白 <= 
2.如果一个函数执行成功，将返回0或正数，如果函数执行失败，将返回-1
3.比较运算符 == 两个相等，返回1，不相等返回0
4.编译器将程序分解成符号的方法是，从左到右一个字符一个字符的读入，如果该字符可能组成一个符号，那么再读入下一个字符，判断已经读入的两个字符组成的字符串是否是
  一个符号的组成部分，如果可能，继续读入下一个字符，重复上述判断
5.y = x /* p     /*被认为是一段注释*/          y = x / *p   (*被认为是一个指针)
6.如果整型常量的第一个字符是数字0，那么该常量被视作八进制数（ANSIC标准也禁止这种做法）
7.用单引号引起的一个字符实际上代表一个整数，'a'的含义与0141（八进制）或者97（十进制）严格一致
8.用双引号引起来的字符串，代表的是一个指向无名数组其实字符的指针，该数组被双引号之间的字符以及一个额外的二进制为0的字符"\0"
  单引号数字，，双引号指针//"yes"含义是依次包含'y'、'e'、's'以及'\0'的4个连续内存单位的首地址
						  //'yes'含义是一个整数值，由'y'、'e'、's'所代表的整数值按照特定编译器实现定义的方式组合得到
9.类型转换符（把声明中的变量名和声明末尾的分号去掉）再将剩余的部分用一个括号整个封装起来即可
  float (*h)();   float(*)()  //指向返回值为浮点类型函数的指针
10.分析表达式(*(void)(*)()0)() 
   void(*fp)() //fp是一个指向返回值为void类型的函数的指针
   (void(*fp)())0  //将常数0转型为“指向返回值为void的函数的指针”
   (*(void)(*)()0)()  //当计算机启动时，硬件将调用首地址为0位置的子例程
   
11.所有赋值运算符的优先级是一样的，而且他们的结合方式是从右到左
   a = b = 0;  //相当于b = 0  a = b    
12.函数getc()用于从流中读取字符
   FILE *fstream;
   char mag[100] = "hello! i have read this film";
   fstresm = fopen("test.txt", "at+");    
   int getc(FILE *stream);
   if(fstream == NULL)
   {
	   printf("read file test.txt fails!\n");
	   exit(-1);
   }
   //从文件流中读取字符
   while((ch = getc(fstream)) != EOF)
   {
	   putchar(ch);
   }
   //循环写入
   len = strlen(msg);
   while(len > 0)
   {
	   putc(msg[i], fstream);
	   len--;
	   i++;
   }
   fclose(fstream);
13.在C语言中如果多写了一个分号有可能不会产生影响，也有可能会报错
14 if (n < 3)
		return
	a = 1;  //将这个当成了return的操作语句
	b = 2;
	
	//如果这段代码所在的函数声明其返回值为void，编译器会因为实际返回值的类型与声明返回值的类型不一致而报错
	//如果省略了返回值类型，会视为int，上面的错误不会被检测到
   
15.
struct logrec{
	int date;
}
 
main()
{
	
} 
  
//上面这段代码实际的效果是声明函数main的返回值是结构logrec类型


16.switch语句
C语言中把case标号当作真正意义上的标号，因此控制程序会径直通过case标号
pascal语言中每个case标号都隐含地结束了前一个case部分
C语言中不加break的好处
//以下程序的目的是跳过所有的空白字符
case '\n':  //如果是\n执行这个
	linecount++;   //意思是如果碰到换行符，行数增加
case '\t':  //如果是\t执行这个
case ' ':  //如果是 执行这个，所以就全跳过了
	
17.数组的大小必须在编译期就作为一个常数确定下来
   对于一个数组，只能做两件事：确定该数组的大小，以及获得指向该数组下标为0的元素的指针   任何一个数组下标运算都等同于一个对应的指针运算
18.在C语言中索引运算是以指针算数的形式来定义的//索引相当于图书的目录，可以根据目录的页码快速找到所需要的内容
19.int calendar[12][31];    //sizeof(calendar)的值是（31 * 12） * sizeof(int)
   如果两个指针指向的是同一个数组中的元素，我们可以把这两个指针相减    //int *q = p + i;可以通过q - p而得到i的值，如果p和q指向的不是同一个数组中的元素，结果可能不正确
p = &a  //是错误的&a是一个指向数组的指针，p是一个指向整型变量的指针，就是如果想让指针指向一个变量，指针的类型和这个指针变量的类型必须相同
int calendar[12][31];
int *p;
int (*monthp)[31];

p = calendar;       //这个是错的，calendar是一个二维数组，数组的数组，有一个东西*的含义和[]相同
monthp = calendar;  //这样写就对了，一定要注意类型的统一
   
20. 
int strlen(char s[])  和   int strlen(char *s)  完全相同
//如果一个指针参数并不实际代表一个数组，即使从技术上而言是正确的，采用数组形式的记法经常会起到误解作用，得看重点是强调数组还是指针
21.空指针并非空字符串
#define NULL 0;  //编译器保证由0转换而来的指针不等于任何有效的指针，无论直接使用常数0还是NULL，效果都是相同的
null指针并不指向任何对象，因此，除非是用于赋值或比较运算，处于其他任何目的使用null指针都是非法的，如果p或q是一个null指针，那么strcmp(p, q)的值就是未定义的


22.边界计算与不对称边界
在标准的basic语言中，声明一个拥有10个元素的数组，实际上编译器分配了11个元素的空间，下标范围从0~10
int i, a[10];
for(i = 1; i <= 10; i++)
	a[i] = 0;//如果用来编译这段程序的编译器按照内存地址递减的方式来给变量分配内存，本来是a[10] = 0变成了i = 0,陷入了一个死循环

	首先考虑最简单情况下的特例，然后将得到的结果外推
	仔细计算边界，绝不能掉以轻心
	x >= 16 且 x <= 37  这里面有多少个元素，假定数组x的范围上界与下届重合，即x>=16且x<=16,合理的取值只有一个
	考虑一般的情况37 - 16 + 1就是22
	****用第一个入界点和第一个出界点来表示一个取值范围x>=16且x<38，这里下界是入界点，即包括在取值范围之中，而上届是出界点，即不包括在取值范围之中
	取值范围之差就是上界与下界之差。38 - 16的值是22
	
	另一种考虑不对称边界的方式，把上界视作某序列中第一个被占用的元素，把下界视为序列中第一个被释放的元素
	//将数据输送到缓冲区（即一块能够容纳N个字符的内存）中去，每当这块内存区被填满时，就将缓冲区的内容写出
	
	/*    *bufptr++ = c;   //把输入字符c放到缓冲区中，然后指针bufptr递增1，又指向缓冲区中第一个未占用的字符（指向第一个未占用的字符复合不对称边界
	      bufptr = &buffer[0];   //当指针bufptr与&buffer[0]相等时，缓冲区存放的内容为空   也可以写成bufptr = buffer;
		                         //任何时候缓冲区中存放的字符数都是bufptr - buffer 当缓冲区全部填满时，表达式的值为N  缓冲区中未占用的字符数为N - (bufptr - buffer)
	
	*/
	static char buffer[N];
	static char *bufptr;
	
	void memcpy(char *dest, const char *sourse, int k)
	{
		while(--k >= 0)
		*dest++ = *source;
	}
	
	
	void bufwrite(char *p, int n)  //p是输入字符串的指针，n用户想读入字符的个数，可以是任意的
	{
		while(n > 0)
		{
			int k, rem;
			//N是缓冲区中的最大字符数
			if(bufptr == &buffer[N])   //实际上&buffer[N]这个元素是不存在的，这种写法等效代替了if (bufptr > &buffer[N - 1])
									   //数组中实际不存在的溢界元素的地址位于数组所占内存之后，这个内存可以用于进行赋值和比较，如果要引用该元素，那就是非法的了
				flushbuffer();   //调用函数flushbuffer来把缓冲区中的内容写出，而且函数会重置指针bufptr，使其指向缓冲区的起始位置
			rem = N - (bufper - buffer);   //缓冲区中还剩余的字符数  另一种计算rem的方法(buffer + N) - bufptr
			k = n > rem ? rem : n;    //判断用户的需求n和剩余的空间rem
			bufptr += k;
			p += k;
			n -= k;
		}
	}
	

23.
求值顺序  a ? b : c,操作数a首先被求值，根据a的值再求操作数b或c的值
g((x, y))  //先对x求值，然后x的值被丢弃，接着求y的值

24.
10(1010)&12(1100)  结果是8(1000)
10(1010)|12(1100)  结果是14(1110)

&& || !  //当结果为假时返回 0， 为真时返回1 （！10的结果是0    10&&12的结果是1）


24.整数溢出
有符号和无符号的区别是一个有符号位，另一个没有符号位，无符号运算中，忽略溢出部分
有符号：int a;  short int b;  long int c;  float d; double e;  //abcde是有符号数
无符号:unsigned char f[10];     unsigned int g;  //无符号

为了防止溢出，使用unsigned，只有在需要符号的时候再用int
if((unsigned)a + (unsigned)b > INT_MAX)
			complain();


25.函数main和其他函数一样，如果并未声明返回类型，那么函数返回类型就默认为整型
   一个返回值为整型的函数如果返回失败，实际上是隐含地返回了某个垃圾整数
   大多数操作系统都通过main函数的返回值来告诉操作系统该函数执行是成功还是失败，返回值为0代表程序执行成功，返回值为非0代表程序执行失败

26.声明与定义
int a;  //a是一个外部整型变量，同时为a分配了储存空间 ，定义和引用类型必须完全相同29.
extern int a;  //显式的说明了a的储存空间是在程序其它地方分配的，上述声明是对外部变量a的引用，而不是对a的定义
每个外部变量只能够定义一次


27.名称冲突
如果在两个不同的源文件中都包括了int a;  它表示程序错误，或者在两个源文件中共享a的同一个实例
如果函数库中有一个叫strcat的，你也写了一个叫strcat的，系统就不知道调用啥了
如果若干个函数需要共享一组外部对象，可以将这些函数放到一个源文件中，把他们需要用到的对象也都在同一个源文件中以static修饰符声明
如果只有函数f需要调用函数g，我们可以把函数f与函数g都放到同一个源文件中，并声明函数g为static
static int g(int x)
{
	
}
void f()
{
	b = g(a);
}

28.
一个函数如果形参列表为空，在被调用时实参列表也为空
要使程序能够运行，函数square必须要么在main之前进行定义
要不写成double square(double );
如果一个函数在被定义或声明之前被调用，那么它的返回类型就默认为整型
返回值为int无所谓，返回值为其他有所谓

ANSIC标准发布之前出现的C编译器，支持这样的写法
int isvowel(c)
		char c;
{
	........;
}

double sqrt();  //最好是加头文件#include <math.h>
main()
{
	double s;
	s = sqrt(2.0);  //sqrt接收一个双精度值为实参，返回值为双精度类型,即使写成2，也会被转换成双精度浮点型
	printf("%g\n", s);
}


29.标识符名称的限定
ANSIC标准所能保证的只是，c实现必须能够区别出前6个字符不同的外部名称
而且，这个定义中并没有区分大写字母和其对应的小写字母
在C语言中是区分大小写的


30.整数的大小
大多数机器的字符长度是8位，一个字节
ANSIC long至少是32位  short int至少是16位


31.除法运算时发生的运算
a除以b，商为q，余数为r
满足的条件
① q * b + r == a;
② 如果改变a的正负号，我们希望会改变q的符号，但这不会改变q的绝对值
③当b > 0时，我们希望保证r >= 0且r < b
上面三条条件不能同时满足  放弃了第三条，改为余数和被除数的正负号相同

C语言只保证了1

32.大小写转换(小写字母的ASCII码比大写字母的ASCII码大32)
#define toupper(c) ((c) + 'A' + 'a')
#define tolower(c) ((c) + 'a' + 'A')
int c;
while((c = getchar()) != EOF)  //EOF的意思是end of film的意思
{
	putchar(isupper(c) ? tolower (c) : c);  //必须先得判断它到底是不是大写，是大写才转换，小写就不转换了
}


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
====================================================================================================================================================
*哈希表
1.就是把储存地址和关键字找出一种对应关系，且这个对应关系尽量是一一对应的
2.根据设定的哈希函数以及处理冲突的方法将查找表中的各数据元素储存在一段有序的空间中，即得哈希表
3.哈希表长应该比关键字集中的关键字要多
——————————————————————————————————————————
设计哈希表地址的方法
1.直接定值法，年龄 1 2 3 4 5 6 7 8 9 .....100 在哈希表中的储存地址 0 1 2 3 4 5 6 7 8  ......99
2.数字分析法
  若关键字是r进制数，且可预知全部可能出现的关键字值，则可取关键字中的若干位构成哈希地址
  如果一个数是81346532 key % 100000(6532) / 1000 (6)   最后的值是6
3.平方取中法
  若关键字较短，则可先对关键字值求平方，然后取运算结果的中间几位为哈希地址
4.折叠法
  1）移位叠加
	 0442205864     04      4220    5864（由低位到高位，每四位一折）   
	 
	 5864
	 4220
   +   04
   ————————
    10088  （最后舍去进位，就是1，得到88就是哈希地址）
  
  2）间接叠加
     0442205864     04      0224    5864（由低位到高位，每四位一折，各段沿分割线来回折叠）
	 
	 
	 5864
	 0224
   +   04
   ————————
     6092  （最后舍去进位，就是6，得到92就是哈希地址）

5.除留余数法
  设有一组关键字如下:(19，14，23，01，68，20，84，27，55，11，10，79)， 试用除留余数法设计哈希函数   因为总共有12个数
  可取p为13    key % 13
  p必须是质数   给定一组关键字为：12，39，18，24，33，21  若取p = 9，则对应的哈希函数值将为：3，3，0，6，6，3，增加了冲突的可能
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
*处理冲突的基本方法
如果按给定的哈希函数求得的哈希地址已被占用，则按一定规则求下一哈希地址，如此重复，直至找到一个可用的地址以保存该元素
1.开放地址法
   （H（Key）+ di）% m      其中H（key）为哈希函数， m为哈希表长，di为增量序列
   di = 1，2，3，4，5  则称为线性探测再散列
   di = 1²，-1²，2²，-2²  称为二次探测再散列
   di = 伪随机数序列，则称为伪随机探测再散列
2.链地址法
   将所有按给定的哈希函数求得的哈希地址相同的关键字储存在同一线性链表中，且使链表按关键字有序
   就是在一个位置插入列表，来处理冲突
3.公共溢出区法
   若关键字所对应的哈希地址已被占用，则保存到公共溢出区（就是单独分出哈希表的一块区域，把溢出的元素按先后顺序依次保存到这块区域中）


#include <stdio.h>
#include <stdlib.h>
#define LEN 13
#define N 11

int date[N] = {10, 9, 8, 7, 5, 4, 6, 3, 2, 1, 95};
int hash[LEN] = {0};

void Creat()
{
    for(int i = 0; i < N; i++)   //循环将原始数据保存到哈希表中
    {
        int j = date[i] % LEN;  //意思就是这个hash函数里最多放13个数字，取模的范围是0-12
        while(hash[j])    //元素位置已经被占用
        {
            j = (++j) % LEN;   //线性探测法解决冲突
        }
        hash[j] = date[i];
    }

}


int Haxi_Soul(int key)   //这个函数的作用是用户输入一个数，要根据这个函数查找到这个数在哈希表中的位置
{
    int i = key % LEN;   //计算哈希地址
    while(hash[i] && hash[i] != key)  //这个位置上有东西，而且有的这个东西不是key
        i = (++i) % LEN;
    if(hash[i] == 0)   //查找到开放单元，表示查找失败，如果这个这个数组里这个位置啥都没有，就是0
        return -1;  //返回失败值
    else
        return i;
}
    
  
int main(void)
{
    int key;
    int i;
    Creat();   //调用函数创建哈希表
    printf("哈希表中各元素的值：");
    for(i = 0; i < LEN; i++);
        printf("%d", hash[i]);
    printf("\n");
    printf("请输入要查找的关键字：");
    scanf("%d",&key);
    int pos = Haxi_Soul(key);    //调用函数在哈希表中查找
    if(pos > 0)
        printf("查找成功，该关键字在数组中的下标为：%d!!!!!!",pos);
    else
        printf("查找失败！！！！");
    printf("\n");
    return 0;
    
}  



====================================================================================================================================
二分查找
二分查找是一种算法，其输入是一个有序的元素列表。如果要查找的元素包含在列表中，二分查找将返回其位置，否则返回NULL
1.使用二分查找查找一个名字，请问最多需要几步才能找到
  在1 2 3  4 5 6 7 8         需要的次数3次或4次，4次是最后一个元素
  ①找1
  1     4
  1     2
  1     1  找到
  ②找8
  4     8
  6     8
  7     8
  8     8  找到
  从上边我们同样可以看到为什么求出mid之后，进行下一步之前，要对mid进行减一或加一，如果不加1，那么找8的时候，就一直会
  停留在7   8 就找不到8了




====================================================================================================================================
*大O表示法（描述出了运行时间随时间z'z'z'z'z的变化情况，指出了算法运行时间的增速）
1.一般而言，对于包含n个元素的列表，用二分查找最多需要log2n（O(logn）步，而简单查找最多需要n（O(n)）步
2.最多需要猜测的次数与列表长度相同，这被称为线性时间
3.大O表示法指出了最糟糕情况下的运行时间
4.常见的大O运行时间
 O(logn)     也叫对数时间，这样的算法包括二分查找
 O(n)		 也叫线性时间，这样的算法包括简单查找
 O(n * logn) 快速排序（速度取决于选择的基准值,最糟糕的情况，运行时间为O(n²)）
 O(n²)		 选择排序
 O(n！)      旅行商问题
					/*一个人要去5个地方，咋地去，第一次可以选择5个地方，第二次可选择4个地方*/
5.算法的速度指的并非时间，而是操作数的增速，不以秒为单位
6.c * n
  c是算法所需的固定时间量，被称为常量，如果两种算法根本不一样，一个是n，另一个是n!，常量无关紧要，如果两个都是n，常量就有关系了
  例如，快速查找的常量比合并查找小，快速查找更快
 
 
====================================================================================================================================
*内存的工作原理
1.内存就是柜子里的抽屉，每个抽屉都有地址
2.需要储存多项数据时，有两种基本方式——数组和链表
  1）数组是连续的抽屉  
     向数组中添加新元素很麻烦。如果没有了空间，就得移到内存其他地方，一种解决方法是预留座位，即使当前只有3个待办事项
	 也请计算机提供10个位置，以便需要添加代办事项，这也就是为什么数组必须在定义的时候规定数组的大小，要不就是int a[] = {1,2,3,4,5}
	 这关乎计算机在内存中找到合适的位置
	 在同一个数组中，所有元素的类型都必须相同
  2）链表是先找到一个抽屉，这个抽屉里放着数据和下一个抽屉的地址，从而使一系列随机的内存地址串在一起
     在链表中添加元素很容易：只要将其放入内存，并将其地址储存到前一个元素中
	 需要同时读取所有元素时，链表的效率很高，如果需要跳跃，链表的效率很低
	 ******
	 专业术语：元素的位置称为索引
	 ******
3.数组和链表操作的运行时间
           数组        链表
	读取   O(1)        O(n)
	插入   O(n)        O(1)

4.数组用的多，访问元素的方式：随机访问和顺序访问


====================================================================================================================================
***排序方法***
1.选择排序法O(n²)   /*
			          为啥不是n! 
					  大O计数法省略常数
					  n! ≈ 1 / 2 * n
					  所以运行时间为O(n * 1 / 2 * n)  但是大O计数法省略常数，因此简单的写做O(n * n) 或 O(n²)
					*/  
首先，选出最小的数，放在第一个位置，然后，选出第二小的数，放在第二个位置
就是先把最小值设成第一个元素，寻找后面最小的元素，找到了，交换，再把最小值设成第二个元素，寻找后面最小的元素，找到了，交换


2.快速排序
  使用分而治之，对于排序算法来说，最简单的数组是什么样呢，就是根本不需要排序的数组
  如果有两个元素，检查第一个元素是否比第二个元素小，如果不比第二个小，就交换他们的位置
  ①选择基准值
  ②将数组分成两个子数组：小于基准值的元素和大于基准值的元素
  ③对这两个子数组进行快速排序
  O(n * logn)  的意思是每层都要比较n个元素，还要选基准值logn
  
3.归并排序  运行时间O(nlogn)  



======================================================================================================================================================
***分而治之（D&C）***
1.步骤:
  1）找出基线条件，这种条件必须尽可能简单
  2）不断将问题分解（或者说缩小规模），直到符合基线条件
  
2.例如：你有一块1680 * 640的土地，将这块地均匀的分成方块，且分出的方块尽可能要大
  找出基线条件：最容易的情况，一条边的长度是另一条边的整数倍
  找出递归条件：每次调用缩小问题的规模：
										首先找出这块地可容纳的最大方块（这个方块可能有多个），会余下一部分地
										再找出余下一部分地的最大方块，还会余下一部分地
										直到满足基线条件
  例如：给定一个数字数组  2  4  6  ，你需要将这些数字相加，并返回结果，如何使用递归函数来完成这种任务呢
        找出基线条件：最简单的数组，一个数组不包含任何元素或只包含一个元素
		找出递归条件：每次调用必须离空数组更近一步sum(2, 4, 6)
												  2 + sum(4, 6)
												  4 + sum(6)
													int sum(int *p, int n)
													{
														int num = 0;
														if(n == 1)
															return *(p);
														else
														{
															return num = p[0] + sum(p + 1, n - 1);
														}
													}

													int main(void)
													{
														int p[5] = {1,2,3,4,5};
														int sum1;
														sum1 = sum(p,5);
														printf("和%d", sum1);
													}
        
	    //编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素								


======================================================================================================================================================
***散列表***
1.散列函数是这样的函数，即无论你给他什么数据，它都还给你一个数字。将输入映射到数字
2.散列函数知道数组有多大，只返回有效的索引
3.数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的储存位置
4.散列表由键和值组成，例如，键为商品名字，值为商品价格。散列表将键映射到值
5.散列表应用
  1）将散列表用于查找（模拟映射关系）
     名字对应电话号码
	 网站的IP地址（这个过程被称为DNS解析）
  2）防止重复
     将输入的名字与散列表的数字比较，如果是0，没投过，并且将它改为1，如果是1，投过
  3）将散列表用于缓存（缓存/记住数据，以免服务器再通过处理来生成它们）
     缓存的工作原理：网站将数据记住，而不再重新计算
	 如果你登录facebook，你看到的所有内容都是为你定制的。你每次访问facebook，其服务器都需考虑你感兴趣的是什么内容。但如果你没有登录，看到的将是登录
	 页面，每个人看到的登录页面都相同
	 缓存的数据储存在散列表中，当你访问facebook的页面时，它首先检查散列表中是否储存了该页面
	 如果不在缓存中，让服务器做些处理，并将处理生成的数据存储到缓存中，再返回他，当下次再请求时，你可以直接发送缓存中的数据，而不用再让服务器处理了
6.冲突
  给两个键分配的位置相同
  1）散列函数很重要。前面的散列函数将所有的键都映射到一个位置，最理想的情况是，散列函数将键均匀地映射到散列表的不同位置
  2）如果散列表储存的链表很长，散列表的速度将急剧下降。然而，如果使用散列函数很好，这些链表就不会很长
  
  避免冲突
  *较低的填装因子（公式：散列表包含的元素数（已经装进去几个东西了） / 位置总数）
   填装因子度量的是散列表中有多少位置是空的
   填装因子大于1意味着商品数量超过了数组的位置数，一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度
   填装因子越低，发生冲突的可能性就越小，散列表的性能就越高。一旦填装因子大于0.7，就调整散列表的长度
  
  *良好的散列函数
  
7.时间O(1)

======================================================================================================================================================
加权图使用狄克斯特拉算法————边上标出时间等的（标出关联数字的）
非加权图使用广度优先搜索————边上啥都没有
——————————————————————————————————————————
***广度优先搜索***（就是从树的头开始，一层一层的找）
1.广度优先搜索让你找出两样东西之间的最短距离（段数最少，但不一定是最快路径）
2.应用
  编写国际跳棋AI，计算最少走多少步就可以获胜
  编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词
  根据你的人际关系网络找到关系最近的医生
3.解决最短路径问题的算法被称为广度优先搜索
4.步骤
  1）使用图来建立模型
  2）使用广度优先搜索解决问题
5.解决两类问题
  第一类问题：从节点A出发，有前往节点B的路径
  第二类问题：从节点A出发，前往节点B的哪条路径最短
              在你的人际关系中逐层查找，找到层数最少的人，也就是跟你关系最近的
6.实现图
如何表示你->这样的关系   散列表   散列表让你能够将键映射到值，在这里，你要将节点映射到其所有邻居
散列表是无序的，因此添加键——值对的顺序无关紧要
7.有向图和无向图
有向图——单箭头——关系单向
无向图——无箭头——关系双向
8.检查完一个人后，应将其标记为已检查，且不再检查它，如果不这样做，就可能会导致无限循环，可以用一个列表来记录检查过的人
9.时间O(V + E) V是节点  O是边
10.你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列

图
·在前面讲解的线性表中，每个元素之间只有一个直接前驱和一个直接后驱，树形结构中，数据元素之间是层次关系，并且每一层上的数据元素
 可能和下一层多个元素相关，但只能和上一层一个元素相关
1.图的定义
  -在线性表中我们把数据元素叫元素，树中叫节点，在图中数据元素我们称之为顶点
  -线性表可以没有数据元素，称为空表，树中可以没有节点，叫做空树，图结构强调顶点集合V要有穷非空
  -线性表中，相邻的元素之间具有线性关系，树结构中，相邻两层之间具有层次关系，图结构中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的
  /*
		图的各种奇葩定义：
		1.无向边：(Vi,Vj)  表示
		2.V1 = {A,B,C,D} 
		  E1 = {(A,B),(B,C),(C,D),(D,A),(A,C)}
		3.有向边：<Vi,Vj>
		  V1 = {A,B,C,D} 
		  E1 = {<A,B>,<B,C>,<C,D>,<D,A>,<A,C>}
		4.简单图：在图结构中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图
		5.无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为完全无向图。
		              含有n个顶点的无向完全图有n * (n - 1) / 2条边
		6.有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，有n * (n - 1)
		7.稀疏图和稠密图：这里的稀疏和稠密都是相对的概念，都是相对而言的，通常认为边或弧数小于n * logn(n是顶点的个数）
		                  的图称为稀疏图，反之称为稠密图
		8.权：与图的边或弧相关的数叫做权，带权的图通常称为网
		9.一个图中一条边上的两个顶点V1，V2，这两个点互为邻接点，即V1和V2相邻接。边(V1,V2)依附于顶点V1和V2，或者说边
		    (V1,V2)与顶点V1和V2相关联
	   10.顶点(V)点相关联边的数目，记为TD(V)
	   11.有向图：度 = 入度 + 出度（以顶点V为头称为入度）（从顶点出去的称为出度）
	   12.路径的长度是路径上的边或弧的数目
	   13.简单环,
	         A
		     |\      不是简单环
		   B | D
		    \|/
			 C
			 
			 A
		    / \      简单环
		   B   D
		    \ /
			 C
	   14.连通图：每个顶点都能联系在一起
	   15.图中的极大联通子图称为连通分量
	   
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
11.小明找小华，广度优先搜索
struct note
{
    int x;   //横坐标
    int y;   //纵坐标
    int f;   //父亲在队列中的编号，本题不要求输出路径，可以不需要f
    int s;   //步数
};

int main(void)
{
    struct note que[2501];   //因为地图的大小不超过50 * 50，因此队列的扩展不会超过2500个
    int a[51][51] = {0}, book[51][51] = {0};
    
    int next[4][2] = {
                      {0, 1},   //往右走 
                      {1, 0},   //往下走
                      {0, -1},  //往左走
                      {-1, 0}   //往上走
                     };
    int head, tail;
    int i, j, k, n, m, startx, starty, p, q, tx, ty, flag;
    
    //n为行  m为列
    scanf("%d %d", &n, &m);
    //初始化这个地图
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    }
    //输入起点和终点坐标
    scanf("%d %d %d %d", &startx, &starty, &p, &q);
    
    //队列的初始化
    head = 1; 
    tail = 1;
    //往队列插入迷宫入口坐标
    que[tail].x = startx;
    que[tail].y = starty;
    que[tail].f = 0;
    que[tail].s = 0;
    tail++;
    book[startx][starty] = 1;
    
    flag = 0;  //用来标记是否达到目标点，0表示未达到，1表示达到
    
    /**
           广度优先搜索
        1.首先数据结构选择哪种类型：数组
          栈先进后出（只需要标记头）
          队列先进先出（需要标记头和尾）
          选择队列
        2.既然选择了队列，那么退出条件就是head < tail
        3.一个位置所包含的参数que（数组）（横坐标 纵坐标 父亲 步数）  
                               book（标记已经走过的点）  
                               head头的坐标：一个头的下一个点的坐标有好几种坐标
                               tail尾的坐标：每次走一步都递增
        4.刚才已经初始化第一个点的值
        5.下一个点的坐标：for循环走四个方向
                           所以需要用一个数组标记出这四个方向，按优先级顺序排好
              需要判断的条件：是否越界
                               如果不是障碍物且这条路没走过，就可以  
          
    **/
    while(head < tail)
    {
        //枚举四个方向
        for(k = 0; k <= 3; k++)
        {
            //计算下一个点的坐标
            tx = que[head].x + next[k][0];
            ty = que[head].y + next[k][1];
            //判断是否越界
            if(tx < 1 || tx > n || ty < 1 || ty > m)
                continue;
            //如果不是障碍物且这条路没走过
            if(a[tx][ty] == 0 && book[tx][ty] == 0)
            {
                book[tx][ty] = 1;
                que[tail].x = tx;
                que[tail].y = ty;
                que[tail].f = head;
                que[tail].s = que[head].s + 1;  //哇哇哇，这个很重要，是head+1
                tail++;
            }
            
            if(tx = p && ty == q)
            {
                flag = 1;
                break;
            }
        }
        if(flag == 1)
            break;
        head++;
    }
    printf("%d", que[tail - 1].s);
    
}
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
12.炸弹人问题
struct note
{
    int x; 
    int y;
};

char a[20][21];  //用来储存地图

int getnum(int i, int j)
{
    int sum, x, y;
    sum = 0;   //sum用来计数（可以消灭的敌人数）
    //向上统计可以消灭的敌人数
    x = i;
    y = j;
    while(a[x][y] != '#')   //#的意思是墙
    {
        if(a[x][y] == 'G')   //G的意思是炸弹
            sum++;
        x--;
    }
    
    //向下统计可以消灭的敌人数
    x = i;
    y = j;
    while(a[x][y] != '#')
    {
        if(a[x][y] == 'G')
            sum++;
        x++;
    }
    
    //向左统计可以消灭的敌人数
    x = i;
    y = j;
    while(a[x][y] != '#')
    {
        if(a[x][y] == 'G')
            sum++;
        y--;
    }
    
    //向右统计可以消灭的敌人数
    x = i;
    y = j;
    while(a[x][y] != '#')
    {
        if(a[x][y] == 'G')
            sum++;
        y++;
    }
    return sum;    
}

int main()
{
    struct note que[401];    //假设地图大小不超过20 * 20，因此队列扩展不会超过400个
    int head, tail;
    int i, j, k, sum, max = 0, mx , my, n, m, startx, starty, tx, ty;
    int book[20][20] = {0};
    int next[4][2] = {
                      {0, 1},   //往右走 
                      {1, 0},   //往下走
                      {0, -1},  //往左走
                      {-1, 0}   //往上走
                     };
    //n为行  m为列
    scanf("%d %d %d %d", &n, &m, &startx, &starty);
    //初始化这个地图
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    }
    
    head = 1; 
    tail = 1;
    que[tail].x = startx;
    que[tail].y = starty;
    tail++;
    book[startx][starty] = 1;
    max = getnum(startx, starty);
    mx = startx;
    my = starty;
    
    /**
            炸弹人问题
            【问题的目的就是找出多条连续且可以到达的线路，判断线路之中的点可以消灭的敌人总数
              使用广度优先搜索可以找出线路，具体方法是找出一个点，找出这个点所能到达的所有点，再找出
              到达下一个点之后所能到达的所有点，[1，2，3，4，5]，1可以到达2，3，2可以到达4，5  将head不断++
              就遍历了所有的点】
            1.分为找到下个点    和    下个点可以消灭的敌人总数
            2.相关参数:que（x, y）点的坐标
                       book  走过的点
                       mx，my最终找出的点的坐标
                       max 最多炸的敌人
            3.tail相当于一个指针，指向的是第一个没有赋值的xy坐标的位置
            4.head相当于测试指针，测试下一个点有多少种可能
                       
    **/
    while(head < tail)
    {
        for(k = 0; k <= 3; k++)
        {
            tx = que[head].x + next[k][0];
            ty = que[head].y + next[k][1];
            
            if(tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1)
                continue;
            if(a[tx][ty] == '.' && book[tx][ty] == 0)
            {
                book[tx][ty] = 1;
                que[tail].x = tx;
                que[tail].y = ty;
                tail++;
                
                sum = getnum(tx, ty);
                
                if(sum > max)
                {
                    max = sum;
                    mx = tx;
                    my = ty;
                }
            }
        }
        head++;
    }
    printf("将炸弹放在（%d, %d）处，可以消灭%d个敌人\n",mx, my, max);
}
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
3.
//如果是用广度优先遍历树，可以用一个链表将数据储存起来，就是有头有尾的数组
int main()
{
    int i, j, n, m, a, b, cur, book[101] = {0}, e[101][101];
    int que[10001], head, tail;
    scanf("%d %d", &n, &m);   //n是顶点的个数，m是边的条数
    
    //初始化矩阵
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if(i == j)
                e[i][j] = 0;
            else
                e[i][j] = 999999999;
        }
    }
    
    //读入顶点的边
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d", &a, &b);
        e[a][b] = 1;
        e[b][a] = 1;
    }
    
    //队列初始化
    head = 1;
    tail = 1;
    
    //从1号顶点出发，将1号顶点加入队列
    que[tail] = 1;
    tail++;
    book[1] = 1;
    
    while(head < tail && tail <= n)
    {
        cur = que[head];
        for(i = 1; i <= n; i++)
        {
            if(e[cur][i] == 1 && book[i] == 0)
            {
                que[tail] = i;
                tail++;
                book[i] = 1;  //完啦就是完啦，不会再用，是一行一行的遍历
            }
            
            if(tail > n)
            {
                break;
            }
        }
        head++;
    }
    
    for(i = 1; i < tail; i++)
        printf("%d", que[i]);
}
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
4.到某一点的最短路径，广度优先搜索
/* 
   正方形打两个叉刨了1-5的那条路线
   1       2
       3   
   5       4
*/

struct note
{
    int x;  //城市编号
    int s;  //转机次数
};

int main()
{
    struct note que[2501];
    int e[51][51] = {0}, book[51] = {0};
    int head, tail;
    int i, j, n, m, a, b, cur, start, end, flag = 0;
    scanf("%d %d %d %d", &n, &m, &start, &end);
    
    //初始化二维数组
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if(i == j)
                e[i][j] = 0;
            else
                e[i][j] = 999999999;
        }
    }
    
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d", &a, &b);
        e[a][b] = 1;
        e[b][a] = 1;
    }
    
    //队列初始化
    head = 1;
    tail = 1;
    
    que[tail].x = start;
    que[tail].s = 0;
    tail++;
    book[start] = 1;
    
    
    /**
            广度优先搜索
          从第一个点开始，直接所能到达的点，肯定是到达这个点最短的，从下一个点到达的下一个点肯定是到
          达这个点最短的，所以广度优先搜索就直接把点排后头
          
          所需要的参数：que[] （x 城市编号   s 转机次数）
                         head  tail
          先把第一个点初始化
    **/
    //当队列不为空时候循环
    while(head < tail)
    {
        cur = que[head].x;
        for(j = 1; j <= n; j++)
        {
            if(e[cur][j] != 99999999 && book[j] == 0)
            {
                que[tail].x = j;
                que[tail].s = que[head].s + 1;
                tail++;
                book[j] = 1;
            }
            
            //如果达到目标城市，停止扩展，任务结束，退出循环
            if(que[tail - 1].x == end)
            {
                flag = 1;
                break;
            }
        }
    }
    printf("%d", que[tail - 1].s);
}

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
*****深度优先搜索*******（就是从树的头开始，从头到尾找一遍，再从头到尾找一遍）

6.输出一组数的全排列，就是在一排盒子里依次放最小的数，放满之后，把从最后再拿出
int a[10], book[10], n;   //C语言全局变量在没有赋值前默认为0

void dfs(int step)   //step表示现在站在第几个盒子面前
{
    int i;
    if(step == n + 1)   //总共就有n个数，你却成了n + 1，意思就是提示该输出了，已经排好了
    {
        //输出一种排列（1-n号盒子中的扑克牌编号）
        for(i = 1; i <= n; i++)
            printf("%d", a[i]);
        printf("\n");

        return;  //返回之前的一步（最近一次调用dfs函数的地方）
    }

    /*输出结果一部分：
        1234
        1243
        1324
        1342
        1423
        1432
        */
    for(i = 1; i <= n; i++)
    {
        if(book[i] == 0)    //还是用book来判断数字是否输出过
        {
            a[step] = i;
            book[i] = 1;
            dfs(step + 1);    //到这个就是一个一个输入数据，直到输满执行上面的，输出
            book[i] = 0;      //输出完成之后，执行这个，dfs保存了book的地址，执行下面的语句，控制权交给了上一个函数
                              //所以下一步就是执行for循环，刚才已经把4的位置设成了0，所以在第3位上就是4，
        }
    }
    return;
}

int main()
{
    scanf("%d", &n);
    dfs(1);
}
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————4

7.///*** + *** = ***   且这9个数不重复

int a[10], book[10], total = 0;

void dfs(int step)  //表示站在第几个盒子前
{
    if(a[1] * 100 + a[2] * 10 + a[3] + a[4] * 100 + a[5] * 10 + a[6] == a[7] * 100 + a[8] * 10 + a[9])
    {
        total++;
        printf("%d%d%d + %d%d%d = %d%d%d\n",a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9]);
        return; 
    }
    
    for(i = 1; i <= 9; i++)
    {
        //如果只看第一个数字，后边默认都是排好的
        if(book[i] == 0)     //首先得看i是否是排过的数字
        {
            a[step] = i;     //如果没有排过，在第step个盒子面前把数字塞进去
            book[i] = 1;     //同时把book设为1
            dfs(step+1);     //排后面默认排好的数字
            book[i] = 0;     //如果是1，就表示，已经把这个数字塞入某一个箱子里了，为0把这张牌取出，这张牌在
			                 //这个位置的所有情况已经排好，在剩下的牌中选择最小的塞进去
        }
    }
    return;
}

int main()
{
    dfs(1);
    printf("total = %d", total / 2);  //除以2的原因是1 + 2 = 3和2 + 1 = 3是一样的
}

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
8.
走迷宫，最短距离，有障碍的地方不能通过
int n, m, p, q, min = 99999999;
int a[51][51], book[51][51];

void dfs(int x, int y, int step)
{
    ///因为起点的坐标是1，1，他要找到点，一定往右走和往下走是最优先的选择
    int next[4][2] = {
                      {0, 1},   //往右走 
                      {1, 0},   //往下走
                      {0, -1},  //往左走
                      {-1, 0}   //往上走
                     };
    int tx, ty, k;
    
    ///我觉得，这种递归法用来判断的，就用if语句为退出的条件
    ///咱类比一个数组，数组第一个元素有1，2，3，4，5好几种选择，所以要用for循环，数组之后的元素调用递归函数，就相当于
    ///解决了之后元素的问题啦
    //判断是否达到小哈的位置
    if(x == p && y == q)
    {
        if(step < min)
            min = step;
        return ;   
    }
    
    //枚举四种走法
    for(k = 0; k <= 3; k++)
    {
        //计算下一个点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];
        
        //判断是否越界,如果越界，换下一种走法
        if(tx < 1 || tx > n || ty < 1 || ty > m)
            continue;
        
        //判断该点是否为障碍物或者已经在路径中
        if(a[tx][ty] == 0 && book[tx][ty] == 0)  ///障碍物就为0，已经做过的事，不需要再做用book法
        {
			//单线程，要走它，设为1，把他后面走完啦，结束，把它设为0，是一条线，广度优先是走一次就把在这个位置上所有的情况都走完，以后不再走
            book[tx][ty] = 1;   //标记这个点已经走过
            dfs(tx, ty, step + 1);  //测试剩余的点
            book[tx][ty] = 0;   //这个点测试完毕，结束，意思就是在这条路线中这个点作用完啦，但在下一条路线中可能还有它，所以设为0，防止
								//下一次走它
        }
    }
    return ;
}

int main()
{
    int i, j, startx, starty;
    
    //n为行， m为列
    scanf("%d %d", &n, &m);
    //读入迷宫
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    }
    
    //读入起点和终点坐标
    scanf("%d %d %d %d", &startx, &starty, &p, &q);
    
    //从起点开始搜索
    book[startx][starty] = 1;   //book为1，就意为着走过这个点
    dfs(startx, starty, 0);
    
    //输出最短步数
    printf("%d", min);
}

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
4.炸弹人问题
char a[20][21];
int book[20][20], max, mx, my, n, m;
int getnum(int i, int j)
{
    int sum, x, y;
    sum = 0;
    
    //上敌人
    x = i;
    y = j;
    while(a[x][y] != '#')
    {
        if(a[x][y] == 'G')
            sum++;
        x--;
    }
    
    //下敌人
    x = i;
    y = j;
    while(a[x][y] != '#')
    {
        if(a[x][y] == 'G')
            sum++;
        x++;
    }
    
    //左敌人
    x = i;
    y = j;
    while(a[x][y] != '#')
    {
        if(a[x][y] == 'G')
            sum++;
        y--;
    }
    
    //右敌人
    x = i;
    y = j;
    while(a[x][y] != '#')
    {
        if(a[x][y] == 'G')
            sum++;
        x++;
    }
    return sum;
}


void dfs(int x ,int y)
{
    int next[4][2] = {
                      {0, 1},   //往右走 
                      {1, 0},   //往下走
                      {0, -1},  //往左走
                      {-1, 0}   //往上走
                     };
    int k, sum, tx, ty;
    sum = getnum(x, y);
    
    if(sum > max)
    {
        max = sum;
        mx = x;
        my = y;
    }
    
    for(k = 0; k <= 3; k++)
    {
        tx = x + next[k][0];
        ty = y + next[k][1];
        
        if(tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1)
            continue;
        if(a[tx][ty] == '.' && book[tx][ty] == 0)
        {
            book[tx][ty] = 1;   //这个点设为1表示测试过了，以后不用看他周围有多少个炸弹了，所以不用再设为0
			/*
			
			sum = getnum(x, y);
			if(sum > max)
			{
				max = sum;
				mx = x;
				my = y;
			}
			
			*/
            dfs(tx, ty);
        }
    }
    return;
}


int main()
{
    scanf("%d %d %d %d", &n, &m, &startx, &starty);
    
    for(i = 0; i <= n - 1; i++)
        scanf("%s", a[i]);
    
    //放第一个数据
    book[startx][starty] = 1;
    max = getnum(startx, starty);
    mx = startx;
    my = starty;
    
    dfs(startx, starty);
    
    printf("将炸弹放在（%d, %d）处，可以消灭%d个敌人\n",mx, my, max);
}
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
5.想知道这个地图中有多少个独立的小岛
int a[51][51];
int book[51][51], n, m;
//我感觉这个程序的主要目的就是为了突出染色（///）的目的，如果直接用book数组（//），我用注释标出来了
void dfs(int x, int y, int color)
{
    int next[4][2] = {
                      {0, 1},   //往右走 
                      {1, 0},   //往下走
                      {0, -1},  //往左走
                      {-1, 0}   //往上走
                     };
    int k, tx, ty;
    ///a[x][y] = color;  //对这个格子进行染色，表示用过这个格子了，不需要再用了，染色就相当于标记
    
    for(k = 0; k <= 3; k++)
    {
        tx = x + next[k][0];
        ty = y + next[k][1];
        
        if(tx < 1 || tx > n || ty < 1 || ty > m)
            continue;
        if(a[tx][ty] > 0 && book[tx][ty] == 0)  //a[tx][ty] > 0表示他既不是被染色的，也不是海洋
		//if(a[tx][ty] !=  0 && book[tx][ty] == 0)
        {      
            book[tx][ty] = 1;
            dfs(tx, ty, color);
        }
    }
    return;
}


int main()
{
    int i, j, num = 0;
    scanf("%d %d", &n, &m);
    
    //输入这个地图
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    }
    
    
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= m; j++)
        {
            if(a[i][j] > 0)   //0是海洋，表示他既不是被染色的，也不是海洋  
			//if(a[i][j] > 0 && book[i][j] == 1)
            {
                ///num--;  //相当于计数器和染色器
                ///book[i][j] = 1;
                dfs(i, j, num); //dfs(i, j, num);
            }
        }
    }
    
    //输出已经染色后的地图
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= m; j++)
        {
            printf("%3d", a[i][j]);
        }
        printf("\n");
    }
    
    //输出小岛的个数
    printf("有%d个小岛\n", -num);
    
}
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
6.有直管子和弯管子，管子向2点钟方向弯  为1， 顺时针分别为1234，左右直管5，上下直管6
int a[51][51];    //假设土地的大小不超过50 * 50
int book[51][51], n, m, flag = 0;

struct note
{
    int x; 
    int y;
}s[100];   //就是这样保存变量容易一些

int top = 0;

void dfs(int x, int y, int front)
{
    int i;
    //判断是否达到终点
    if(x == n && y == m + 1)  //注意这里是m + 1，因为终点在边界那里
    {
        flag= 1;
        for(i = 1; i <= top; i++)
            printf("(%d, %d)", s[i].x, s[i].y);
        return;
    }
    
    /**
            姿姿小课堂又来啦
            1.走分为咋走和碰到阻碍咋地办
            2.碰到阻碍咋地办
                下面这些情况说明这条路线就是错误的，赶紧return吧
                    碰墙啦        return       
                    碰到鬼打墙    return
                这还有救：
                    撞树啦    看到树不走就好了
            3.咋地走呀
               首先得知道你从哪里来，上1 下2 左3 右4， front
                直管子：直来直去，只有一种情况
                
                弯管子：有两个可以弯的方向
            4.走完
              判断这条路线可以到达终点不，到达了，输出它
              这条路线就完啦，把他们设为没走过的情况
    **/
    //判断是否越界
    if(x < 1 || x > n || y < 1 || y > m)
        return;
    if(book[x][y] == 1)   //啥意思了，就是在一条路线之中，走的走的被自己这条路线挡住了，所以不符合题意，所以返回
        return;
    book[x][y] = 1;
    
    //将当前尝试的坐标入栈
    top++;   //top指向的是最后一个坐标
    s[top].x = x;
    s[top].y = y;
    
    //当前水管是直管的情况
    if(a[x][y] >= 5 && a[x][y] <= 6)
    {
        if(front == 1)   //进水口在左边的情况
        {
            dfs(x, y + 1, 1);
        }
        
        if(front == 2)   //进水口在上边的情况
        {
            dfs(x + 1, y, 2);
        }
        
        if(front == 3)   //进水口在右边的情况
        {
            dfs(x, y + 1, 3);
        }
        
        if(front == 4)   //进水口在下边的情况
        {
            dfs(x - 1, y, 4);
        }
    }
    
    if(a[x][y] >= 1 && a[x][y] <= 4)
    {
        if(front == 1)  //进水口在左边的情况
        {
            dfs(x + 1, y, 2); //3号状态
            dfs(x - 1, y, 4); //4号状态
        }
        
        if(front == 2)  //进水口在上边的情况
        {
            dfs(x, y + 1, 1); //1号状态
            dfs(x, y - 1, 3); //4号状态
        }
        
        if(front == 3)  //进水口在右边的情况
        {
            dfs(x - 1, y, 4); //1号状态
            dfs(x + 1, y, 2); //2号状态
        }
        
        if(front == 4)  //进水口在下边的情况
        {
            dfs(x, y + 1, 1); //2号状态
            dfs(x, y - 1, 3); //3号状态
        }
           
    }
    
    book[x][y] = 0; //因为是深度遍历搜索，所以设为0可以让另一条路线再次使用
    top--; //将当前尝试的坐标出栈
    return;
}

int main()
{
    int i, j, num = 0;
    scanf("%d %d", &n, &m);
    
    //读入游戏地图
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    }
    
    //开始搜索，从1，1点开始，进水方向也是1
    dfs(1,1,1);
    //判断是否找到铺设方案
    if(flag == 0)
        printf("inpossible\n");
}
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
7.
//用图模拟图的深度遍历 1-1是0   1-没有是无穷  是双向图 就是1-2 和 2-1都是1
//输出的结果是：按照深度遍历顶点的顺序
int book[101], sum, n, e[101][101];
void dfs(int cur)  //cur是当前顶点所在编号
{
    int i;
    printf("%d", cur);   
    sum++;    //已经访问过顶点的个数
    if(sum == n)
        return;   //所有顶点都已经访问过，直接退出
    /**
            对于一个点来说，要想实现深度遍历，需要找到下一个元素，这个元素用完之后就不再看他了，因为输出的就是遍历
            顶点的顺序，经历过他所以用book[i]来表示不再看的元素
    **/
    for(i = 1; i <= n; i++)
    {
        if(e[cur][i] == 1 && book[i] == 0)
        {
            book[i] = 1;  
            dfs(i);
        }
    }
    return;
}

int main()
{
    int i, j, m, a, b;
    scanf("%d %d", &n, &m);
    //初始化二维矩阵，就是把大概的输出来
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= m; j++)
        {
            if(i == j)
                e[i][j] = 0;
            else
                e[i][j] = 999999999;
        }
    }

    //读入顶点的边
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d", &a, &b);
        e[a][b] = 1;
        e[b][a] = 1;   //这里是无向图，所以将e[a][b]也赋为1
    }
    
    //从1号顶点出发
    book[1] = 1; //标记1号顶点已经访问
    dfs(1); // 从1号顶点开始遍历
}
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
8.
//一个城市到达另一个城市的最短距离，带权边的图，深度遍历
int min = 999999999, book[101], n, e[101][101];

void dfs(int cur, int dis)  //cur是当前所在城市编号，dis是当前已经走过的路径
{
    int j;
    //如果当前走过的路程已经大于之前找到的最短路，则没有必要往下试了，立即返回
    if(dis > min)
        return;
        
    if(cur == n)  //判断是否达到了目标城市
    {
        if(dis < min)
            min = dis;  //更新最小值
        return;
    }
    
    for(j = 1; j <= n; j++)   //cur是横坐标，j是遍历纵坐标
    {
        if(e[cur][j] != 999999999 && book[j] == 0)
        {
            book[j] = 1;    //把这个城市设置为走过
            dfs(j, dis + e[cur][j]);
            book[j] = 0;
        }
    }
    return;
}

int main()
{
    int i, j, m, a, b, c;
    scanf("%d %d", &n, &m);
    //初始化二维矩阵
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if(i == j)
                e[i][j] = 0;
            else
                e[a][b] = c;
        }
    }
    
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d %d", &a, &b, &c);
        e[a][b] = c;
    }
    
    book[1] = 1;
    dfs(1, 0);
    printf("%d", min);
}


   
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
*****f弗洛伊德算法*******————————最短路径问题————————————时间复杂度O(n³)
通过经过一个中转点，两个中转点，不断更新
//求两个城市之间的最短路径
//带权边 的图
int main()
{
    int e[10][10], k, i, j, n, m, t1, t2, t3;
    int inf = 99999999;
    
    //读入n和m，n表示顶点个数，m表示边的条数
    scanf("%d %d", &n, &m);
    
    //初始化
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if(i == j)
                e[i][j] == 0;
            else
                e[i][j] == inf;
        }
    }
    
    //读入边
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d %d", &t1, &t2, &t3);
        e[t1][t2] = t3;
    }
    
    /**
        如果想去一个城市，第一种方法是直达可以更新一次数据，第二种方法是经过一个站点，再去你想去的城市
        再更新一次数据，此时图中的值就是在直达和经过一次站点当中选出的最优解；如果是经历两次站点，虽然
        表达式是e[i][j] = e[i][k] + e[k][j];但其实在之中已经包含了经过一次站点的情况，因为选出的是最优解
    **/
	//之前在图中储存的就是不经过中转点的距离，经过2号中转点就默认经过一个中转点
    for(k = 1; k <= n; k++)    //对中间顶点遍历，中转点
    {
        //以下两个for循环是对两个要
		for(i = 1; i <= n; j++)
        {
            for(j = 1; j <= n; j++)
            {
                if(e[i][j] > e[i][k] + e[k][j])
                    e[i][j] = e[i][k] + e[k][j];
            }
        }
    }
}
==============
如何表示正无穷
==============
1。int类型可以储存的最大整数是2147 4836 47   
2.将正无穷定义为9999 9999
3.如果有100条边，每条边不超过100的话，只需要将正无穷设置为10001
3.如果你认为正无穷和其他值相加得到一个大于正无穷的数是不被允许的话，我们只需在比较的时候加两个判断条件就可以了
for(k = 1; k <= n; k++)
    {
        for(i = 1; i <= n; j++)
        {
            for(j = 1; j <= n; j++)
            {
				if(e[i][k] < inf && e[k][j] < inf && e[i][j] > e[i][k] + e[k][j])
                    e[i][j] = e[i][k] + e[k][j];
            }
        }
    }
==============
这个算法可以处理带负权边的图
但是不可以处理带有负权回路的图：例如一个圈各个边的总和加起来是负数，那么每转一次圈，就减少1，永远找不到最短路径
==============

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
*****迪克斯拉特   ————   最短路径问题******
通过每次找出dis数组中最小的距离，再更新这个最小距离所对应的点所对应的距离
1.步骤
  找出最便宜的节点，即可在最短时间内到达的节点
  更新该节点邻居的开销
  重复这个过程
  计算最终路径
2.无向图就是环
  狄克斯特拉算法只适用于有向无环图
3.最短路径指的并不一定是物理距离，也可能是让某种度量指标最小
4.负权边
  如果有负权边，就不能使用狄克斯特拉算法
  
  
 （乐谱指向黑胶唱片5）黑胶唱片
			  乐谱        |-7
 （乐谱指向海报是0）海报—————>架子鼓
						  35
						  
  解释：首先乐谱指向海报为0，少，执行海报，找海报的指向只有一个架子鼓，更新为35，然后再更新海报为-2，由于先后关系，最终架子鼓是35，而不是32
  
  *如果有负权边，使用贝尔曼福德算法


#include <stdio.h>
#include <string.h>

int main(void)
{
    int e[10][10], dis[10], book[10], i, j, n, m, t1, t2, t3, u, v, min;
    int inf = 99999999;   //储存一个正无穷值

    //n表示顶点个数， m表示边的条数
    scanf("%d %d", &n, &m);

    //初始化
    for(i = 1; i < n; i++);
    {
        for(j = 1; j <= n; j++)
        {
            if(i == j)
                e[i][j] = 0;
            else
                e[i][j] = inf;
        }
    }
    //读入边
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d %d", &t1, &t2, &t3);
        e[t1][t2] = t3;  //t1是竖的  t2是横的  t1指到t2的距离是1
    }
    //初始化dis数据，这里是一号顶点到其余各个顶点的初始路程,因为i从1开始，所以这里最终表示的就是到达i的最短距离
    for(i = 1; i <= n; i++)
        dis[i] = e[1][i];

    //book数组初始化，记录是否查过这个点所对应的各个路线，查过记为1
    for(i = 1; i <= n; i++)
        book[i] = 0;
    book[1] = 1;    //因为第一个差的就是1，所以肯定要先记为1


	/*
		狄克斯特拉算法
		首先是分治算法，最简单的情况，只有一个点，就是0，如果是一个点对应多个点，直接更新
		找出每一次最小的距离，更新这个最小距离对应的点，更新这个点
	*/
	
	
    for(i = 1; i < n; i++)   //为什么是i < n,因为，最后一个就不查了
    {
        min = inf;
        for(j = 1; j <= n; j++)  
        {
            if(book[j] == 0 && dis[j] < min)   
            {
                min = dis[j];     
                u = j;   
            }
        }
        book[u] = 1;  //把这个值设为1，意思就是下一个值要从u开始查了
        for(v = 1; v <= n; v++)
        {
            if(e[u][v] < inf)     //u是将要查的这个节点，v是这个节点存值的地方，比如v = 1
            {
                if(dis[v] > dis[u] + e[u][v])    //如果dis在1处存的值比先到u，再从u-1的值要大，而后面存的一些值都是9999999，肯定大
                    dis[v] =  dis[u] + e[u][v];  //就把原来在1处存的值换掉

            }
        }

        //输出最终的结果
        for(i = 1; i <= n; i++)
            printf("%d", dis[i]);

        return 0;

    }
}

2.
//求两个城市之间的最短路径
//带权边的图
int main()
{
    int e[10][10], dis[10], book[10], i, j, n, m, t1, t2, t3, u, v, min;
    int inf = 99999999;
    
    //读入n和m，n表示顶点个数，m表示边的条数
    scanf("%d %d", &n, &m);
    
    //初始化
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if(i == j)
                e[i][j] == 0;
            else
                e[i][j] == inf;
        }
    }
    
    //读入边
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d %d", &t1, &t2, &t3);
        e[t1][t2] = t3;
    }
    
    //初始化dis数组，这里是1号顶点到其余各个顶点的初始路程
    for(i = 1; i <= n; i++)
        dis[i] = e[1][i];
    
    for(i = 1; i <= n; i++)
        book[i] = 0;
    book[1] = 1;
    
    /**
        这个算法的主要目的是不断更新dis的值
        首先，将dis初始化为1所对应的一个横行，并将1所对应的book值设为1，book的目的是标记当前所有book值
        不是1当中的最小值，将这个最小值设为1，每一次遍历，都可能会将后面无穷大元素设为一个小于无穷大的值
        ，所以有可能遍历到全部的点
        
        不断选出1所能到达的最小值，这个最小值就是到达这个点的最小值，为啥，如果这个不是到达这个点的最小值的话
        ，那肯定1得首先经过一个点，再到达这个点，肯定比原来大，因为本来到大的就是最小值
        
    **/
    for(i = 1; i <= n - 1; i++)   //1所到达顶点的个数最多是n - 1，
    {
        min = inf;
        for(j = 1; j <= n; j++)   //选出1后元素的最小值
        {
            if(book[j] == 0 && dis[j] < min)
            {
                min = dis[j];
                u = j;
            }
        }
        book[u] = 1;    //这个最小值已经选过了，设为1，下次不再选
        for(v = 1; v <= n; v++)
        {
            if(e[u][v] < inf)
            {
                if(dis[v] > dis[u] + e[u][v])
                    dis[v] = dis[u] + e[u][v];
            }
        }
    }
    for(i = 1; i <= n; i++)
        printf("%d", dis[i]);
}

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
***********
  邻接表
***********
//邻接表,就是储存图的一种方法
//使用邻接表来储存图的时间空间的复杂度O(M),遍历每一条边的复杂度也是O(M)
int main()
{
    int n, m, i;   //n表示顶点个数，m表示边的条数
    int u[6], v[6], w[6];
    
    //first要比n的最大值大一，next要比m的最大值大1
    int first[5], next[6];
    scanf("%d %d", &n, &m);
    
    //初始化first数组下标1~n的值为-1，表示1~n顶点暂时都没有边
    for(i = 1; i <= m; i++)
        first[i] = -1;
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d %d", &u[i], &v[i], &w[i]);
		next[i] = first[u[i]];
        first[u[i]] = i;
    }
    
    
    /**
         
         first是根据顶点找下标，next是根据下标找找下一个下标
		 uvw是输入每一个数据，并把每一个数据都分配了一个下标
         
            u   v   w      first      next
         1  1   4   9    1   1    1    -1
         2               2   -1   2
         3               3   -1   3
         4               4   -1   4
         5                        5
         
         
         编号为2的边是4号顶点为起始点的第一条边，所以将next[2]的值设为-1
         
            u   v   w      first      next
         1  1   4   9    1   1    1    -1
         2  4   3   8    2  -1    2    -1
         3               3  -1    3
         4               4   2    4
         5                        5
          
            u   v   w      first      next
         1  1   4   9    1   3    1    -1
         2  4   3   8    2  -1    2    -1
         3  1   2   5    3  -1    3     1
         4               4   2    4
         5                        5
          
            u   v   w      first      next
         1  1   4   9    1   3    1    -1
         2  4   3   8    2   4    2    -1
         3  1   2   5    3  -1    3     1
         4  2   4   6    4   2    4    -1
         5                        5
          
            u   v   w      first      next
         1  1   4   9    1   5    1    -1
         2  4   3   8    2   4    2    -1
         3  1   2   5    3  -1    3     1
         4  2   4   6    4   2    4    -1
         5  1   3   7             5     3
          
    **/
    
    //遍历1号顶点每条边的代码
    k = first[1];
    while(k != -1)
    {
        printf("%d %d %d\n", u[k], v[k], w[k]);
        k = next[k];
    }
    
    //遍历每个顶点的所有边的代码
    for(i = 1; i <= n; i++)
    {
        k = first[i];
        while(k != -1)
        {
            printf("%d %d %d\n", u[k], v[k], w[k]);
            k = next[k];
        }
    }
    
}



2.算法演示
bellman——解决负权边的算法
int main()
{
    int dis[10], bak[10], i, k, n, m, u[10], v[10], w[10], check, flag;
    int inf = 99999999;
    //n表示顶点个数，m表示边的条数
    scanf("%d %d", &n, &m);
    
    //读入边  从u到v的距离为w
    for(i = 1; i <= m; i++)
        scanf("%d %d %d", &u[i], &v[i], &w[i]);
    
    for(i = 1; i <= n; i++)
        dis[i] = inf;
    dis[1] = 0;
    /**
        在最开始初始化的时候，把dis[1]的值设为0，剩余都设为无穷大
        假设：边的顺序为
        2  3  2
        1  2  -3
        1  5  5
        4  5  2
        3  4  3
        
        第一步：1->2  +  2->3  是否小于  1->3
        所以，把dis[1]设为0，就是1号顶点到达二号顶点距离为-3，-3 < 99999，所以更新
        所以，第一轮更新可以从1号顶点直接到达的，第二轮更新需要一个中转站才能到达的
        结论：至多进行n-1次松弛，但不一定是每次都是按二叉树行来初始化的，得看uvw边的
               先后顺序
        
        问题：最短路径中是否可能包含回路，最短路径肯定是一个不包含回路的简单路径
              回路分为正权回路和负权回路
              正权回路：每次加越来越多，去掉更少
              负权回路：没有最短，算法如下
            for(k = 1; k <= n - 1; k++)   
            {
                for(i = 1; i <= m; i++)   //遍历那个边的数组
                {
                    if(dis[v[i]] > dis[u[i]] + w[i])
                        dis[v[i]] = dis[u[i]] + w[i];
                }
            }
            //检测负权回路，上面的已经是最小了，再循环也不可能变了，如果变了，就是有负权边，因为要把uvw都循环一次才能看出，所以要循环
			//小于m
            flag = 0;
            for(i = 1; i <= m; i++)
            {
                if(dis[v[i]] > dis[u[i]] + w[i])
                    flag = 1;
            }
            if(flag == 1)
                printf("此图含有负权回路");
              
    
    **/
    for(k = 1; k <= n - 1; k++)   //每次遍历都更新一部分点的值
    {
        check = 0;   //用来标记在本轮松弛中数组dis是否会发生更新
		for(i = 1; i <= m; i++)
        {
            if(dis[v[i]] > dis[u[i]] + w[i])    //到3号点的>到2号点的 + 2-3号点的
			{
                dis[v[i]] = dis[u[i]] + w[i];
				check = 1;   
			}
        }
		
		if(check == 0)  //如果最终check的值为0，就说明这次循环所有点都没变，说明已经弄好了
			break;
    }
    
	flag = 0;
	for(i = 1; i <= m; i++)
	{
		if(dis[v[i]] > dis[u[i]] + w[i])
			flag = 1;
	}
	if(flag == 1)
		printf("此图含有负权回路");
	else
	{
		//输出结果
		for(i = 1; i <= n; i++)
			printf("%d", dis[i]);
	}
				
    
}

3.使用队列，邻接表来更新dis的值，就是1到各个点的距离的最小值
int main()
{
    int n, m, i, j, k;
    int u[8], v[8], w[8];
    int first[6], next[8];
    int dis[6] = {0}, book[6] = {0};
    int que[101] = {0}, head = 1, tail = 1;
    int inf = 99999999;
    
    //n是顶点，m是边数
    scanf("%d %d", &n, &m)
    for(i = 1; i <= n; i++)
        dis[i] = inf;
    dis[1] = 0;
    
    
    for(i = 1; i <= n; i++)
        book[i] = 0;
    for(i = 1; i <= n; i++)
        first[i] = -1;  //上面有个first表就是那个
    
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d %d", &u[i], &v[i], &w[i]);
        next[i] = first[u[i]];
        first[u[i]] = i;
    }
    
    que[tail] = 1;
    tail++;
    book[1] = 1;
    
    /**
            姿姿激情课堂又来啦！！！！！！
         1. 如何利用树的广度遍历来看这道题
                将所有出现的边都设为灰色（代表无穷大）   红色代表这条边上有值
                从1开始，可以到达的点，这条路线标成红色，并把可以到达的点按照先后顺序放在que队列中
                ，并将路线上的权值输入dis数组中，之后找到队列中的下一个点，更新dis数组的值，又可以
                将所可以到达点放入que中，如果之前有，就不放了.........
                
                问题：使用first和next数组的好处？
                    根据顶点坐标，可以快速定位这个点所伸出边的序号，根据next可以把这个点伸出的所有边都
                    找到，如果之前，就得一遍一遍遍历uvw
                
                问题：为什么要使用que队列？ 队列中元素的初始化为什么是像题目中所说？
                    使用que队列的目的是把所有的点都遍历完，que的目的就是入顶点
                    刚才我所描述的染色法，如果1号完了，直接是5号，而1号不可以直接到达5号，所以5号周围的
                    路线就都是灰色的，就是无穷大，无法更新出这个点的最小值，下一点必须是和之前的点有联
                    系的，就像墨水浸染一样
                
    **/
    while(head < tail)   //类似于广度优先遍历
    {
        k = first[que[head]]; //que是找到点，first是根据点找到边的编号
        while(k != -1)   //把这个点可以到达的所有点都找出来
        {
            if(dis[v[k]] > dis[u[k]] + w[k])
            {
                dis[v[k]] = dis[u[k]] + w[k];   //更新这个点
                if(book[v[k]] == 0)  //让这个点入队
                {
                    que[tail] = v[k];
                    tail++;
                    book[v[k]] = 1;
                }
            }
            k = next[k];
        }
        book[que[head]] = 0;  
        head++;
    }
    for(i = 1; i <= n; i++)
        printf("%d ", dis[i]);
}

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————






***图算法***
1.图由节点和边组成
   O————O     O是节点  ————是边
  一个节点可能与众多节点直接相连，这些节点被称为邻居

2.拓扑排序
如果任务A依赖于任务B，在列表中任务A就必须在任务B后面,小的指向大的

	  <-锻炼<-洗澡
起床<-  刷牙<-吃早餐
      <-打包午餐

#define OK 1
#define ERROR 0
#define MVNum 100

/**
    ——etv(Earliest Time Of Vertex):时间最早发生时间，就是顶点的最早发生时间
    ——lty(Latest Time Of Time Of Vertex)：事件最晚发生时间，就是每个顶点对应的事件最晚需要开始的时间
                                          如果超出此时间将会延误整个工期
    ——ete(Earliest Time Of Edge):活动的最早开工时间，就是弧的最早发生时间
    ——lte(Latest Time Of Edge):活动的最晚发生时间，就是不推迟工期的最晚开工时间
	老子不写笔记了，你下次必须给我看懂

**/

typedef int Status;
typedef char VerTexType;
typedef int OtherInfo;

typedef struct StackNode{
	int data;
	struct StackNode *next;
}StackNode, *StackList;

typedef struct ArcNode{
	int adjvex;
	struct ArcNode *nextarc;
	OtherInfo weight;
}ArcNode;

typedef struct VNode{
	VerTexType data;
	ArcNode *firstarc;
}VNode, AdjList[MVNum];

typedef struct{
	AdjList vertices;
	int vexnum, arcnum;
}ALGraph;


int indegree[MVNum] = { 0 };

InitStack(StackList *S)
{
	S = NULL;
	return S;
}

StackList Push(StackList S, int e)
{
	StackList p;
	p = (StackNode *)malloc(sizeof(StackNode));
	p->data = e;
	p->next = S;
	S = p;
	return S;
}

StackList Pop(StackList S, int *e)
{
	StackList p;
	p = S;
	if (!p)
		return ERROR;
	*e = p->data;
	S = S->next;
	free(p);
	return S;
}

int LocateVex(ALGraph *G, VerTexType v)
{
	int i;
	for (i = 0; i < (G->vexnum); i++)
	{
		if (v == G->vertices[i].data)
			return i;
	}
}

void CreateUDG(ALGraph *G)
{
	int i, j, k;
	OtherInfo w;
	VerTexType v1, v2;
	ArcNode *p1;
	printf("输入总节点数和总边数：");
	scanf("%d %d", &G->vexnum, &G->arcnum);
	fflush(stdin);
	printf("输入各个节点的值：");
	for (i = 0; i < G->vexnum; i++)
	{
		scanf("%c", &G->vertices[i].data);
		G->vertices[i].firstarc = NULL;
	}
	for (k = 0; k < G->arcnum; k++)
	{
		fflush(stdin);
		printf("输入一条边的两个节点以及边的权值：");
		scanf("%c %c %d", &v1, &v2, &w);
		i = LocateVex(G, v1);
		j = LocateVex(G, v2);
		p1 = (ArcNode *)malloc(sizeof(ArcNode));
		p1->adjvex = j;
		p1->weight = w;
		p1->nextarc = G->vertices[i].firstarc;
		G->vertices[i].firstarc = p1;
		indegree[j]++;
	}
}

int TopologicalSort(ALGraph G, int *topo)
{
	int i, m, k;
	StackList S;
	ArcNode *p;
	S = NULL;
	for (i = 0; i < G.vexnum; i++)
	{
		if (!indegree[i])
			S = Push(S, i);
	}
	m = 0;
	while (S)
	{
		S = Pop(S, &i);
		topo[m] = i;
		++m;
		p = G.vertices[i].firstarc;
		while (p != NULL)
		{
			k = p->adjvex;
			--indegree[k];
			if (indegree[k] == 0)
				S = Push(S, k);
			p = p->nextarc;
		}
	}
	topo[m] = -1;
	if (m < G.vexnum)
		return ERROR;
	else
		return OK;
}


Status CriticalPath(ALGraph G)
{
	int i, j, k, e, l;
	int *ve, *vl;
	int topo[MVNum];
	ArcNode *p;
	ve = (int *)malloc(sizeof(int)*G.vexnum);
	vl = (int *)malloc(sizeof(int)*G.vexnum);
	if (!TopologicalSort(G, topo))
		return ERROR;
	for (i = 0; i < G.vexnum; i++)
		ve[i] = 0;
	for (i = 0; i < G.vexnum; i++)
	{
		k = topo[i];
		p = G.vertices[k].firstarc;
		while (p)
		{
			j = p->adjvex;
			if (ve[j] < ve[k] + p->weight)
				ve[j] = ve[k] + p->weight;
			p = p->nextarc;
		}
	}
	for (i = 0; i < G.vexnum; i++)
		vl[i] = ve[G.vexnum - 1];
	for (i = G.vexnum - 1; i >= 0; i--)
	{
		k = topo[i];
		p = G.vertices[k].firstarc;
		while (p)
		{
			j = p->adjvex;
			if (vl[k]>vl[j] - p->weight)
				vl[k] = vl[j] - p->weight;
			p = p->nextarc;
		}
	}
	for (i = 0; i < G.vexnum; i++)
	{
		p = G.vertices[i].firstarc;
		while (p)
		{
			j = p->adjvex;
			e = ve[i];
			l = vl[j] - p->weight;
			if (e == l)
				printf("%c->%c\n", G.vertices[i].data, G.vertices[j].data);
			p = p->nextarc;
		}
	}
	return OK;
}

int main(void)
{
	ALGraph G;
	CreateUDG(&G);
	if (!CriticalPath(G))
		printf("错误\n");
	else
		printf("结束\n");
	return 0;
}


======================================================================================================================================================
**贪婪算法**（寻找局部最优解，企图以这种方式获得全局最优解）
1.教室调度问题（每节课的上课时间都有冲突）
  选出最早结束的课，它就是要在这间教室上的第一堂课
  接下来，必须选择第一堂课结束后才开始的课，同时，你选择结束最早的课，这将是要在这间教室上的第二堂课
  
  你每次都选择结束最早的课用专业术语说，就是你每步都选择局部最优解，最终的到的就是全局最优解
2.背包问题
  背包可装35磅  可以偷   音响30磅——3000美元   笔记本电脑20磅——2000美元   吉他——15磅——1500美元   
  如何使背包装的东西最贵
  算法：盗窃可装入背包最贵商品，再盗窃还可装入背包的最贵商品
3.集合覆盖问题
  如何找出覆盖全美50个州的最小广播台集合
  算法：选出这样一个广播台，即它覆盖了最多的未覆盖州
        重复第一步，直到覆盖了所有的州
4.判断近似算法的优劣程度
  速度有多快
  得到的近似解与最优解的近似程度
5.NP完全问题（以难解著称，根本不可能编写出可快速解决这些问题的算法）
  就是你需要计算所有的解，并从中选出最小，最短的那个
  包括：旅行商问题   第一个选择有5个，第二个有4个........就是得把所有的情况列出来，选
        集合覆盖问题   每个广播站所覆盖的范围不一样，选择最少广播站使得所有的区域都被覆盖.......就是得把所有的情况列出来，选
  特点：
  1）元素较少时算法的运行速度非常快，但随元素数量的增加，速度会变得非常慢
  2）涉及所有组合的问题通常是NP问题
  3）不能将问题分成小问题，问题之间相互联系，缠绕在一起，必须考虑各种可能的情况，这可能是NP完全问题
  4）如果问题涉及序列（如旅行商中的程序序列）且难以解决，它可能就是NP完全问题
  5）如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题
  6）如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题

======================================================================================================================================================
**动态规划**
1.它将问题分成小问题，并着手解决这些小问题，先解决小问题，再逐步解决大问题
2.背包问题（在规定范围内有多种选择，找到最优解）

  背包可装4磅  可以偷   音响4磅——3000美元   笔记本电脑3磅——2000美元   吉他1磅——1500美元   
  如何使背包装的东西最贵
  一行一行排    一种商品只能选一次所以只能选这行上边的
           1       2       3      4
吉他     1500    1500    1500    1500
音响     1500	 1500	 1500	 3000
笔记本   1500	 1500    2000    3500


公式   CELL[][] = 两者中较大的那个{1.上一个单元格的值     2.当前商品的价值 + 剩余空间的价值CELL[i - 1][j - 当前商品的重量]//i - 1的目的就是只能选择
																														  //这行上面的

  
    再增加一件商品将会如何（iphone 2000 1磅）
           1       2       3      4
吉他     1500    1500    1500    1500
音响     1500	 1500	 1500	 3000
笔记本   1500	 1500    2000    3500
IPHONE   2000    3500    3500    4000


    增加一件更小的商品将如何  （项链   0.5磅   1000美元）
    考虑的颗粒更细，因此必须调整网络
          0.5    1    1.5    2    2.5    3     3.5    4
吉他
音响
笔记本
项链


    *使用动态规划时，要么考虑拿走整件商品，要么考虑不拿，而没法判断该不该拿走商品的一部分		  
    *处理相互依赖的问题（这三个地方都在巴黎，如果从别地去这三个地是1.5天，而如果去了巴黎之后，就会变成一个1.5 剩下两个都是0.5）
		埃菲尔铁塔   1.5天
		卢浮宫       1.5天
		巴黎圣母院   1.5天
	*计算最终的解时会涉及两个以上的子背包吗，最后一个4 = 1（本身的重量）+3（剩余的重量），所以不会，但子背包可能又包含子背包
	*最优解有可能导致背包没装满
  
3.动态规划和贪婪算法一样都是自底向上分析问题的算法，但是动态规划着眼于全局最优解，而贪婪算法着眼于局部最优解
  动态规划和分治策略的区别在于  动态规划着眼于小问题再解决大问题   分治法是自定向下分析问题，先拆分大问题为小问题，解决了小问题后大问题即可解决

  
4.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/**
    最长公共部分序列：
    如果 A = "abcd", B = "xbadz"
    最长共同部分序列bd
	
	分为两种情况
	
	1.两个数字相同：aaa   bbba 
	  现在已经知道的就是a横行以上所有的数据，全为0，首先比较a和a，相等，为1，如果比较a和第二个a，相等，如果是上或左的数字加一，那就是2了
	  如果是左上角的数字加1，就是1，这到底是为什么呢？
	  如果知道两个数字相等，我所需要知道的条件就是在这两个数字之前有多少个相等的，再加上1，就是目前有多少个相等的
	  	  
	2.两个数字不同：abnh  abcc
	  我已经知道的条件就是abc和abnh有多少个相等的，拿c和abnh一个一个比较，假设一直比较到c和最后一个数字h，不相等，所以就是c之前所比较的情况加上已知条件
	  上面的情况同理去推。	  	  
	  
	递归大佬，给递归大佬端水果
	意思就是如果两个数字不相同，分别为1和2，分为两种情况：
	可以把指向2的指针向后移动一个，看看跟1相不相同;
	可以把指向1的指针向后移动一个，看看跟2相不相同;
	
	而在动态规划中也可以借鉴递归中的思想：
	如果两个数字不相同，可以往让指针往左移动一个，看看一个数组当中这个数字之前有多少个相同的
						可以往让指针往上移动一个，看看另一个数组当中这个数字之前有多少个相同的
						取这两个数字较大的那个
**/

void longst_common_subsequence(char *a, char *b, char *result)
{
    int **d;   //动态规划的那个二维数组
    int m = strlen(a), n = strlen(b);  //m是行  n是列
    int count, i, j;
    
    /*--------------get memory and initialize dope vector------------*/
    
    d = (int **)malloc(sizeof(int) * (m + 1)); //这个分配的是d[1] d[2]..总共有m + 1行
    d[0] = (int *)malloc(sizeof(int) * (m + 1) * (n + 1));//意思就是在d[0]指针所指向的地方分配了这个二维数组所需要的所有的内存
							
    for(i = 1; i <= m; i++)  //假设d[0]所到的最后一个元素是n + 1，所以下一个d[1]就从n + 1开始往后数n + 1，如果是n，就会少一个
	                         //n + 1正好
        d[i] = d[i - 1] + n + 1;
        
    /*--------------把d这个二维数组的第一行和第一列全部初始化为0------------*/
    
    d[0][0] = 0;
    for(i = 1; i <= m; d[i][0] = 0, i++);
    for(j = 1; j <= n; d[0][j] = 0, j++);
    
    /*-------------------------------------------------------------*/
    //m是行，n是列
    for(i = 1; i <= m; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if(a[i - 1] == b[j - 1])  //数组里面的元素是从0开始的，所以要减1
                d[i][j] = d[i - 1][j - 1] + 1;  //等于它对角线的元素加1
            
            //选择这个格子上边和左边中较大的，填入这个格子中
            else if(d[i][j - 1] > d[i - 1][j])
                d[i][j] = d[i][j - 1];   
            else
                d[i][j] = d[i - 1][j];
        }
    }
    
    /*-------------------------------------------------------------*/
    
    count = d[m][n];  //最后的数字，意思就是有几个是相等的
    result[count] = '\0';  //初始化result中的元素
    
    //一个数字的来源：左边和上边的最大值或者是对角线加1
    for(i = m, j = n; (i != 0) && (j != 0);)
    {
        if(d[i][j] == d[i - 1][j])
            i--;
        else if(d[i][j] == d[i][j - 1])
            j--;
        else 
        {
            result[--count] = a[i - 1];
            i--;
            j--;
        }
    }
    free(d[0]);
    free(d)
}
  
2.最长公共子序列递归法
#include<string.h>
char a[30],b[30];
int lena,lenb;
int LCS(int,int);　　///两个参数分别表示数组a的下标和数组b的下标

int main()
{
    strcpy(a,"ABCBDAB");
    strcpy(b,"BDCABA");
    lena=strlen(a);
    lenb=strlen(b);
    printf("%d\n",LCS(0,0)); //这个0，0就相当于两个指针
    return 0;
}

int LCS(int i,int j)
{
    if(i>=lena || j>=lenb)
        return 0;
    if(a[i]==b[j])    //如果说这两个指针所指向的数字相同，两个指针都移动
        return 1+LCS(i+1,j+1);
    else
        return LCS(i+1,j)>LCS(i,j+1)? LCS(i+1,j):LCS(i,j+1);     //如果两个指针所指向的数字不相同，去后面分别找和前面一个相同的
}
======================================================================================================================================================
*最长公共子串
1.有人输入了hish，那他原本要输入的是fish还是vista呢
      h  i  s  h
    f 0  0  0  0
	i 0  1  0  0
	s 0  0  2  0
	h 1  0  0  3
	*如果两个字母不相同，值为0
	*如果两个字母相同，值为左上角邻居的值加1
	*最大值有可能不在最后的单元格中
	我懂了，如果比较的两个字母根本就不相等，就没有出现最长公共子串的可能
	如果两个字母相等，先要看看这两个数字的上两个字母是否相等，如果相等，就是左上角的数字加1
	如果不相等，那它就是第一个相等的，为1

*最长公共子序列
 如果有人不小心输入了fosh，他原本想输入的是fish还是fort呢
 如果使用最长公共子串  两个都是2，但是fosh与fish更像
     f   o   s   h
   f 1   1   1   1
   i 1   1   1   1
   s 1   1   2   2
   h 1   1   2   3
   
   *如果两个字母不同，就选择上方和左方邻居中较大的那个
   *如果两个字母相同，就将当前单元格的值设置为左上方单元格加1.
	
======================================================================================================================================================
*K最近邻算法
1.你需要对一个水果进行分类   你查看它三个最近的邻居   在这些邻居中，橙子多于柚子，所以它可能是橙子
2.特征抽取
  把物品的特征程度用数字表示出来，绘制特征图（把特征都转化为坐标）
  度量它们有多像，计算两点间距离根号（x1 - x2）² + （y1 - y2）²
  
  如何解决两个相似的人，但是其中一位更严格的问题
  可以使用归一化，可以计算每位用户的平均评分，并据此来调整用户的评分，稍微调高评分低的那位的分数
  
*回归
1.假设你不仅要向priyanka推荐电影，还要预测她将给这部电影打多少分，先选出与她最邻近的5个人，再求平均值，这就是回归
   ***********
   余弦相似度：余弦相似度不仅计算两个矢量的距离，还比较他们的角度
   ***********
   
======================================================================================================================================================
*机器学习简介
OCR指的是光学字符识别
如何自动识别出一个数字是什么呢，可以使用KNN
1）浏览大量的数字图像，将这些数字的特征提取出来，
2）遇到新图像时，你提取该图像的特征（这被称为训练，大多数机器学习算法都包含训练的步骤，要让计算机完成任务，必须先训练他），再找出它最邻近的邻居都是谁
3）OCR算法是提取线段、点和曲线等特征

创建垃圾邮件过滤器
1）朴素贝叶斯分类器
2）比较垃圾主题和邮件中单词的相似度有多少
   
======================================================================================================================================================
**逻辑结构
      线性
			数组
			链表
	        栈和队列是一种特殊的线性结构
	  非线性
	        树   图
========================================
非线性结构
========================================
树
    树定义
	            专业定义：
					1.有且只有一个称为根的节点
					2.有若干个互不相交的子树，这些子树本身也是一棵树
	            通俗的定义：
					1.树是由节点和边组成
					2.每个节点只有一个父节点但可以有多个子节点
					3.但有一个节点除外，该节点没有父节点，此节点称为根节点
				专业术语：
					1.节点、父节点、子节点、子孙、堂兄弟
					2.深度：从根节点到最底层节点的层数称为深度、根节点是第一层
					3.叶子节点：没有子节点的节点
					4.非终端节点：实际就是非叶子节点
					5.度：子节点的个数称为度
	树分类 
				一般数  //任意一个节点的子节点的个数都不受限制
				
				二叉树  //任意一个节点的子节点个数最多两个，且子节点的位置不可更改
					///分类
					1.一般二叉树
					2.满二叉树
						在不增加数的层数的前提下，无法再多添加
						一个节点的二叉树就是满二叉树
					3.完全二叉树
						如果只是删除了满二叉树最底层最右边的连续若干个连续点，这样形成的二叉树就是完全二叉树
					
				森林    //n个互不相交的数的集合

	树的储存
				二叉树的储存
					连续储存[完全二叉树]   //得把所有二叉树的空位全补齐，最后一行从最右边开始一直到子节点的所有节点都可以没有
										   //如果只知道一个二叉树（先中后顺序）是无法推出整个二叉树的，所以要补齐
						1.优点：查找某个节点的父节点和子节点（也包括有没有子节点）速度很快
						2.缺点：耗用内存空间过大
					一般数的储存  
						1.双亲表示法 //例如：A(BC(E)D)
							0 A -1
							1 B 0
							2 D 0
							3 E 4
							4 C 0
						2.孩子表示法  //例如：A(B(EF)CD(G))
							A->B->C->D
							B->E->F
							C  ^
							D->G
							E  ^
							F  ^
							G  ^
						3.双亲孩子表示法  //例如：A(B(C(DEF)))
							0 E 4 ^
							1 F 4 ^
							2 B 5->C
							3 D 4 ^
							4 C 2->D->E->F
							5 A -1->B
							
						4.二叉树表示法
							把一个普通数转化为二叉树来储存
							
							具体的转换方法：
								设法保证任意一个节点的
									左指针域指向它的第一个孩子
									右指针域指向它的堂兄弟
								只要能满足此条件，就可以把一个普通数转化为二叉树
								
								//加线——在所有兄弟节点之间加一条连线
								//去线——对树中每个节点，只保留它与第一孩子节点的连线，删除它与其他孩子节点的连线
								//层次调整，以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明
							例如：						1
											2		        3		4		5
									6	    7      8
									            9  10 11
												
												
												        1
											2
								6					                3
								    7									4
								              8								5
									  9
									    10
										   11
							
							树的遍历分为两种形式，一种是先根遍历，另一种是后根遍历
							先根遍历：先访问树的根节点，然后再依次先根遍历根的每棵子树
									    
				森林的储存:先把森林转化为二叉树，再储存二叉树
				二叉树到树，森林的转化，钝角三角形，钝角在右边，连起钝角所对的边，去掉钝角三角形中最底下的那条边
				森林的遍历也分为前序遍历和后序遍历，其实就是按照树的先根遍历和后根遍历依次访问森林的每一棵树
				/*
						我们惊人发现：树、森林的前根遍历和二叉树的前序遍历结果相同，树、森林的耳后根遍历和二叉树
						的中序遍历结果相同
				*/
				
				/**
						判断一棵二叉树能够转化成一棵二叉树还是森林，标准很简单，那就是只要看这颗二叉树的根节点
						有没有右孩子，有的话就是森林，没有的话就是一棵树
				
				**/
	
	二叉树操作
		遍历
			//先序遍历
				先访问根节点
				再先序访问左子树
				再先序访问右子树
							A
				B						Q
			C 						M
			   D					    N
				  E					  S
				 F L
			先：ABCDEFLQMNS
			
			
			//中序遍历(投影法)
			    中序遍历左子树
				再访问根节点
				再中序遍历右子树
						  A
				   B            F
					  C       L    M
					 D E         N
								  Q
			中：BDCEALFNQM
				
			//后序遍历
				先中序遍历左子树
				再中序遍历右子树
				再访问根节点
						A
				B               C
							D        E
							        F L
								   M
									
				BDMFLECA
				
		  已知两种遍历序列求原始二叉树
				通过先序和中序  或者  中序和后续   可以还原出原始的二叉树
				但是通过先序和后序是无法还原出原始的二叉树的
			    
				换种说法：
					只有通过先序和中序，或者通过中序和后序
					我们才可以唯一确定一个二叉数
		        例如：中序BDCEAFHG
					  后序DECBHGFA
					  前序
					  /*
						步骤：1.根据前后序确定节点的先后顺序（先序从前往后看   后序从后往前看）  这个里第一个节点是A
							  2.分割BDCE  A  FHG
							  3.找第二个节点F，看中序FHG
							    抛去后序里的HGF，所以B又是一个节点，看中序，B没有左节点，看后序，B有右节点c，DCE，把C上移，DE分别是左右节点
					  
					  */
					          A
					   B           F
					      C            G
						D   E        H
				
	应用
	    树是数据库中数据组织一种重要形式
		操作系统的字符进程的关系本身就是一棵树
		面向对象语言中的类的继承关系   人分为男人和女人     男人分为啥啥啥

2.完全二叉树的高度为：log(2,N)，简写为logN，完全二叉树就是允许右边有空着的

    //链式二叉树
/*
            A
        B       C
              D
               E

*/
==========================================================================================================================================
3.
二叉树系列问题解答

二叉树套路

节点为空 if(root == NULL) or if(!root)

（有左右指针型）
左边小于右边
左边等于右边


1.
left  = 递归函数
right = 递归函数

root 和 left right的关系

return root;




3.每个结点处理法
我也可以把它叫做递归前后关联法 通过类似于return可以把sum关联起来

左右递归非裸露函数
假如只有这一个结点，应该对这个节点进行什么操作
在函数里面
{
	int sum = 0;
	
	sum进行一些操作
	
	return sum + 函数(root->left) + 函数(root->right);
}

————————————————————————————————————————————————————————————————————————————————
我大致说一下这道题的思路：因为函数是对每个root结点的处理
结点满足下面这个条件肯定就可以输出了
但是要删除一个结点得依靠上一个结点
root->left == NULL && root->right == NULL && root->val == target

所以删除过程得和上一个结点相关，上面这条语句只能作为一部分

int dfs(struct TreeNode* root,int target)
{
    if(root->left != NULL && dfs(root->left, target)) 
		root->left = NULL;
		
    if(root->right != NULL && dfs(root->right,target)) 
		root->right = NULL;
		
    if(root->left == NULL && root->right == NULL && root->val == target) 
		return 1;
		
    return 0;
}


===============================================================================
———————————————————————————————————————————————————————————————————————————————
左右递归裸露函数

如果没有前面上下关联的操作，还要算出sum，就得设置全局变量(全局变量法)


就是上面的前序遍历 中序遍历 后序遍历 层序遍历，也叫dfs深度遍历
前序遍历是线性  后序遍历是回溯  中序遍历是排序二叉树的应用

                       1
                     /   \
                    2     5
                  /  \  /  \
                3    6 4    9
                           / \
                          10 12

            中间竖杠的目的是把它分为左子树和右子树
            前序遍历：1 2 3 6 5  4  9  10 12      
            后序遍历：3 6 2 4 10 12 9  5  1			
			中序遍历：3 2 6 1 4  5  10 9 12
			
我又有了一点体会：
当root->left的时候  就是一直寻找它的左结点 如果到达一条线的末端，返回的时候，就是返回他的父结点
                    返回它父结点的时候，这个节点对于它来说就是右儿子
root->right同理

    ss(root->right);

    if(root->right && root->right->val == 0 && !root->right->left && !root->right->right)
        root->right=NULL;

    ss(root->left);

    if(root->left && root->left->val == 0 && !root->left->left && !root->left->right)
        root->left=NULL;

————————————————————————————————————————————————————————————————————————————————————————
暂时我觉着根据结点处理的位置来判断  记住前序中序后序遍历的结点顺序就OK


这里需要进行一个判断，有时候需要
root->left != NULL    root->rigth != NULL
左递归函数  
右递归函数

l = getDeep(root->left);
r = getDeep(root->right);

这个虽然是非裸露函数，但是如果写在这两个函数前面的就是前序遍历
写在这两个函数后面的就是回溯，如果需要比较的是深度  记得得加1，因为是返回给上边的


————————————————————————————————————————————————————————————————————————————————————————
广度优先遍历 
int sumEvenGrandparent(TreeNode* root) 
	{
        //建立一个队列 
		queue<TreeNode*> q;
		
		//压栈，把()里的压入栈中
        q.push(root);
        int ans = 0;
		
		//如果这个栈是空
        while (!q.empty()) 
		{
            //栈的第一个元素
			TreeNode* node = q.front();
			//弹出栈顶元素
            q.pop();
			
			//对栈的第一个元素进行操作
            if (node->val % 2 == 0) 
			{
                if (node->left) 
				{
                    if (node->left->left) 
					{
                        ans += node->left->left->val;
                    }
                    if (node->left->right) 
					{
                        ans += node->left->right->val;
                    }
                }
				
                if (node->right) 
				{
                    if (node->right->left) 
					{
                        ans += node->right->left->val;
                    }
                    if (node->right->right) 
					{
                        ans += node->right->right->val;
                    }
                }
            }
			
			//左右入栈，先左后右，还是先右后左有时候都可以，有时候要看具体情况
            if (node->left) 
			{
                q.push(node->left);
            }
            if (node->right) 
			{
                q.push(node->right);
            }
        }
        return ans;
    }

===================================================================================
函数变量   就是写在函数头中的变量

================================================================================
左右递归裸露函数和左右递归非裸露函数的区别
非裸露函数  相当于只完成一件事，不用考虑回溯对值改变所产生的影响等问题
            看下面这个
			第一步：要把所要求的值设为0    sum = 0
			第二步：这个值如何 和 左右递归建立关系 求出来
			第三步：返回这个值
			
			与此同时，左右递归需要终止条件，且需要返回值
           


左右递归非裸露函数
整体观
int _sumRootToLeaf(struct TreeNode *root, int num) 
{
    int sum = 0; 
    
    num = (num << 1) + root->val;  
	
    if (root->left == NULL && root->right == NULL)
        return num; 
    if (root->left) 
        sum += _sumRootToLeaf(root->left, num);
    if (root->right) 
        sum += _sumRootToLeaf(root->right, num);
    return sum; 
}

int sumRootToLeaf(struct TreeNode *root) 
{   
    //这个的意思就是判断根节点是否存在，存在输出算出的结果，不存在输出0
    return root ? _sumRootToLeaf(root, 0) : 0;
}


————————————————————————————————————————————————————————————————————————————————
搞清非裸露函数此行的目的
非裸露函数建立的是左右孩子和父结点之间的关系，所以左右孩子返回值的含义应该和父结点return到上一个结点的含义相同

看以下这个函数，它的目的就是找出到达这个结点为止走过的路程数
因为一个点必须找到才能回溯出它的路程数
又因为 咱们看的时候一条一条的线来看的，所以这时候就分为如果这条线找到了和如果这条线没找到
如果这条线找到了，回溯ret + 1  ，如果这条线没找到，回溯-1，
所以如果ret < 0 就表明没有找到，是否递归在这里就停止了，答案是否定的，因为只要一出现left right
就是全部结点的递归过程

int find_depth_x(struct TreeNode* f_node, struct TreeNode* root, int node_val)
{
    /*
		记住，寻找和回溯的过程可以看成是线性的，何为线性的
		就是一条路走到黑，可以把这个二叉树分为多个这样的一条路，那么，如果说这条路没有找到
		就返回-1表示，如果ret = -1就表明不符合题意，只要一出现大于0的情况，就说明需要开始回溯了	
	*/
	
	if (root == NULL)  
		return -1;   //为什么不是0，0表示深度是0，而-1表示这个深度根本不存在
    if (root->val == node_val) 
	{
        x_f = f_node;
        return 0;
    }
    int ret;
	//找到这个点，只有一条路
    if ((ret = find_depth_x(root, root->left,  node_val)) >= 0) return ret+1;   //这个返回值是左右孩子返回给父节点的东西
    if ((ret = find_depth_x(root, root->right, node_val)) >= 0) return ret+1;
           
    return -1;
}
__________________________________________________________________________________________________________________int num;
左右递归裸露函数
局部观

int num;
void _sumRootToLeaf(struct TreeNode *root, int sum)
{
    if(root == NULL)
        return;

    sum = (sum << 1) + root->val;
	
    //得先对sum做如上操作，才是属于这个函数的sum
    if(root->left == NULL && root->right == NULL)
        num += sum;

    _sumRootToLeaf(root->left, sum);
    _sumRootToLeaf(root->right, sum);

}


int sumRootToLeaf(struct TreeNode *root)
{
    int sum = 0;
    num = 0;
    _sumRootToLeaf(root, sum);
    return num;
}


=====================================================================================
return 法
适用于判断型真假

前序遍历 写一些判断条件和为空时候的情况
return  root->val  == ... && root->left && root->right

======================================================================================
有多少种可能 排列组合
=======================================================================================
如果可能的结果是从根节点到空结点这段路程上的某一部分

int pathSum(struct TreeNode* root, int sum)
{
    if(root == NULL)
        return 0;
    Sum(root,sum);
    pathSum(root->left, sum);  记住测试的时候不仅要测试root还要有左右孩子
    pathSum(root->right, sum);
    return pathnumber;
}

void Sum(struct TreeNode* root, int sum)
{
    //注意：这个是有负数的
    if(root == NULL) 
        return;

    sum -= root->val;
    if(sum == 0)
        pathnumber++;           
    
    Sum(root->left,sum);
    Sum(root->right,sum);

==========================================================================================================================================
#include <string.h>
#include <stdbool.h>
#include <malloc.h>

typedef struct TreeNode
{
    char Element;
    struct TreeNode *left;
    struct TreeNode *right;
}TREE, *PTREE;

void CreatTree(PTREE *);    //    树的先序创建函数
void PreOrderTree(PTREE );    //    树的前序遍历函数
void InOrderTree(PTREE );    //    树的中序遍历
void PostOrderTree(PTREE );    //    树的后序遍历
void LeafOfTree(PTREE );    //    打印树的叶子节点函数
int  Get_Leaf_Num(PTREE );    //    获取树叶子节点个数
int Get_Height(PTREE );    //    获取树的高度


int main()
{
    PTREE Root;

    printf("请先序输入二叉树的节点数据： ");
	/*
		我来解释一下为什么建立二叉树的时候传的是指针
		首先Root里面保存的是一个0x01929的地址，是一个野指针，这个指针指向的数据的类型是TREE
		之后，如果我们要给这个野指针在函数中分配一个地址，就是要改变这个地址，所以传入的是&Root
		目的就是为了可以改变这个地址的值
	
	
	*/
    CreatTree(&Root);
    printf("\n前序遍历结果为：");
    PreOrderTree(Root);
    printf("\n中序遍历结果为：");
    InOrderTree(Root);
    printf("\n后序遍历结果为：");
    PostOrderTree(Root);
    printf("\n打印叶子节点为：");
    LeafOfTree(Root);
    printf("\n叶子节点个数为：%d", Get_Leaf_Num(Root));
    printf("\n二叉树的高度为：%d", Get_Height(Root));
    printf("\n");

    return 0;
}

//只是对这个节点的操作，不是对节点和它的儿子操作
/**
    这个是跟前序遍历一样：
              A
        B           C
     D           E      F
                      G
    如果输入的话：ABD***CE**FG***
    ***表示D没两个儿子，B没一个儿子

**/
void CreatTree(PTREE *Root)  //输入的是根节点的地址
{
    char val = 0;
    val = getchar();

    if(val == '*')
        (*Root) = NULL;
    else
    {
        (*Root) = (PTREE)malloc(sizeof(TREE));
        if((*Root) == NULL)
        {
            printf("创建节点失败！");
            exit(-1);
        }
        else
        {
            (*Root)->Element = val;
            CreatTree(&(*Root)->left);
            CreatTree(&(*Root)->right);
        }
    }
}

//树的前序遍历
void PreOrderTree(PTREE Root)
{
    if(Root == NULL)
        return;
    else
    {
        putchar(Root->Element);
        PreOrderTree(Root->left);
        PreOrderTree(Root->right);
    }
}

//    树的中序遍历函数定义
void InOrderTree(PTREE Root) {

    if (Root == NULL)
        return;
    else {
        InOrderTree(Root->left);
        putchar(Root->Element);
        InOrderTree(Root->right);

    }
}

//    树的后序遍历函数定义
void PostOrderTree(PTREE Root) {

    if (Root==NULL)
        return ;
    else{
        PostOrderTree(Root->left);
        PostOrderTree(Root->right);
        putchar( Root->Element);
    }
}

//打印树的叶子节点
void LeafOfTree(PTREE Tree)
{
    if(Tree == NULL)
        return;
    else
    {
        if(Tree->left == NULL && Tree->right == NULL)
            putchar(Tree->Element);
        else
        {
            LeafOfTree(Tree->left);
            LeafOfTree(Tree->right);
        }
    }
}

//    获取树的叶子节点个数函数定义
int Get_Leaf_Num(PTREE Tree)
{
    if (Tree == NULL)
        return 0;
    if (Tree->left == NULL && Tree->right == NULL)
        return 1;

    //递归整个树的叶子节点个数 = 左子树叶子节点的个数 + 右子树叶子节点的个数
    return Get_Leaf_Num(Tree->left) + Get_Leaf_Num(Tree->right);
}

//    获取树高的函数定义
int Get_Height(PTREE Tree)
{
    int Height = 0;
    if (Tree == NULL)
        return 0;

    //树的高度 = max(左子树的高度，右子树的高度) + 1
    else
    {
        int L_Height = Get_Height(Tree->left);
        int R_Height = Get_Height(Tree->right);
        Height = L_Height >= R_Height ? L_Height + 1 : R_Height + 1;
    }
    return Height;
}

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
==========
线索二叉树
==========
1.线索二叉树充分利用了指针的空间，同时又便于寻找节点的前驱节点和后继节点。线索二叉树适用于经常需要遍历寻找节点前驱或后继节点的
二叉树


typedef char ElemType;

//线索储存标志位
//Link(0):表示指向左右孩子的指针  link以后就是代表1
//Thread(1):表示指向前驱后继的线索
typedef enum {Link, Thread} PointerTag;

typedef struct BiThrNode
{
    char data;
    struct BiThrNode *lchild, *rchild;
    PointerTag ltag;
    PointerTag rtag;
}BiThrNode, *BiThrTree;

//全部变量，始终指向刚刚访问过的节点
BiThrTree pre;

//创建一颗二叉树，约定用户遵照前序遍历的方式输入数据
void CreateBiThrTree(BiThrTree *T)
{
    char c;
    scanf("%c", &c);
    if(' ' == c)
        *T = NULL;
    else
    {
        *T = (BiThrTree *)malloc(sizeof(BiThrNode));
        (*T)->data = c;

        //先假设这个节点有左右孩子
        (*T)->ltag = Link;
        (*T)->rtag = Link;

        CreateBiThrTree(&(*T)->lchild);
        CreateBiThrTree(&(*T)->rchild);
    }

}

//中序遍历线索化
void InThreading(BiThrTree T)
{
    if(T)
	/**
		   假设一棵树长这样：
		              A
					/   \
				   B     C
				  / \   / \
				 D   E F   G
				/ \ / 
			   H  I J
		   中序遍历的结果为： H  D  I  B  J  E  A  F  C  G
		   意思就是，在中间那块进入的节点顺序就是上面的排列顺序
		   而需要改动的只有H I J E（右） F G
		   所以进去一个节点，首先要判断这个节点有没有左孩子和右孩子
		   假如T 是 D，则pre就是H
		   I的后续是B，可是此时，还没有轮到B，所以只有在到达B，才能判断pre(I)有没有后续，如果没有，设成B
		   
		   我来尝试理解一下这个大型递归过程：
		   InThreading(T->lchild);  目的就是不断找出它的左孩子，直到它没有左孩子
		   中间这个点的目的就是输出这个左孩子；
		   InThreading(T->rchild);  目的就是在这个点没有左孩子的前提下，找出这个点的右孩子，然后重复不断找出
			                        这个点的左孩子
		   它既没有左孩子也没有右孩子，就返回上一个中间输出的步骤
    **/
    {
        InThreading(T->lchild);//递归左孩子线索化，找到最左孩子的根部
        
		————————————————————————————————————————————————————————————————————————————————————————
        if( !T->lchild) //如果该节点没有左孩子，设置Itag为Thread，并把lchild指向刚刚访问的节点。
        {
            T->ltag = Thread;
            T->lchild = pre;  //pre是这个T节点的父亲
        }
        
        if(!pre->rchild)    //如果这个节点没有右孩子
        {
            pre->rtag = Thread;
            pre->rchild = T;
        }
        
        pre = T;
        ——————————————————————————————————————————————————————————————————————————————————————————    
        InThreading(T->rchild); //递归右孩子线索化
        
    }
}

void InOrderThreading(BiThrNode *p, BiThrTree T)
{
    
	 //H  D  I  B  J  E  (A)  F  C  G
	 /**
			这个*p的目的就是：如果A先遍历右子树，最后到达H，H指向*p，*p又指向A，所以还可以遍历左子树
			遍历完左子树到达G，G指向*p，*p又可以指向G，可以从后头遍历
			
	 **/
	*p = (BiThrTree)malloc(sizeof(BiThrNode));
    (*p)->ltag = Link;    //表示他左边有儿子
    (*p)->rtag = Thread;  //表示他右边是连线
    (*p)->rchild = *p;   //既然右边是连线，刚开始不知道它指向谁，就指向它自己
    if(!T)   //如果T是空的，意思就是它要改变的那棵树什么都没有
        (*p)->lchild = *p;   //把它的左孩子设为它本身
        
    else 
    {
        (*p)->lchild = T;  //p的右孩子指向T，T是根节点
        pre = *p;  //pre是独立于树的一个控制台
        InThreading(T);  //线索化这棵树
        pre->rchild = *p;  //此时pre就是中序遍历的最后一个
        pre->rtag = Thread;
        (*p)->rchild = pre;
    }
}

void visit( char c )
{
	printf("%c", c);
}

//中序遍历二叉树，非递归
void InOrderTraverse(BiThrTree T) //T是刚才输进来的P
{
    BiThrTree p;
    p = T->lchild; //先找到根节点
    
    while(p != T)  //p绕一圈又会绕回T
    {
        while(p->ltag == Link)   //先一直往左找，找到最根部，
        {
            p = p->lchild;
        }
        
        visit(p->data);
        
        while(p->rtag == Thread && p->rchild != T)
        {
            p = p->rchild;
            visit(p->data);
        }
        
        p = p->rchild;
    }
}


int main()
{
    BiThrTree P, T = NULL;

    CreateBiThrTree(&T);
    
    //T代表的是建立好的一棵树
    InOrderThreading(&P, T);
    
    printf("中序遍历的输出结果为：");
    InOrderTraverse(P);
    printf("\n");
    
    return 0;
}
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
赫夫曼树
就是找出一个数组里两个最小的数，把这两个数加起来，形成这两个节点的父节点
1.数据压缩，就是生成一棵最小树，就是节点所带权值和它所在的层数的乘积所有的加起来最小
2.节点的路径长度：从根节点到该节点的路径上的连接数
3.树的路径长度：树中的每个【叶子节点】的路径长度之和
4.节点带权路径长度：节点的路径长度与节点权值的乘积
5.树的带权路径长度（WPL）：树中所有叶子节点带权路径长度之和
WPL越小，说明构造出来的二叉树性能越优
typedef int ElemType;
struct BTreeNode
{
    ElemType data;
    struct BTreeNode* left;
    struct BTreeNode* right;
};

//输出二叉树，可在前序遍历的基础上修改。采用广义表格式，元素类型为int

void PrintBTree_int(struct BTreeNode* BT)//输出来的BT就是根节点了OK，而且这个树肯定是二叉树OK
{
    if(BT != NULL)
    {
        //在树里面的递归其实特别简单
        //首先我要把BT里面所包含的值输出来，接着我想把这个节点的儿子输出来，所以要判断是否为空

        /**
            深刻理解递归：
            递归之前的作用是你从上往下遍历的时候需要完成的
                    递归之前需要把节点值输出来，如果有儿子，还需要输出括号，输出左儿子
            递归之后需要把这个节点的右儿子输出来，还需要输出左括号
            当输完左括号时就意味着，这个节点的任务已经完成，返回上一个节点
        **/
        printf("%d", BT->data);  //输出根节点的值
        if(BT->left != NULL || BT->right != NULL)
        {
            printf("(");
            PrintBTree_int(BT->left);  //输出左子树

            if(BT->right != NULL)
                printf(",");
            PrintBTree_int(BT->right);  //输出右子树
            printf(")");
        }

    }
}

//根据数组a中n个权值建立一棵哈夫曼树，返回树根指针
struct BTreeNode* CreateHuffman(ElemType a[], int n)   //a[]是包含n个点权值的数组int类型
{
    int i, j;
    //因为a是一个数组，是树里包含的节点值，得有树他才有意义
    //
    struct BTreeNode **b, *q;
    /**
        b[]是一个指针，指向每一行，所以给b[]分配的就是行数*sizeof
        b[][]是指向每一个元素，又b[1] = 。。。；b[2] = 。。。
    **/
    b = (struct BTreeNode **)malloc(n * sizeof(struct BTreeNode)); //分配n行结构
    for(i = 0; i < n; i++)  //初始化b指针数组，使每个指针元素指向a数组中对应的元素节点
    {
        b[i] = (struct BTreeNode *)malloc(sizeof(struct BTreeNode));  //每行分配一个结构
        b[i]->data = a[i];  //把每行结构数据里面存上a数组里的值
        b[i]->left = b[i]->right = NULL;   //设置每行结构的左右孩子
    }

    for(i = 1; i < n; i++)  //进行n - 1次循环建立哈夫曼树，每一次的目的就是合并俩个节点，总共要合并n - 1
    {
        //k1表示森林中具有最小权值的数根节点的下标，k2为次最小的下标
        int k1 = -1, k2;
        for(j = 0; j < n; j++)  //让k1初始指向森林中的第一棵树，k2指向第二棵
        {
            //为什么不使k1 = 0  k2 = 1 ，因为不知道k1,k2的指向是否为空

            if(b[j] != NULL && k1 == -1)
            {
                k1 = j;
                continue;
            }

            if(b[j] != NULL)
            {
                k2 = j;
                break;
            }
        }

        for(j = k2; j < n; j++) //从当前森林中求出最小权值树和次最小
        {
            if(b[j] != NULL)
            {
                if(b[j]->data < b[k1]->data)
                {
                    k2 = k1;
                    k1 = j;
                }

                else if(b[j]->data < b[k2]->data)
                {
                    k2 = j;
                }
            }
        }
        //由最小权值树和次小权值树建立一颗新树，q指向树根节点
        q = malloc(sizeof(struct BTreeNode));
        q->data = b[k1]->data + b[k2]->data;
        q->left = b[k1];
        q->right = b[k2];

        b[k1] = q;    //将指向新树的指针赋给b指针数组中k1位置，说明现在k1的位置上就是q带着她的孩子
        b[k2] = NULL; //k2位置为空

    }

    free(b);
    return q;
}

//求哈夫曼树的带权路径长度，就是每个节点乘他在二叉树的行数，从0开始，是总长度
ElemType WeightPathLength(struct BTreeNode* FBT, int len)  //len初始化为0
{
    if(FBT == NULL) //空树返回0
        return 0;
    else
    {
        //注意：这个哈夫曼树只有一个节点既没有左儿子又没有右儿子，他才是实际存在的，别的就是他们之间互相加起来
        if(FBT->left == NULL && FBT->right == NULL)   //访问到叶子节点
            return FBT->data * len;    //len是它的深度
        else //访问到非叶子节点，进行递归调用，返回左右子树的带权路径长度之和，len递增
            return WeightPathLength(FBT->left, len + 1) + WeightPathLength(FBT->right, len + 1);
    }
}


//哈夫曼编码（可以根据哈夫曼树带权路径长度的算法基础上进行修改）
//就是那个往左是1，往右是0的那个
void HuffManCoding(struct BTreeNode * FBT, int len) //len初始化为0
{
    static int a[10]; //定义静态数组a，保存每个叶子的编码，数组长度至少使树的深度减一
    if(FBT != NULL) //访问到叶子节点时输出其保存在数组a中的0和1序列编码
    {
        if(FBT->left == NULL && FBT->right == NULL)
        {
            int i;
            printf("节点权值为%d的编码：", FBT->data);
            for(i = 0;  i < len; i++)
                printf("%d", a[i]);
            printf("\n");
        }

        else  //访问到非叶子节点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a
        {
            //向下深入一层时len值增1
            //a[len]的值是条件，就是在这个前提下的意思
            a[len] = 0;
            HuffManCoding(FBT->left, len + 1);
            a[len] = 1;
            HuffManCoding(FBT->right, len + 1);
        }
    }
}

void main()
{
    int n, i;
    ElemType* a;    //ElemType是int类型
    struct BTreeNode* fbt;
    printf("从键盘输入待构造的哈夫曼树中带权叶子节点数n:");
    while(1)
    {
        scanf("%d", &n);
        if(n > 1)
            break;
        else
            printf("重输n值：");
    }

    a = malloc(n * sizeof(ElemType));

    printf("从键盘输入%d个正数作为权值：", n);
    for(i = 0; i < n; i++)
        scanf("%d", &a[i]);
    fbt = CreateHuffman(a, n);
    printf("广义表形式的哈夫曼树：");
    PrintBTree_int(fbt);
    printf("\n");
    printf("哈夫曼树的带权路径长度：");
    printf("%d\n", WeightPathLength(fbt, 0));
    printf("树中每个叶子节点的哈夫曼编码:\n");
    HuffManCoding(fbt, 0);
}
——————————————————————————————————————————————————————————————————————————————————————————————————————————————
普里姆算法（找出经过所有节点带权值的最小生成树）
#define OK 1
#define ERROR 0
#define Max_Int 32767
#define MVNum 100
/**
    ①找到一个节点1的相邻节点中权值最小的2
    ②找出2号顶点所对的节点权值，如果比之前小，更新
    ③如果两个相同，随便选一个



**/

struct{
    	char adjvex;  //这个是总节点
        int lowcost;  //最小权值
}closedge[MVNum];     //这个是这个总节点所对应的节点

typedef struct{
        char vex[MVNum];        //各个节点的值
        int arc[MVNum][MVNum];  //两个节点之间的距离
        int vexnum, arcnum;     //vexnum总节点数   arcnum总边数
}AMGraph;

int LocateVex(AMGraph *G,char v)     //用来检查这个节点是否存在，是根据下标找节点
{
    int i;
    for (i = 0; i < G->vexnum; i++)  
    {
        if (G->vex[i] == v)
            return i;
    }
    return -1;
}

int CreateUDN(AMGraph *G)   //创建这个表，必须得输入地址
{
    int i, j, k;
    char v1, v2;
    int w;
    printf("输入总节点数和总边数：");
        scanf("%d %d", &G->vexnum, &G->arcnum);
    fflush(stdin);    //清空缓冲区
    printf("输入各个节点的值：");   
    for (i = 0; i < G->vexnum; i++)
        scanf("%c", &G->vex[i]);    //i是下标，vex是这个节点的值
        
    for (i = 0; i < G->vexnum; i++)  //初始化各个节点所对应边的值为最大值
    {
        for (j = 0; j < G->vexnum; j++)
        {
            G->arc[i][j] = Max_Int;
        }
    }
    for (k = 0; k < G->arcnum; k++)  //输入各个节点所对应边的值
    {
        fflush(stdin);
        printf("输入一条边的两个顶点以及该边的权值：");
        scanf("%c %c %d", &v1, &v2, &w);
        i = LocateVex(G, v1);   //LocateVex是找到这个值所对应的下标，也就是位置
        j = LocateVex(G, v2);
        G->arc[i][j] = w;    //输入这条边的值
        G->arc[j][i] = G->arc[i][j];   //反的也得设上
    }
    return OK;
}

int Min(AMGraph G)   //找出跟closedge中所对应最小的边
{
    int i;
    int min = Max_Int;
    int index = -1;
    for (i = 0; i < G.vexnum; i++)
    {
        if (min > closedge[i].lowcost && closedge[i].lowcost!=0)   //等于0有两种情况，一种是本节点，另一种是已经用过的节点
        {
            min = closedge[i].lowcost;
            index = i;
        }
    }
    return index;
}


void MinSpanTree_Prim(AMGraph G, char v)   //v是输入的第一个顶点
{
    int i, j, k;
    char u0, v0;
    k = LocateVex(&G, v);   //检查G中这个顶点v是否存在
    
    //初始化closedge表
    for (j = 0; j < G.vexnum; j++)
    {
        if (j != k)
        {
            closedge[j].adjvex  = v;   //把他们所对应的总节点都设为v
            closedge[j].lowcost = G.arc[k][j];   //初始化边
			//注意这里G.arc[k][j]和G.arc[j][k]是相同的
        }
    }
    closedge[k].lowcost = 0;   //最后初始化它自己所对应的边
    
    for (i = 1; i < G.vexnum; i++)   //控制循环的次数为G.vexnum - 1次
    {
        k = Min(G);               //找到所对应的最小的边所对应的下标
        u0 = G.vex[k];            //找到所对应的节点的值 char
        v0 = closedge[k].adjvex;  //找到总节点
        printf("%c->%c\n", v0, u0);
        
        closedge[k].lowcost = 0;  //已经完成输出，设为0
        
        for (j = 0; j < G.vexnum; j++)             //遍历k所对应的节点
        {
            if (closedge[j].lowcost > G.arc[k][j])   
            {
                closedge[j].adjvex = G.vex[k];     //更新总节点
                closedge[j].lowcost = G.arc[k][j]; //更新对应边的值
            }
        }
    }
}

int main(void)

{

	AMGraph G;

	CreateUDN(&G);

	MinSpanTree_Prim(G, '1');

	printf("\n");

	return 0;

}
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
**************
克鲁斯卡尔算法
**************
//克鲁斯卡尔算法
//在连通网中求出最小生成树
//https://www.cnblogs.com/qianbixin/p/5005161.html

#include <stdio.h>
#include <stdlib.h>

#define MAXEDGE  20
#define MAXVEX   20
#define INFINITY 65535

typedef struct
{
    int arc[MAXVEX][MAXVEX];
    int numVertexes, numEdges;//顶点数，边数
}MGraph;

typedef struct
{
    int begin;
    int end;
    int weight;
}Edge;   //对边集数组Edge结构的定义

//创建图的邻接矩阵
void CreateMGraph(MGraph *G)
{
    int i, j;

    G->numEdges=11;
    G->numVertexes=7;

    //初始化这个边图
	for (i = 0; i < G->numVertexes; i++) 
	{
        for ( j = 0; j < G->numVertexes; j++) 
		{
            if (i==j)
                G->arc[i][j]=0;
            else
                G->arc[i][j] = G->arc[j][i] = INFINITY;
        }
    }
    G->arc[0][1]=7;
    G->arc[0][3]=5;
    G->arc[1][2]=8;
    G->arc[1][3]=9;
    G->arc[1][4]=7;
    G->arc[2][4]=5;
    G->arc[3][4]=15;
    G->arc[3][5]=6;
    G->arc[4][5]=8;
    G->arc[4][6]=9;
    G->arc[5][6]=11;

    for(i = 0; i < G->numVertexes; i++) 
    {
        for(j = i; j < G->numVertexes; j++) 
        {
            G->arc[j][i] =G->arc[i][j];
        }
    }

}

//快速排序的条件
int cmp(const void* a, const void* b) 
{
    return (*(Edge*)a).weight - (*(Edge*)b).weight;    //从小到大排序
}

//找到根节点
int Find(int *parent, int f) 
{
    while ( parent[f] > 0) 
    {
        f = parent[f];
    }
    return f;
}

// 生成最小生成树
void MiniSpanTree_Kruskal(MGraph G) 
{
    int i, j, n, m;
    int k = 0;
    int parent[MAXVEX]; //用于寻找根节点的数组

    Edge edges[MAXEDGE]; //定义边集数组,edge的结构为begin,end,weight,均为整型

    // 用来构建边集数组并排序(将邻接矩阵的对角线右边的部分存入边集数组中)
    for ( i = 0; i < G.numVertexes-1; i++) 
    {
        for (j = i + 1; j < G.numVertexes; j++) 
        {
            if (G.arc[i][j] < INFINITY) 
            {
                edges[k].begin = i; //编号较小的结点为首
                edges[k].end = j;   //编号较大的结点为尾
                edges[k].weight = G.arc[i][j];
                k++;
            }
        }
    }

    //为边集数组Edge排序，从小到大排序
    qsort(edges, G.numEdges, sizeof(Edge), cmp);

    //先初始化parent数组
    for (i = 0; i < G.numVertexes; i++)
        parent[i] = 0;

    
    printf("打印最小生成树：\n");
    for (i = 0; i < G.numEdges; i++)  //这个numEdges是边的条数
    {
        n = Find(parent, edges[i].begin);//寻找边edge[i]的“首节点”所在树的树根
        m = Find(parent, edges[i].end);//寻找边edge[i]的“尾节点”所在树的树根

        //假如n与m不等，说明两个顶点不在一棵树内，因此这条边的加入不会使已经选择的边集产生回路
        if (n != m) 
        {
            parent[n] = m;  //这样设置的目的就是表示他们在同一颗生成树里面，不表示顶点和顶点之间的关系
            printf("(%d, %d) %d\n", edges[i].begin, edges[i].end, edges[i].weight);
        }
    }
}

int main(void)
{
    MGraph G;
    CreateMGraph(&G);
    MiniSpanTree_Kruskal(G);

    return 0;
}

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
判断两个树是否相同
如果要判断两个树是否相同，就是判断节点所包含的数字是否相同
struct TreeNode
{
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};

//第一种
bool isSameTree(struct TreeNode* p, struct TreeNode* q)
{
    bool rlt;
	//传进来两个节点，首先要判断节点是否为空
    if(p == NULL && q == NULL)
        return true;
    if ((p == NULL && q != NULL) || (p != NULL && q == NULL)) 
	{
        return false;
    } 
    return isSameTree(p->left, q->left) && 
            p->val == q->val && 
            isSameTree(p->right, q->right);
}

//第二种简便算法
bool isSameTree(struct TreeNode* p, struct TreeNode* q)
{
    if (p == NULL || q == NULL) 
    {
        return p == q;
    }
    return  p->val == q->val &&
               isSameTree(p->left, q->left) &&    
               isSameTree(p->right, q->right);
}

=======================================================================================================================================
判断一个树是否是轴对称树
就是判断一个节点的情况，下面的节点都递归下去了，重复第一个节点的操作

bool isSymmetric(struct TreeNode* root){
    if (root == NULL) return true;
    return fun(root->left, root->right);
}

int fun(struct TreeNode* l_root, struct TreeNode* r_root)
{
    //首先要判断是否为空的情况
	//递归前面的是一开始就要判断的，所以要把判断是否为空放前面
	//递归后面的是从底翻上去返回的东西
	if (l_root == NULL && r_root == NULL) return true;
    if (l_root == NULL || r_root == NULL) return false;

    return    (l_root->val == r_root->val)   &&
           fun(l_root->left,  r_root->right) &&
           fun(l_root->right, r_root->left);
}


=======================================================================================================================================
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5


 题目中测试用例[-10,-3,0,5,9]生成的平衡二叉树应为：

以上面的测试用例为例，数组值nums为[-10,-3,0,5,9]，数组numsSize长度5。
平衡二叉树的根节点应该是这组数据中大小中间的值 0.
由于测试用例是一个有序数组，所以平衡二叉树的根节点的值就应该为数组中坐标中点(numsSize/2)的值。
那么:
该根节点的左节点值 应该为位于数组的范围就为[0 ~ (numsSize/2) -1]的中间值。
该根节点的右节点值 应该为位于数组的范围就为[(numsSize/2)+1 ~ numsSize]的中间值。
这样可以通过数组范围left,right和数组nums生成递归。

///这道题的目的就是把数组里的数不断选出中间的，输入到一棵树的链表中
void InitNode(struct TreeNode *nowNode)  //初始化这个Node的值
{
	nowNode->left  = NULL;
	nowNode->right = NULL;
}

//其实，这个的目的就是创造一个节点
/**
	如何创造一个节点
	首先判断这个节点可不可以创建，如果可以创建，给这个节点分配内存，
	完成这个节点的赋值操作，递归完成它的左右节点，因为它的左右节点同样
	属于一个节点
**/
struct TreeNode * CreateBST( int* nums , int left , int right)
{
	//这个节点不能创建
	if(left > right)   //说明这个数组遍历完成
	{
		return NULL;
	}
	
	//这个节点可以创建，如果可以创建，要给这个节点分配内存
	//创建了这个节点，就意味着nownode指向这个内存，之后不会乱指，
	//但是它里面的left和right有可能会乱指，所以要初始化指向NULL
	struct TreeNode *NowNode = (struct TreeNode *)malloc(sizeof(struct TreeNode));
	InitNode (NowNode);
	
	if( right == left) //处理最下面既没有左儿子也没有右儿子的节点，直接输入数字就好
	{
		NowNode->val = nums[left];
	}
	else  //处理既有左儿子又有右儿子的节点
	{
		int nownums = (right + left ) / 2;
		NowNode->val = nums[nownums]; //把中间的输进去
		
		NowNode->left = CreateBST(nums,left,nownums-1);
		NowNode->right = CreateBST(nums,nownums+1,right);
	}
	return NowNode;
}

struct TreeNode* sortedArrayToBST(int* nums, int numsSize)
{
	return CreateBST(nums,0,numsSize - 1);
}

=======================================================================================================================================
不用递归建立二叉搜索树
struct TreeNode* bstFromPreorder(int* preorder, int preorderSize)
{
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    
    root->val = preorder[0];
    root->left = NULL;
    root->right = NULL;
    
    //如果只有一个元素的情况
    if(preorderSize == 1) 
        return root;
    
    struct TreeNode* p;
    
    for(int i=1; i<preorderSize; i++)
    {
        p = root;
        
        //找到这个点应该插入的位置
        while((preorder[i]<p->val && p->left!=NULL) || (preorder[i]>p->val && p->right!=NULL))
        {
            if(preorder[i]>p->val)
                p=p->right;
            else
                p=p->left;
        }
        
        struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        node->val = preorder[i];
        node->left = NULL;
        node->right = NULL;
        
        if(preorder[i] > p->val)
            p->right = node;
        
        else
            p->left = node;
    }
    
    return root;
}


 
 
 
=====================================================================================================================================
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：


一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。


示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4


返回 false 。

//我的妈呀，太难了，我终于看懂这个递归了
int findBalanced(struct TreeNode* root){
	if( root == NULL ){
		return 0;
	}
	
	//下面这个步骤是得知一个节点左子树的高度
	/**
			1
		2		3
		这个递归的目的就是不断找出这棵树的左子树，直到到达末尾为空，返回0，如果想继续往上返回，就得加上本节点的高度1
		所以最终left_length是包含root_left的高度
		右边同理
		
		如果有一个这个节点下面某一个不符合条件，返回-2 ，-2加1等于-1，所以只要出现-1，就表示有不符合题意的，返回-2
	
	**/
	int left_length  = findBalanced(root->left) + 1;  
	
	//下面这个步骤是得知一个节点右子树的高度
	//只要发现有一个节点不符合条件就返回-1，-2+1 = -1，执行if，所以一直都不符合，必须得是负数，如果是正数就是(left_length == 1 || right_length == 1)
	//有可能它本身就是正数，负数是它根本不可能是负数
	int right_length = findBalanced(root->right) + 1;
	
	而下面的这些是在递归完成之后往上返回的时候需要做的
	//比较左子树和右子树
	if( left_length == -1 || right_length == -1 || left_length-right_length>1 || left_length-right_length<-1)
	//满足不是平衡二叉树的条件：①遍历的这个顶点不是平衡二叉树  ②遍历的之前顶点不满足平衡二叉树
	//如果是此顶点不满足返回-2，-2 + 1 = -1，如果是-1就是上一个顶点不满足
	{
		return -2;
	}
	//如果不是这两种情况的，返回它的左右子树中高度最高的
	else if( left_length >= right_length )
	{
		return left_length;
	}
	else
	{
		return right_length;
	}
}

bool isBalanced(struct TreeNode* root){
	if( findBalanced(root) < 0 ){
		return false;
	}else{
		return true;
	}
}


=========================================================================================================================================
【深度和高度的区分】第一个深度   第二个高度

               O   0 3        
			 /   \
			O 1 1 O 1 2
		   / \     \
		  O   O     O 2 1
		 2 0  2 0  /
				  O 3 0
 
 
 
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

返回它的最小深度  2.


递归寻找树深度的变形，每次只需要返回左右子树深度的最小值。
注意:

当左子树为空时，返回右子树深度；
当右子树为空时，返回左子树深度。

int minDepth(struct TreeNode* root){
	if(root == NULL)
	{
		return 0;
	}
	
	//这个是算上根节点的
	int left_length  = minDepth(root->left)  + 1;
	int right_length = minDepth(root->right) + 1;
	
	if( root->left == NULL )   //就是这个点右边什么都没有，当然返回右边的深度
	{
		return right_length;
	}
	else if( root->right == NULL )
	{
		return left_length;
	}
	else if( left_length >= right_length )
	{
		return right_length;
	}
	else
	{
		return left_length;
	}
}



===============================================================================================================================


给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1


返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
注意：路径必须是从头到底

struct TreeNode 
{
     int val;
     struct TreeNode *left;
     struct TreeNode *right;
};


bool hasPathSum(struct TreeNode* root, int sum)
{
   //首先判断这个根节点存不存在
   if(!root)
       return false;
   //如果传进来的点没有左右儿子，且这个节点所包含的数字正好是sum
   if (!root->left && !root->right && root->val == sum)
       return true;
   //如果这个节点有左儿子，左儿子所包含的值等于加上它爸爸的
   if(root->left)
       root->left->val += root->val;
   if(root->right)
       root->right->val += root->val;
   return (hasPathSum(root->left,sum) || hasPathSum(root->right,sum));
       
}



bool hasPathSum(struct TreeNode* root, int sum)
{
    //如果出现树的递归问题，一定要判断传进来的节点是否是NULL，如果是NULL返回false
	if (root == NULL) 
	{
        return false;
    }

    //如果这个节点的左右儿子全是空，表明这个节点是最末的节点，判断这个节点所包含的数字和最后遗留下来的数字是否相同
	if (root->left == NULL && root->right == NULL) 
	{
        return (sum == root->val);
    }
	
	//这个遗留下来的数字是sum减去这个节点所包含的数字
    int remainSum = sum - root->val;
	
	//这个的意思是只要下面两个有一个符合题意就行，一直递归调用left，直到到达根节点，如果找到，返回1，执行root->right
	//返回上一个left
    return hasPathSum(root->left, remainSum) || hasPathSum(root->right, remainSum);
}


================================================================================================================================
__________________________________________________________________________________________________________________

给定一个二叉树，返回它的中序 遍历。

示例:

输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]



struct TreeNode {
     int val;
     struct TreeNode *left;
     struct TreeNode *right;
};


/**
	因为我的目的是从下往上遍历左节点，以各个左节点为起点，开始不断输出它的右边
**/

int* inorderTraversal(struct TreeNode* root, int* returnSize)
{
    struct TreeNode* st[1000] = {0};  //struct TreeNode*  就是st数组里每个元素的类型
    int *nums = malloc(sizeof(int) * 1000);
    int p = -1, index = 0;

    while(root != NULL || p != -1)
    {
        while(root != NULL)
        {
            st[++p] = root;
            root = root->left;
        }
		
        if(p != -1)
        {
            root = st[p--];
            nums[index++] = root->val;
            root = root->right;
        }
    } 

    *returnSize = index;
    return nums;  
}

__________________________________________________________________________________________________________________
给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。不会

示例:

输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3



struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};

/*
	二叉树的内存分配
	分为两种情况
	struct TreeNode*       这种情况的意思就是 树是一个类似于链表的结构 所以每一个树节点都是一个指针类型
	struct TreeNode**      这种情况的意思就是 一个数组里储存着储存着很多树结点  每一个树节点都是一个指针
	
	所以分配内存要分配两次，一次是给数组里这个位置分配内存，还有一个是给这个结点分配内存

*/


struct TreeNode** create(int start,int end,int*m)   //m是这个数组里有几个位置
// 返回所有从start开始到end结束这些数所能构成的二叉搜索树，并通过间接赋值输出这些二叉树的数目

{
    struct TreeNode **p,**lefts,**rights;
    int a,i,b,j,k,count = 0;   
		
	
    if(start > end) 
    {              
        //这个空也在数组里占一个位置
		p = (struct TreeNode**)malloc(sizeof(struct TreeNode*)); //二级指针只指向一个一级指针
        *p = NULL; 
        *m = 1; 
        return p;
    } 
    
    if(start == end)             //当子树个数为一时的特殊情况
    {
         p = (struct TreeNode**)malloc(sizeof(struct TreeNode*));   //二级指针只指向一个一级指针
        *p = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        (*p)->left = (*p)->right = NULL;   //当子树为1时的赋值
        (*p)->val = start;
        *m = 1;
        return p;
    }                         //为了减少循环量，不写也可以
	
	//这个给p分配的内存就是在数组里分配10000个位置
    p=(struct TreeNode**)malloc(sizeof(struct TreeNode*)*10000);//设置一个足够大的分配内存空间来存储左右子树的各种情况
	
    
	for(i = start;i<=end;i++)
    {
        //下面这两步的目的就是确定根节点i 和它的左右子树 ab就是数组里有多少个位置
		//当完成下面两步之后，lefts 和 rights就是两个二维数组，每一行分别是一种情况
		lefts = create(start,i-1,&a);
        rights = create(i+1,end,&b);     //递归生成左右子树s
        
        for(k = 0;k<a;k++)
        {
            for(j=0;j<b;j++)          //两个for循环链接两个子树s        
            {
                //因为刚才已经分配了位置，所以现在只要分配结点就行
				p[count] = (struct TreeNode*)malloc(sizeof(struct TreeNode));
                p[count]->val = i;
                p[count]->left = lefts[k];
                p[count]->right = rights[j];      
                count++; //记录个数
            }
        } 
    }
     *m = count;
    return p;
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
struct TreeNode** generateTrees(int n, int* returnSize){
    struct TreeNode** p;
    if(n == 0) 
    {
        *returnSize = 0;
        return NULL;
    }       //当n为0的特殊情况
    p = create(1,n,returnSize);  //调用函数计算
    return p;
}//结束

=====================================================================================================================

翻转一棵二叉树。

示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9

输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

struct TreeNode {
     int val;
     struct TreeNode *left;
     struct TreeNode *right;
};

Please look this, this is left_right type that our speak 
struct TreeNode* invertTree(struct TreeNode* root)
{
    
    struct TreeNode* tmpNode;
    
    if(root)
    {   
       tmpNode = invertTree(root->left);
       root->left = invertTree(root->right);
       root->right = tmpNode;
    }
    
    return root;   
}


————————————————————————————————————————————————————————————————————————————————
struct TreeNode* invertTree(struct TreeNode* root)
{
    if(root == NULL)
        return root;
		
    //记住树是通过指针相连，只要左右换了，就是左边所有的和右边所有的都换了
	struct TreeNode *temp;
    temp = root->left;
    root->left = root->right;
    root->right = temp;
    if(root->left != NULL)
    {
        invertTree(root->left);
    }
    if(root->right != NULL)
    {
        invertTree(root->right);
    }
    return root;
}

=====================================================================================================================
/**
    给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：


	每个节点都有 0 个或是 2 个子节点。
	数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）
	每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。


    在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。

     

    示例：

    输入：arr = [6,2,4]
    输出：32
    解释：
    有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。

        24            24
       /  \          /  \
      12   4        6    8
     /  \               / \
    6    2             2   4
    
    我来大概重复一下这道题的意思：
    父节点的值就是左子树叶节点最大的 × 右子树叶节点最大的，何为叶节点，就是数组里的值，何为父节点，就是求出来的值
    所以首先要取出数组里最大的数
    如果这个数在左右两边
    如果这个数在中间 
     
    因为节点值等于左边的叶子节点的最大值 * 右边叶子结点的最大值  所以要使叶子结点尽量放在高处，这样只有比它高的结点会影响，而比他矮的不会被影响	 

**/

/*
为了保证最后输出的结果最小，分析可知尽量让数值大的分布在较高的节点处，
这样计算非叶节点值的时候会用到这个较大数值的次数就相对比较少了。
以此分析，以最大数值为分界点，
把树分为左子树和右子树，分别计算非叶节点的和即可。
*/

//找最大的就是找最大的所对应的下标
int GetMaxIdx(int *arr, int arrSize)
{
    int max = arr[0];
    int out = 0;
    for (int i = 0; i < arrSize; i++) 
    {
        if (arr[i] > max) 
        {
            max = arr[i];
            out = i;
        }
    }   
    return out;
}

//递归其实就是看父节点和两个孩子的情况
int CalcMin(int *arr, int arrSize)
{
    /* 1、得到数组中最大成员序号 */
    
    //特殊情况：如果只有两个元素，返回他们的乘积
    if (arrSize == 2) 
    {
        return arr[0] * arr[1];
    }
    
    //如果有1个元素，就没有这种情况
    if (arrSize == 1) 
    {
        return 0;
    }
    
    int finalOut = 0x7fff;
	
    //取出这个里面的最大值的下标
    int Idx = GetMaxIdx(arr, arrSize);
    
    for (int i = 0; i < arrSize; i++)  //这个循环的目的就是找出有没有这个数，我觉着没用
    {
        if (arr[i] == arr[Idx]) 
        {
            int out = 0;
            int maxIdx = i;
            
            /* 最大数值在两端点的情况 */
            if (maxIdx == 0) 
            {
                //找出剩下的最大值
                int secMax = GetMaxIdx(arr + 1, arrSize - 1);
                
                //out的意思就是根节点的值
                out = (arr + 1)[secMax] * arr[maxIdx];
                out += CalcMin(arr + 1, arrSize - 1);
                
                return out;
            }
            else if (maxIdx == arrSize - 1) 
            {
                int secMax = GetMaxIdx(arr, arrSize - 1);
                out  = arr[secMax] * arr[maxIdx];
                out += CalcMin(arr, arrSize - 1);
                
                return out;
            } 
            
            //最大数值在中间的情况
            else 
            {
                int leftMax = GetMaxIdx(arr, maxIdx); // 左侧最大值【索引】
                int rightMax = GetMaxIdx(arr + maxIdx + 1, arrSize - maxIdx - 1); // 右侧最大值索引
                int left = arr[leftMax];
                int right = (arr + maxIdx + 1)[rightMax];
                
                /* 根据次大的数值选择最大数值位于左子树还是右子树 */
                if (left > right) 
                { 
                    out = left * arr[maxIdx]; //次大数值在左侧，那最大数值放在右子树。
                    //遍历右子树
                    out += CalcMin(arr + maxIdx, arrSize - maxIdx);
                    //遍历左子树
                    out += CalcMin(arr, maxIdx);
                } 
                else if (left < right) 
                {
                    out = right * arr[maxIdx]; //次大数值在右侧，那最大元素放在左子树
                    out += CalcMin(arr + maxIdx + 1, arrSize - maxIdx - 1);
                    out += CalcMin(arr, maxIdx + 1);
                } 
                else 
                {   // 如果次大数值在最大数值的两侧都有，那就都计算一遍比较哪种比较小
                    out = left * arr[maxIdx];
                    out += CalcMin(arr + maxIdx, arrSize - maxIdx);
                    out += CalcMin(arr, maxIdx);
                    
                    int tmpOut = left * arr[maxIdx];
                    tmpOut += CalcMin(arr + maxIdx + 1, arrSize - maxIdx - 1);
                    tmpOut += CalcMin(arr, maxIdx + 1);
                    
                    if (tmpOut < out) 
                    {
                        out = tmpOut;
                    }
                }
            }
            //不断选出里面的最小值
            if (finalOut > out) 
            {
                finalOut = out;
            }
        }
    }  
    return finalOut;
}

int mctFromLeafValues(int* arr, int arrSize)
{
    int out;
    out = CalcMin(arr, arrSize);
    return out;
}

=====================================================================================================================
给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：


	该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）


如果不存在祖父节点值为偶数的节点，那么返回 0 。

                 6
			/         \
		   7           8
		 /   \       /   \
       [2]   [7]   [1]   [3]
	   /    / \            \
	  9    1   4           [5]


 

int sumEvenGrandparent(struct TreeNode* root) 
{
        if (root == NULL) 
			return 0;
        int temp = 0;
        if (root->val % 2 == 0) 
		{
            if (root->left != NULL) 
			{
                if (root->left->left != NULL) 
					temp += root->left->left->val;
                if (root->left->right != NULL) 
					temp += root->left->right->val;
            }
            if (root->right != NULL) 
			{
                if (root->right->left != NULL) 
					temp += root->right->left->val;
                if (root->right->right != NULL) 
					temp += root->right->right->val;
            }
        }
        return temp + sumEvenGrandparent(root->left) + sumEvenGrandparent(root->right);
}


__________________________________________________________________________________________________________________
深度优先遍历（就是检查每一个节点）
class Solution {
private:
    int ans = 0;
    
public:
    void dfs(int gp_val, int p_val, TreeNode* node) {
        if (!node) {
            return;
        }
        if (gp_val % 2 == 0) {
            ans += node->val;
        }
        dfs(p_val, node->val, node->left);
        dfs(p_val, node->val, node->right);
    }
    
    int sumEvenGrandparent(TreeNode* root) {
        dfs(1, 1, root);
        return ans;
    }
};

————————————————————————————————————————————————————————————————————————————————
广度优先遍历
首先检查一个节点是否是偶数，如果是，输出它的孙子
class Solution {
public:
    int sumEvenGrandparent(TreeNode* root) 
	{
        //建立一个队列
		queue<TreeNode*> q;
        q.push(root);
        int ans = 0;
        while (!q.empty()) 
		{
            TreeNode* node = q.front();
            q.pop();
            if (node->val % 2 == 0) 
			{
                if (node->left) 
				{
                    if (node->left->left) 
					{
                        ans += node->left->left->val;
                    }
                    if (node->left->right) 
					{
                        ans += node->left->right->val;
                    }
                }
				
                if (node->right) 
				{
                    if (node->right->left) 
					{
                        ans += node->right->left->val;
                    }
                    if (node->right->right) 
					{
                        ans += node->right->right->val;
                    }
                }
            }
            if (node->left) 
			{
                q.push(node->left);
            }
            if (node->right) 
			{
                q.push(node->right);
            }
        }
        return ans;
    }
};


=====================================================================================================================
给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。

注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。

也就是说，你需要重复此过程直到不能继续删除。

//一定要记住向下三角形和回溯三角形
int dfs(struct TreeNode* root,int target)
{
    if(root->left != NULL && dfs(root->left, target)) 
		root->left = NULL;
		
    if(root->right != NULL && dfs(root->right,target)) 
		root->right = NULL;
		
    if(root->left == NULL && root->right == NULL && root->val == target) 
		return 1;
		
    return 0;
}
struct TreeNode* removeLeafNodes(struct TreeNode* root, int target)
{
    if (dfs(root, target)) 
		return NULL;
    return root;
}


=====================================================================================================================
给你一棵二叉树，请你返回层数最深的【叶子节点】的和。
                       1
                     /   \
                    2     5
                  /  \  /  \
                3    6 4    9
                           / \
                          10 12

            中间竖杠的目的是把它分为左子树和右子树
            前序遍历：1 2 3 6 5  4  9  10 12      
            后序遍历：3 6 2 4 10 12 9  5  1			
			中序遍历：3 2 6 1 4  5  10 9 12
错的精彩
int maxDeepth;

void calcSum(struct TreeNode* root, int deep, int* sumNode) 
{
    if(root == NULL)
        return ;
    if(deep > maxDeepth)
    {
        maxDeepth = deep;
        //printf("%d ", maxDeepth);
    }

    calcSum(root->left, deep + 1, sumNode);
    calcSum(root->right, deep + 1, sumNode);
    
    

    //这条语句什么时候执行，不是等前序遍历都遍历完时返回，而是只要一个结点的左右孩子都为空时，后序遍历的这条语句就开始执行了
    //所以说有可能中间输出，那就错啦，我要的是前序遍历全部完时输出
    /*
        50
           \
           54
          /  \
         98   6
               \
               34
        
        比如说这个，当前面执行完时  root->val = 98, 此时maxDeepth = 2 ，所以要输出，这就错啦
        我仔细想了一下，必须先求出深度，才可以这样计算

        不要灰心，有个想法很正确，就是前序遍历求出的最大值可以在后序遍历一直存在
    */
    printf("%d ", maxDeepth);
    if(deep == maxDeepth)
        *sumNode += root->val; 
    printf(" （%d）【%d】[%d] \n", *sumNode, root->val, deep);
      
}


int deepestLeavesSum(struct TreeNode* root)
{
    int sumNode = 0;
    maxDeepth = 0;
    calcSum(root, 0, &sumNode);
    return sumNode;
}


——————————————————————————————————————————————————————————————————————————————————

void calcSum(struct TreeNode* root, int deep, int* maxDeepth, int* sumNode) 
{
   //深度就是从1开始  
   
   /*
		下面这种方法很巧妙
		如果deep > *maxDeepth  就意为着前面计算的sumNode都不算
		sumNode得从root->val开始从新算
   */	
    if (root == NULL) 
	{
        return;
    }
    if(deep > *maxDeepth) 
	{
        *maxDeepth = deep;
        *sumNode = root->val;
    }
	else if(deep == *maxDeepth) 
	{
        *sumNode += root->val;
    }
    //printf("\ndeep %d, sum %d", *maxDeepth, *sumNode);
    calcSum(root->left,deep+1,maxDeepth,sumNode);
    calcSum(root->right,deep+1,maxDeepth,sumNode);
}
int deepestLeavesSum(struct TreeNode* root)
{
    int sumNode =0;
    int maxDeepth = 0;
    calcSum(root,0,&maxDeepth,&sumNode);
    //printf("\nsumNode = %d", sumNode);
    return sumNode;
}

=====================================================================================================================
有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 root，树上总共有 n 个节点，且 n 为奇数，其中每个节点上的值从 1 到 n 各不相同。

 

游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时，

「一号」玩家从 [1, n] 中取一个值 x（1 <= x <= n）；

「二号」玩家也从 [1, n] 中取一个值 y（1 <= y <= n）且 y != x。

「一号」玩家给值为 x 的节点染上红色，而「二号」玩家给值为 y 的节点染上蓝色。

 

之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色。

如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。

若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。

 

现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true；若无法获胜，就请返回 false。

————————————————————————————————————————————————————————————————————————————————
就是一个人着一次色，下一次着色必须根据已经着色的地方接着着
可以根据已经着色的地方向四周扩散

/**
    根据第一个涂红的点可以分为三部分：左孩子的一堆  右孩子的一堆  剩下的所有
    如果选择了左孩子，就将左孩子下面的所有涂成蓝色  剩下两部分涂成红色
    剩下同理 
**/

相当于这样
     O
	 |
	 O
	/ \
   O   O


struct TreeNode *g_firstPlayer;

//找到这个点下面所有的个数,包括这个节点
int CalcNodeNum(struct TreeNode *root)
{
    if (root != NULL) 
        return 1 + CalcNodeNum(root->left) + CalcNodeNum(root->right);
}

//找到这个点和它上面所有的个数
int CalcAndFind(struct TreeNode *root, int toFind)
{
    int output = 0;
    int output = 0;
    if (root == NULL) 
    {
        return output;
    }
    if (root->val == toFind) 
    {
        g_firstPlayer = root;
        return output;
    } 
    
	//这是左右递归裸露函数
	//设置全局变量num 在主函数中初始化num为0
	
	/**
	
	num++;
    CalcAndFind(root->left, toFind);
    CalcAndFind(root->right, toFind);
    return num;
	
	**/
    
	//这是左右递归非裸露函数
	return (1 + CalcAndFind(root->left, toFind) + CalcAndFind(root->right, toFind));
}

bool btreeGameWinningMove(struct TreeNode* root, int n, int x)
{   
    g_firstPlayer = NULL;
	
	//记住一个特殊情况，就是当root是根节点的时候
    if (x == root->val) 
    {
        /* 1、如果第一个玩家选择的是第一个根节点 */
        /* 1.1、左子节点下节点总数 */
        int left = CalcNodeNum(root->left);
        
        /* 1.2、右子节点下节点总数 */
        int right = n - left - 1;  //去掉左边的个数和根节点
        if (left == right) 
            return false;

        else 
            return true;
    } 
	
	//如果root不是根节点
    else 
    {
        /* 2、第一个玩家选择非第一个根节点 */
        /* 2.1、第一个玩家选择节点的根节点 */
        int Root = CalcAndFind(root, x);   
        /* 2.2、第一个玩家选择节点的左子节点 */
        int Left = CalcNodeNum(g_firstPlayer->left);
        /* 2.3、第一个玩家选择节点的右子节点 */
        int Right = CalcNodeNum(g_firstPlayer->right);
         printf("Root = %d, Right = %d, Left = %d", Root, Right, Left);
         
        //加1的目的就是为了加上那个根节点
        if (Root > Left + Right + 1 || Right > Root + Left + 1|| Left > Root + Right + 1) 
        {
            return true;
        }  
        else 
        {
            return false;
        }
    }
}

=====================================================================================================================
二叉树寻路
就是在一棵完全二叉树中，奇数行顺序不变，偶数行反着来，找到一个点的路径

因为以1为根节点层次编号的满二叉树可以对应到位的表示，所以用位运算的思路即可。
因为每层的顺序在变，所以每次需要对首位外的其它位取反。
举例14=1110b，
先将14右移，变为111b(7)，然后对除第一位外所有位取反变为100b，即它的根节点4，
同理100b(4)，右移变为10b(2)，对除第一位外所有位取反变为11b，即它的根节点3
一直到1结束。


先开始这个二进制所有位都为0
0000 0000 0000 0000 
第一行   0000 0000 0000 0001
第二行   位数向后移动一位，补齐前面的，排列组合01  
		 0000 0000 0000 0010
         0000 0000 0000 0011
第n行同理  所以说每一行最大的数字就是 1 1111.....第一个1是上一行向后移动一个的，不能变
                       最小的数字就是 1 0000
所以才有上面的结论  << >>相当于除2  乘2

二叉树图


									   1
									  /  \
									 /    \
									/      \
								   /        \
								  /          \
								 /            \
								/              \
							   /                \
							  /                  \
						     /                    \
							/                      \
						   /                        \
						  /                          \
						 2                            3
					   /   \                        /   \
					  /     \                      /     \
					 /       \                    /       \
				    /         \                  /         \
				   /           \                /           \
				  4             5              6             7
				/   \         /   \          /   \         /   \
			   /     \       /     \        /     \       /     \         
			  8       9     10     11      12     13     14     15
			/  \    /  \   /  \   /  \    /  \   /  \   /  \   /  \
		   16  17  18  19 20  21 22  23  24  25 26  27 28  29 30  31
 


int* pathInZigZagTree(int label, int* returnSize)
{
    int count = 0;
    int tmp = label;
    //确认returnSize
    while (tmp != 0){
        tmp >>= 1;
        count++;
    }
    *returnSize = count;
    int *ret = (int *)malloc(sizeof(int)*count);
    //从末置位开始写入
    for( int i = count - 1; i > -1;i--){
        ret[i]=label;
        //将label的值右移一位，层数上升
        label >>= 1;
        //异或操作，实现题目中的反转顺序，如果没有交叉顺序的话不需要这一步操作就可以得到其父节点。
		/*
			假设label = 1000   (int)pow(2, i - 1) - 1 = 111; 由下表可知，当b为1时，a取反 
			真值表 
			 a   b   a ^ b
			 1   0     1
	     	(1   1     0)
			 0   0     0
			(0   1     1)

		*/
        label ^= (int)pow(2,i-1)-1; //(int)pow(2,i-1)的意思就是上一行总共的数字，也就是总共的二进制数位，减1就是除了第一位的
    }
    return ret;

}

=====================================================================================================================
给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。

对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。

以 10^9 + 7 为模，返回这些数字之和。

 

示例：
		1
	  /   \
     0     1 
	/ \   / \
   0   1 0   1

输入：[1,0,1,0,1,0,1]
输出：22
解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22

左右递归非裸露函数

int _sumRootToLeaf(struct TreeNode *root, int num) 
{
    int sum = 0; 
    /**
        这一步是啥意思了：就是把num向左移一位，空出来的位补上root->val
    **/
    num = (num << 1) + root->val;  
    if (root->left == NULL && root->right == NULL)
        return num; 
    if (root->left) 
        sum += _sumRootToLeaf(root->left, num);
    if (root->right) 
        sum += _sumRootToLeaf(root->right, num);
    return sum; 
}

int sumRootToLeaf(struct TreeNode *root) 
{   
    //这个的意思就是判断根节点是否存在，存在输出算出的结果，不存在输出0
    return root ? _sumRootToLeaf(root, 0) : 0;
}

__________________________________________________________________________________________________________________int num;
左右递归裸露函数

int num;
void _sumRootToLeaf(struct TreeNode *root, int sum)
{
    if(root == NULL)
        return;

    sum = (sum << 1) + root->val;
	
    //得先对sum做如上操作，才是属于这个函数的sum
    if(root->left == NULL && root->right == NULL)
        num += sum;

    _sumRootToLeaf(root->left, sum);
    _sumRootToLeaf(root->right, sum);

}


int sumRootToLeaf(struct TreeNode *root)
{
    int sum = 0;
    num = 0;
    _sumRootToLeaf(root, sum);
    return num;
}

==================================================================================================================================================


最深叶节点的最近公共祖先
给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。

回想一下：


	叶节点 是二叉树中没有子节点的节点
	树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1
	如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。


 

示例 1：

要注意啊，返回值不是[1,2,3]这个数组，而是一个树根

输入：root = [1,2,3]
输出：[1,2,3]


示例 2：

输入：root = [1,2,3,4]
输出：[4]


示例 3：

输入：root = [1,2,3,4,5]
输出：[2,4,5]


//下面的dep就是此结点的深度
//下面的fa就是记录这个结点之下 左边等于右边的结点
struct info{
    int dep;
    struct TreeNode* fa;
 };

struct info getDeep(struct TreeNode* root)
{
    struct info res={0,NULL};
    if (!root) 
		return res;
    else
    {
        struct info l,r;
        l = getDeep(root->left);
        r = getDeep(root->right);
		
		/*
			我应该如何说呢，下面这些相当于后序遍历当中的回溯
			
		*/
        if (l.dep==r.dep)
        {
            res.dep = l.dep + 1; //因为要回溯，回溯的含义是这这个结点的深度
            res.fa = root;
        }
        else
        {
            if (l.dep < r.dep)
            {
                res.fa = r.fa;
                res.dep = r.dep+1;
            }
            else
            {
                res.fa = l.fa;
                res.dep = l.dep+1;
            }
        }
    }
    return res;
}

struct TreeNode* lcaDeepestLeaves(struct TreeNode* root)
{
    struct info res = getDeep(root);
    return res.fa;
}





=====================================================================================================================

节点与其祖先之间的最大差值
给定二叉树的根节点 root，找出存在于不同节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。

（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）

 


输入：[8,3,10,1,6,null,14,null,null,4,7,13]
输出：7
解释： 
我们有大量的节点与其祖先的差值，其中一些如下：
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。

class Solution 
{
    int res = Integer.MIN_VALUE;  //这个形式的存在是很有意义的了，在全局中存在，且可以修改
	
	
    public int maxAncestorDiff(TreeNode root) 
	{
        if (root == null) return 0;
        //如果当前节点没有子节点，则直接返回
        helper(root, root.val, root.val);
        return res;
    }

    /**
     * 每条从根节点到叶子节点的路径中的最大值和最小值，并求出差值更新全局变量
     */
    private void helper(TreeNode node, int max, int min) 
	{
        if (node == null) 
			return;
        max = Math.max(node.val, max);
        min = Math.min(node.val, min);
        //到达叶子节点，求最大差值
		//因为要求必须是祖先和子孙之间的关系，所以必须在到达一条线的末尾进行判断，太巧妙了
        if (node.left == null && node.right == null) 
		{
            res = Math.max(res, Math.abs(max - min));
        }
        helper(node.left, max, min);
        helper(node.right, max, min);
    }
}


java

=====================================================================================================================
反转等价二叉树
我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。

只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。

编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。

bool flipEquiv(struct TreeNode* root1, struct TreeNode* root2)
{
    if (!root1 && !root2)
        return true;

    if(root1 == NULL || root2 == NULL || root1->val != root2->val)
        return false;

    return ((flipEquiv(root1->left,root2->left)&&flipEquiv(root1->right,root2->right)) || (flipEquiv(root1->right,root2->left)&&flipEquiv(root1->left,root2->right))) ;

}

=====================================================================================================================
完全二叉树
给定一个二叉树，确定它是否是一个完全二叉树。

百度百科中对完全二叉树的定义如下：

若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）


每个顶点入队的层次遍历，只要用脑子算这道题的时候是一行一行算的，就用层序遍历，只要
用到层序遍历，就要用入队出队的方法

bool isCompleteTree(struct TreeNode* root) 
{
    struct TreeNode *Queue[2000];
    int front=0,back=0;
    if(root) 
		Queue[back++]=root;
		
    //层次遍历
    while(front<back)
    {
        int cnt=back-front;//一层的结点数目，上一层的结点数目
        for(int i=0;i<cnt;i++)
        {
            //让它下一层的结点入队列
			root=Queue[front++];
            if(root)
            {
                Queue[back++]=root->left;
                Queue[back++]=root->right;
            }
            else//结点为null时
            {
                while(front<back)//将这一层的节点数全部进行判断
                {
					if(Queue[front++]!=NULL)//出现不为null的情况即为false
                        return false; 
                }
            }

        }
    }
    return true;
}

——————————————————————————————————————————————————————————————————————————————————
不进行层次遍历的代码
天哪，这个太厉害了，自己画画图一目了然
之后如果要进行一层一层的遍历，就用这个方法，设置头尾指针，先加入根节点到队列中，然后加这个根节点的孩子到队列中，尾指针不断移动......
如果事物完全二叉树，一旦出现空，则它之后都是空，如果出现不是空的情况就是非完全二叉树

bool isCompleteTree(struct TreeNode* root) 
{
    struct TreeNode *Queue[200];
    int front=-1,rear=-1;
    Queue[++rear]=root;
    while(front<rear)
    {
        root=Queue[++front];//DeQueue出队列过程
        if(root!=NULL)
        {
            Queue[++rear]=root->left;
            Queue[++rear]=root->right;
        }
        else
        {
            while(front<rear)
            {
                if(Queue[++front]!=NULL)
                {
                    return false;
                }
            }
        }
    }
    return true;
}

=====================================================================================================================

单值二叉树
如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
只有给定的树是单值二叉树时，才返回 true；否则返回 false。

bool helper(struct TreeNode* root,int val)
{
	/*
		我的目的就是不断检查每个结点的值是否是val，这个过程可以用递归来实现
		如果不是，返回false
		而return helper(root->left, val) && helper(root->right, val);
		这个就可以达到目的
	*/
	if(root==NULL) 
	    return true;
		
    if(root->val!=val) 
	    return false;
		
    return helper(root->left,val) && helper(root->right,val);
}
bool isUnivalTree(struct TreeNode* root)
{
   
    if(root==NULL) 
		return true;
    return helper(root,root->val);
}

=====================================================================================================================
反转二叉树以匹配先序遍历
**
    voyage是给定的先序遍历的数组
    root是给定的一棵树
    看是否能通过交换这棵树中一个结点的左右儿子使这棵树的先序遍历和voyage相匹配
    并把这个结点输入到returnSize数组中
    
    如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。
    如果不能，则返回列表 [-1]。

**/


int* flipMatchVoyage(struct TreeNode* root, int* voyage, int voyageSize, int* returnSize)
{
    int* ret = (int*)malloc(sizeof(int)*voyageSize);
    
    //保存树结点的栈，因为树是通过链表储存的，通过指针来找到下一个结点，所以每一个结点的类型是struct TreeNode *
    //栈的储存形式有数组也有链表，数组本质就是指针，链表刚才说也是通过指针寻找，所以栈的类型就是struct TreeNode **
    //如果是数组的话，就可以把栈想象成一排柜子，根据数组的下标可以找到这个柜子，根据柜子里面储存的地址又可以找到这个结点
    //下面的内存分配就可以看成是stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *)*voyageSize)
    //内存的分配就是分配柜子的大小，柜子总共的大小由所装物品的类型struct TreeNode *和所装物品的多少voyageSize决定
    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *)*voyageSize);
    int i;
    int top = 0;
    stack[0] = root;
    int flipcunt = 0;
    
    for(i = 0;  i < voyageSize; i++)
    {
        if(top < 0 || stack[top]->val != voyage[i])   //如果top < 0意思就是说这个点的左右孩子都和voyage里面的不相等
                                                      //还有一种情况就是这个结点就不相等  这两种情况都是不符合题意的
													  //如果top < 0，就不可能有stack[top]->val这种形式的写法
        {
            ret[0] = -1;
            *returnSize = 1;
            return ret;
        }
        root = stack[top--];
     
        /*
            因为入栈是先进后出，应该是先看一个节点的左孩子，再看一个结点的右孩子的，因为栈刚好是相反，所以是先右后左
            这个下面的意思就是如果这个结点左右孩子的顺序和值刚好和voyage相同的情况
            同样注意呀：每个if之后都有一个continue，意思就是这两个只能执行一个
        */
        if(NULL != root->left && root->left->val == voyage[i+1])  //如果这个结点的左孩子不为空，且这个左孩子和yoyage中的相同
        {
            if(NULL != root->right)  //如果这个点的右孩子不为空
            {
                stack[++top] = root->right;  //把原来放根节点的地方放上右孩子
            }
            stack[++top] = root->left;  //栈的下一位放上左孩子
            continue; //注意这个
        }
        
        /*
            这个下面的意思就是如果这个结点左右孩子的顺序和值刚好和voyage相反的情况
            如果相反，这个结点就要入ret中了
        
        */
        
        if(NULL != root->right && root->right->val == voyage[i+1])  //如果这个结点的右孩子不为空，且这个右孩子和yoyage中的相同
        {
            if(NULL != root->left)   //如果这个点的左孩子不为空      
            {
                ret[flipcunt++] = root->val;  
                stack[++top] = root->left;
            }
            stack[++top] = root->right;
            continue; //注意这个
        }        
    }
	
    *returnSize = flipcunt;  //*returnSize是返回这个数组的大小
    return ret;

}


=====================================================================================================================
如何移动金币使得每个结点都分配有一个金币
/*
       示例1：输出2
                3         ans = 2      返回 0
              /   \
             0     0      0 返回 -1    0 返回 -1
          
       示例2：输出3
                0         ans = 3      返回 0
              /   \
             3     0      3 返回 2（它多出来两个金币，先移到父节点处，需要两步）   0 返回 -1（它需要一个金币，从父节点移到这里需要一步）  两步加一步 = 3
       
       示例3：输出2
                1         ans = 2      返回 0
              /   \
             0     2      0 返回 -1    0 返回 1                 
       
       示例4：输出4
                1         ans = 2      返回 0     ans = 4
              /   \
             0     0      0 返回 1    0 返回 -1   ans = 2
              \
               3          左边没有返回0   3返回2   
*/

int ans;

//以结点为单位，确定递归函数的含义
//结点需要的金币数
//L左边需要的金币数   R右边需要的金币数
int dfs(struct TreeNode* node)
{
    if(node == NULL)
        return 0;

    int L = dfs(node->left);  //左边需要的金币数
    int R = dfs(node->right); //右边需要的金币数
    int absL = L > 0 ? L : -L;
    int absR = R > 0 ? R : -R;

    ans += (absL + absR);          //所要移动的步数
    return node->val + L + R - 1;  

}


int distributeCoins(struct TreeNode* root) 
{
    ans = 0;
    dfs(root);
    return ans;
}

=====================================================================================================================
/*
    最大二叉树：
    最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。
    给出最大树的根节点 root。
    
	把val值插入到这棵树中
	这个记录上一个结点好巧妙呀
	只要涉及二叉树的增删就得记录上一个结点

*/


struct TreeNode* insertIntoMaxTree(struct TreeNode* root, int val)
{
    struct TreeNode *dummy = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    dummy->val = -1;
    dummy->right = root;
    dummy->left = NULL;

    struct TreeNode *prev = dummy;
    struct TreeNode *curr = root;
    
    while(curr != NULL && curr->val > val)  //找到这个点应该添加的位置
    {
        prev = curr;  //这个是curr的上一个结点
        curr = curr->right;
    }
    
    struct TreeNode *node = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    node->val = val;
    node->left = curr;
	node->right = NULL;
	
    prev->right = node;
    
    return dummy->right;
}

=====================================================================================================================
二叉树的堂兄弟结点
在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。

如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。

我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。

只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。


//这两个结点的e父节点
struct TreeNode* x_f = NULL;
struct TreeNode* y_f = NULL;
bool isCousins(struct TreeNode* root, int x, int y)
{
    int x_depth = find_depth_x(NULL, root, x);
    int y_depth = find_depth_y(NULL, root, y);
    return (x_f != y_f && x_depth == y_depth);
}


/**
	一棵树可以分为三部分：父结点  左孩子   右孩子
	函数里面的操作是对父节点的操作  递归的操作是测试这个结点的左孩子和有孩子是否满足题意
	如果递归root->left 当这个为空时，说明左孩子不满足题意 
	如果递归root->right 当这个为空时，说明右孩子不满足题意
	最后返回-1时，表明左右孩子都不满足题意
**/
int find_depth_x(struct TreeNode* f_node, struct TreeNode* root, int node_val)
{
    /*
		记住，寻找和回溯的过程可以看成是线性的，何为线性的
		就是一条路走到黑，可以把这个二叉树分为多个这样的一条路，那么，如果说这条路没有找到
		就返回-1表示，如果ret = -1就表明不符合题意，只要一出现大于0的情况，就说明需要开始回溯了	
	*/
	if (root == NULL)  
		return -1;   //为什么不是0，0表示深度是0，而-1表示这个深度根本不存在
    if (root->val == node_val) 
	{
        x_f = f_node;
        return 0;
    }
    int ret;
	//找到这个点，只有一条路
    if ((ret = find_depth_x(root, root->left,  node_val)) >= 0) return ret+1;   //这个返回值是左右孩子返回给父节点的东西
    if ((ret = find_depth_x(root, root->right, node_val)) >= 0) return ret+1;
           
    return -1;
}
int find_depth_y(struct TreeNode* f_node, struct TreeNode* root, int node_val)
{
    if (root == NULL)  return -1;
    if (root->val == node_val) {
        y_f = f_node;
        return 0;
    }
    int ret;
    if ((ret = find_depth_y(root, root->left,  node_val)) >= 0) return ret+1;
    if ((ret = find_depth_y(root, root->right, node_val)) >= 0) return ret+1;       
    return -1;
}


=====================================================================================================================
/*
    二叉树的垂序遍历
    啥意思就是左右儿子的位置取开区间，看包括在这个范围内的结点有多少，把这个范围内的结点从上到下输出来
    例1：
             3
            / \
           9  20
              / \
             15  7

         输入：[3,9,20,null,null,15,7]
         输出：[[9],[3,15],[20],[7]]
         
    例2：
                1
              /   \
             /     \
            /       \
           2         3
          / \       / \
         4   5     6   7
         
         输入：[1,2,3,4,5,6,7]
         输出：[[4],[2],[1,5,6],[3],[7]]
    
    （1）使用结构体，表示节点的位置和坐标
    （2）采用多关键字排序，首先按照x坐标进行排序，然后按照y坐标进行排序，最后按照值大小进行排序
    （3）进行遍历
*/

typedef struct Node
{
    int val;
    int xPos;
    int yPos;
} Node;

int num = 0;

//排序函数
int cmp(const void *temp1, const void *temp2)
{
    Node *node1 = (Node *)temp1;
    Node *node2 = (Node *)temp2;
    if (node1->xPos == node2->xPos)      //如果这两个点横坐标相同
    {
        if (node1->yPos == node2->yPos)  //纵坐标相同
        {
            return node1->val - node2->val; //横坐标相同，纵坐标也相同，不就是一个点，返回0
        }
        return node2->yPos - node1->yPos;//纵坐标不相同，按纵坐标从小到大排序
    }
    return node1->xPos - node2->xPos;    //横坐标不相同，按横坐标从大到小排序
}

//初始化 node 和 num 的值
void dfs(struct TreeNode *root, int x, int y, Node *node)
{
    if (root == NULL)
    {
        return;
    }
    
    //num是全局变量，初值为0
    node[num].val = root->val;
    node[num].xPos = x;
    node[num].yPos = y;
    num++;
    dfs(root->left, x - 1, y - 1, node);
    dfs(root->right, x + 1, y - 1, node);
}
int **verticalTraversal(struct TreeNode *root, int *returnSize, int **returnColumnSizes)
{
    int tempXPos = 0;
    int i = 0;
    int m = 0;
    int colSize = 0;
    int cur = 0;
    int *columnSizes=NULL;
    *returnSize = 0;
    int **result = NULL;
    
    Node *node = (Node *)malloc(sizeof(Node) * 1000);  //储存横纵坐标的
    num = 0;
    dfs(root, 0, 0, node);
    
    //这是一个排序函数
    /*
        int (*cmp)(const void *,const void *);
        qsort(*s, n, sizeof(s[0]), cmp);

        其中第一个参数s是一个地址，即参与排序的首地址；
        n是需要排序的数量；
        sizeof(s[0])则是每一个元素占用的空间大小；
        指向函数的指针，用于确定排序的顺序
    
    */
    //排好序之后 num数组里的值按从左到右从上到下的顺序排好
    qsort(node, num, sizeof(Node), cmp);
    
    tempXPos = node[0].xPos;
    result = (int **)malloc(sizeof(int *) * num);
    columnSizes = (int *)malloc(sizeof(int)*num);
    
    for (i = 0; i < num; i++)
    {
        if (tempXPos != node[i].xPos)  //i和它前面的数字的横坐标不相同
        {
            columnSizes[*returnSize] = i - cur;   //储存每一行有多少个数字
            result[*returnSize] = (int *)malloc(sizeof(int) * (i - cur));  //应该给这一行分配多少内存  i - cur是这一行元素的个数
            
            m = 0;  //m是在第几列
            for (int j = cur; j < i; j++)  //完成每行数字的输入
            {
                result[*returnSize][m] = node[j].val;
                m++;
            }
            *returnSize = *returnSize + 1;  //这个是在第几行
            cur = i;  //cur是每个小组的第一个数字下标  也就是第一个和它右边不相同的横坐标的数字的下标
            tempXPos = node[i].xPos;  //重新更换下标值
        }
    }
    //如果横坐标的值是12333333  上面的一堆只是如果横坐标有变化，才可以完成输出，所以最后的3并没有输出来
    columnSizes[*returnSize] = num - cur;   //i值和num的值是相同的 
    result[*returnSize] = (int *)malloc(sizeof(int) * (num - cur));
    m = 0;
    for (int j = cur; j < i; j++)   
    {
        result[*returnSize][m] = node[j].val;
        m++;
    }
    *returnSize = *returnSize + 1;  //行数是从0开始的，最终的行数是从1开始的，所以最后的行数得加1
    *returnColumnSizes=columnSizes; //储存每一行有多少个数字
    free(node);  //刚才按从左到右从上到下排好序的数组
    return result;
}

=====================================================================================================================
二叉树剪枝
https://leetcode-cn.com/problems/binary-tree-pruning/
给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。

返回移除了所有不包含 1 的子树的原二叉树。

( 节点 X 的子树为 X 本身，以及所有 X 的后代。)


void ss(struct TreeNode* root)
{
    /**
        恍然大悟：这就是小橘子的魅力
        首先：第一点 通过下面这两步可以找到所有的结点
             第二点  如果是在下面这两步上面所写意思就是从上往下   下面所写就是从上往下
        ss(root->right);  这一步是找到所有结点的右节点
        ss(root->left);   这一步是找到所有节点的左节点

        观察这道题目  应该选择从下往上  所以递归写上面  如果找到一个结点它本身为0，且没有左右孩子，就删除，如果要删除这个结点，就得取地址，如果不
        取地址，就得根据它的父节点，将他父节点的孩子设为NULL的形式将这个结点删除，所以才有下面的形式
    **/
    if(!root)
        return;
    
    ss(root->right);

    if(root->right && root->right->val == 0 && !root->right->left && !root->right->right)
        root->right=NULL;

    ss(root->left);

    if(root->left && root->left->val == 0 && !root->left->left && !root->left->right)
        root->left=NULL;
}
struct TreeNode* pruneTree(struct TreeNode* root)
{
    /*
        我懂了：这里为什么不传地址，因为如果传地址，目的就是为了改变变量所包含的内容，也就是为了改变root的指向
        而这里并不需要改变root的指向，需要改变的是root所包含左孩子或右孩子的指向，可以直接改
    */
    ss(root);
    return root;
}


=====================================================================================================================
二叉树中所有距离为k的结点

给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。
返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。
 //找到这个结点的父亲结点
void getParNode(struct TreeNode* curNode, struct TreeNode* targetNode, struct TreeNode** pareNode) 
{
    if (curNode == NULL) 
    {
        return;
    }
    if (curNode->left == targetNode || curNode->right == targetNode) 
    {
        *pareNode = curNode;
        return;
    }
    getParNode(curNode->left, targetNode, pareNode);
    getParNode(curNode->right, targetNode, pareNode);
}



//找到这个结点下面的目标结点
//curNode是目标结点  distCnt是走到这个结点需要的步数  returnSize是数组元素的个数  valK是可以走的步数  distRst是保存最终结果的数组
void preOrderCnt(struct TreeNode* curNode, int* distCnt, int* returnSize, int valK, int* distRst) 
{
    int tempDist = 0;
    if (curNode == NULL) 
    {
        return;
    }

    (*distCnt)++;      //先递增，因为传到下面的函数中就是distCnt
    tempDist = *distCnt;  

    if (*distCnt == (valK + 1))  //因为刚才递增过，所以是valK + 1
    {
        if (*returnSize < 500) 
        {
            distRst[*returnSize] = curNode->val;  //把这个结点的值输入到这个数组中
            *returnSize = *returnSize + 1;        //数组的长度递增1
        }
    }
    //因为传的是指针，会改变distCnt的值，所以要记录下来distCnt之前的值
    preOrderCnt(curNode->left, distCnt, returnSize, valK, distRst);
    *distCnt = tempDist;
    preOrderCnt(curNode->right, distCnt, returnSize, valK, distRst);
}

int* distanceK(struct TreeNode* root, struct TreeNode* target, int K, int* returnSize) 
{
    struct TreeNode* pareNode = NULL;
    struct TreeNode* tempTarget = NULL;
    int distCnt = 0;
    static int distRst[500] = {0};
    int pareNum = 0;

    *returnSize = 0;

    getParNode(root, target, &pareNode);  //找到目标节点的父节点pareNode，因为要改变pareNode的指向，所以要取地址
    tempTarget = target;

    //找到这个结点下面的目标节点
	preOrderCnt(target, &distCnt, returnSize, K, distRst);
    distCnt = 0;

    while (pareNode != NULL)  //目标节点的父节点pareNode，如果父节点是空，就代表是根结点
    {
        pareNum++;     //记录走的步数，因为pareNode是它的e父节点，从target走到pareNode需要一步，所以在之前需要递增

        //这个就是找父节点，父节点的父节点。。。。。，直到找到最后，把最后的输入到disRst中，break结束
        if (pareNum == K) 
        {
            //returnSize指向的是第一个可以填充数据的位置
            distRst[*returnSize] = pareNode->val;
            (*returnSize)++;
            break;
        } 


        //说的简单一点，就是处理需要拐一个弯再走一步才可以到达的，先从这个结点到达它的父节点，再从这个父结点到它另一个儿子
		//为啥不和下面写的合并，因为下面是(K - pareNum - 1) > 0   这里输出的是right的
        else if (pareNum == K - 1) 
        {
            if (pareNode->left == tempTarget && pareNode->right != NULL) 
            {
                distRst[*returnSize] = pareNode->right->val;
                (*returnSize)++;
            } 
            else if (pareNode->right == tempTarget && pareNode->left != NULL) 
            {
                distRst[*returnSize] = pareNode->left->val;
                (*returnSize)++;
            }
            //break;
        }

        //记住pareNode是它的父结点
        //拐一步输出它兄弟结果
        if (pareNode->left == tempTarget && (K - pareNum - 1) > 0)  //这个减一的目的就是k减去pareNode->right的一步，意思就是输出right以下的
        {
            //记得之前disCnt又被设为0
            preOrderCnt(pareNode->right, &distCnt, returnSize, (K - pareNum - 1), distRst);//第四个参数就是从这个结点开始，需要走的步数
            distCnt = 0;
        } 
        else if (pareNode->right == tempTarget && (K - pareNum - 1) > 0) 
        {
            preOrderCnt(pareNode->left, &distCnt, returnSize, (K - pareNum - 1), distRst);
            distCnt = 0;
        }
        
        //tempTarget储存原来父亲的结点
        tempTarget = pareNode;
        pareNode = NULL;   //因为之后要修改它，所以先让它指向空
        
        //pareNode储存tempTarget父亲的结点
        getParNode(root, tempTarget, &pareNode);
    }

    return distRst;
}

=====================================================================================================================
具有最深结点的最小子树——这是一个二叉树
就是找到最深的结点，输出它的父亲
/*
    下面这种写法是如果左子树等于右子树，则是最大深度
    我的想法记录下每一条路线的长度，如果有大于，则更新这个路线
    同时记录每一个结点的父节点，更新路线的同时更新这个父节点
*/


操操操  只要涉及左右儿子和父结点的就用左右非裸露函数呀
int max(int a, int b)
{
    return a > b ? a : b;
}

int depth(struct TreeNode *node)
{
    if(node == NULL ) 
        return 0;
    return max(depth(node->left),depth(node->right)) + 1;
}

struct TreeNode* subtreeWithAllDeepest(struct TreeNode* root)
{
         int diff = depth(root->left) - depth(root->right);
		 
         if(diff==0) 
            return root;
			
         else if(diff > 0)   //说明左边的深度大于右边的深度
         {
             return subtreeWithAllDeepest(root->left);
         }
         else               //说明左边的深度小于右边的e深度
         {
            return subtreeWithAllDeepest(root->right);
         }
}

————————————————————————————————————————————————————————————————————————————————————————————
我写的，也不知哪里错

struct TreeNode *father;
int deepest;

void GetIt(struct TreeNode *root, int deep, struct TreeNode *father)
{
    
    if(root == NULL)
        return ;
    
    if(root->left == NULL && root->right == NULL)
    {
        if(deep > deepest)
        {
            deepest = deep;
            &father = &root;
        }
    }
    GetIt(root->left, deep + 1, root);
    GetIt(root->right, deep + 1, root);
}



struct TreeNode *subtreeWithAllDeepest(struct TreeNode *root)
{
    TreeNode *father = NULL;
    int deepest = 0;
    
    GetIt(root, 0, NULL);
    
    return father;
}


=====================================================================================================================
叶子相似的树
判断两个树的从左到右的叶子是否相同
/*思路，先把两个root的叶子结点分别存在两个数组里面，然后再比较这两个数组的元素是否一致*/
void ordertraversal(struct TreeNode* root, int* leaf, int* count)
{
    if(root)
    {
        if(root->left == NULL && root->right == NULL)
        {
            leaf[*count] = root->val;
            (*count)++;
        }
        ordertraversal(root->left, leaf, count); //这里的count就不用&count，因为这里的count相当于指针了
        ordertraversal(root->right, leaf, count);
    } 
}
    
  
bool leafSimilar(struct TreeNode* root1, struct TreeNode* root2) 
{
    int leaf1[100] = {0}, leaf2[100] = {0}, i = 0, j = 0, count1 = 0, count2 = 0;
    ordertraversal(root1, leaf1, &count1);  //这种一般都要传地址，count的地址，传值就会出错
    ordertraversal(root2, leaf2, &count2); 
    while(i < count1 && j < count2 && count1 == count2 && leaf1[i++] == leaf2[j++]);

    //因为最后无论两个相不相等，i和j都要递增  所以要判断(leaf1[--i] != leaf2[--j])
	//否则如果一棵树是1  另一棵树是2就不行
    if((i < count1 || j < count2) || (leaf1[--i] != leaf2[--j])) 
        return false;
    else 
        return true;
}

=====================================================================================================================
根据前序和后序遍历构造二叉树
标准左右非裸露函数
struct TreeNode* constructFromPrePost(int* pre, int preSize, int* post, int postSize)
{
    if (pre == NULL || post == NULL || preSize <= 0)  //preSize和postSize是相等的
    {
        return NULL;
    }
    struct TreeNode *root = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    int i;
    root->val = pre[0];
    if (preSize == 1) 
    {
        root->left  = NULL;
        root->right = NULL;
    } 
    else 
    {
        for (i = 0; i < preSize - 1; i++) 
        {
            //找到中序遍历中这个点的位置
			if (post[i] == pre[1]) 
            {
                break;
            }
        }

        /*
                        1
                     /    \
                    2     5
                  /  \  /  \
                3    6 4   9
                         /  \
                        10  12

            中间竖杠的目的是把它分为左子树和右子树
            前序遍历： 1 2 3 6 | 5 4 9 10 12      1右边的2是1的左孩子
            后序遍历：3 6 2 | 4 10 12 9 5 1       1左边的5是1的右孩子
            i的意思是2在后序遍历中的位置，就是2
            pre + 1的意思是左子树根节点的位置  i + 1的意思是左子树有3个结点
            pre + i + 2的意思是右子树根节点的位置  preSize - i - 2的意思是右子树有5个结点

        */
        root->left  = constructFromPrePost(pre + 1, i + 1, post, i + 1);
        root->right = constructFromPrePost(pre + i + 2, preSize - i - 2, post + i + 1, preSize - i - 2);
    }
    return root;
}


=====================================================================================================================
所有可能的满二叉树
给出结点的个数，输出所有可能的满二叉树
排列组合
struct TreeNode** allPossibleFBT(int N, int* returnSize)
{
    int cnt = 0, cntL, cntR, sum = 0;
    struct TreeNode **forest = NULL, **newForest = NULL, **lForest, **rForest;
    if (N == 1) 
    {
        forest = calloc(1, sizeof(struct TreeNode*));
        forest[0] = calloc(1, sizeof(struct TreeNode));
        *returnSize = 1;
        return forest;
    }
    if (N%2 != 0) //结点的个数是奇数
    {
        for (int i = 1; i < N-1; i += 2) //因为是满二叉树，所以是i += 2;
        {
            //下面这步是实现左右子树结点的分配
            //lForest是左子树所有可能情况的二维数组    rForest是右子树所有可能情况的二维数组  
            //cntL是左子树可能情况的个数     cntL是右子树可能情况的个数 
            lForest = allPossibleFBT(i, &cntL);   //假设左边结点的个数是i
            rForest = allPossibleFBT(N - 1 - i, &cntR);  //右边结点的个数是N - 1 - i
            sum += cntL * cntR;   //排列组合  目的是知道分配多少内存

            newForest = realloc(forest, sum*sizeof(struct TreeNode*));

            if (newForest == NULL)    //如果动态内存分配失败
            {
                free(forest);
                return NULL;
            }
            
            //forest是输进来这个结点的二维数组
            forest = newForest;
            for (int j = 0; j < cntL; j++) 
            {
                for (int k = 0; k < cntR; k++) 
                {
                    //因为就是只存一个struct TreeNode的内存
                    forest[cnt] = calloc(1, sizeof(struct TreeNode));
                    forest[cnt]->left = lForest[j];
                    forest[cnt]->right = rForest[k];
                    cnt++;
                }
            }
        }
    }
    //返回二维数组的行数
    *returnSize = cnt;
    return forest;
}

=====================================================================================================================
//递增顺序查找树
/*
给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。

 

示例 ：

输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]

       5
      / \
    3    6
   / \    \
  2   4    8
 /        / \ 
1        7   9

输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9  
*/

//呜呜呜呜呜  它说我这个超出时间限制
struct TreeNode* _increasingBST(struct TreeNode* root)
{
    if((root->left == NULL && root->right == NULL) || (root->left == NULL))
    {
        return root;
    }

    if(root->right == NULL)
    {
        root->left->right = root;
        return root->left;
    }

    
    struct TreeNode* tmp_left = _increasingBST(root->left);
    struct TreeNode* tmp_right = _increasingBST(root->right);
    struct TreeNode* tmp_left1 = tmp_left;
	
    while(tmp_left1->right != NULL)
        tmp_left1 = tmp_left1->right;
    tmp_left1->right = root;

    return tmp_left;
    
}

struct TreeNode* increasingBST(struct TreeNode* root) {
    return _increasingBST(root);
}

——————————————————————————————————————————————————————————————————————————————————
/*
    
	中序遍历
	它的脑子是用金子做的吗
    我来简述以下它的意思
    下面这个函数的第二个参数是中序遍历root结点的下一个结点
    这个函数的意思就是先把root结点的左边弄成线线的，弄成线线的同时把最底下的右边弄成root，记得是指针，现在root就变成了它左边线线的最底端
    所以要把root的左边设置成NULL
    现在要处理root的右边了，记住pre是中序遍历它的下一个点，也就是root的父节点，如果右边是空的，就设成pre，如果右边不是空的，就让右边变成线线的
 */
struct TreeNode* _increasingBST(struct TreeNode* root, struct TreeNode* pre)
{
    if(!root)
    {
        return pre;
    }
    
    struct TreeNode* tmp = _increasingBST(root->left, root);
    root->left = NULL;
    if(root->right)
    {
        root->right = _increasingBST(root->right, pre);
    }
    else
    {
        root->right = pre;
    }
    return tmp;
}

struct TreeNode* increasingBST(struct TreeNode* root) 
{
    return _increasingBST(root, NULL);
}


——————————————————————————————————————————————————————————————————————————————————
=====================================================================================================================
非裸露函数 + 递归法 + 结点判断

//记住它给的是搜索二叉树，在L 和 R范围内的和
int rangeSumBST(struct TreeNode* root, int L, int R)
{
        //天哪，我就是一个笨蛋，我咋地就没想见了，root = NULL不要想那么多，就假设右一个结点，这个结点是NULL，应该返回啥就是啥
		if(root == NULL)
        {
            return 0;
        }
        if(root->val > R)
        {
            return rangeSumBST(root->left, L, R);
        } 
        else if(root->val < L)
        {
            return rangeSumBST(root->right, L, R);
        } 
        else 
        {
            return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);
        }
		
}


=====================================================================================================================
给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

struct TreeNode* searchBST(struct TreeNode* root, int val)
{
    
	//咱们来用逻辑理解一下，给了一个结点，首先要判断这个结点是不是空，接着再判断这个结点里的数据和给的数据相不相同，如果不相同，检查它的两个子树每一个点
	if(root == NULL)
        return NULL;
    if(root->val == val)
        return root;
    else if(root->val > val)
        return searchBST(root->left, val);  //返回它左子树查找的结果
    else
        return searchBST(root->right, val); //返回它右子树查找的结果
}

=====================================================================================================================
二叉搜索树结点的最小距离
//搜索二叉树中中序遍历的结果就是从小到大的顺序
int min;
struct TreeNode* pre;

//这个是main函数
int minDiffInBST(struct TreeNode* root)
{
    min = 0x3f3f3f3f;
    pre = NULL;
    dfs(root);
    return min;
}

int dfs(struct TreeNode* root)
{
    if (root == NULL)
        return 0;
    dfs(root->left);
    if (pre != NULL) 
    {
        if (min > (root->val - pre->val)) 
        {
            min = root->val - pre->val;
        }
    }
    pre = root;
    dfs(root->right);
    return 0;
}

=====================================================================================================================
二叉树的最大宽度
就是把这个树画成满二叉树时，这每一行的最大宽度
/*给所有的节点进行编号（从1开始，空节点也编号），递归，若某个节点的编号为n,则左子节点编号为2n，
右子节点为2n+1，将该层起始第一个非空节点的编号保存下来记为j, 
则该层编号为k的节点，二者间的宽度为k-j+1，该层所有节点的宽度最大值即为该层宽度*/


#define MAX_INT 2147483648

void getTreeDepath(struct TreeNode* node, unsigned int iDepath, unsigned int *maxDepath)
{
    if(NULL == node) 
        return;
    (*maxDepath) = (*maxDepath) > iDepath ? (*maxDepath):iDepath;

    //我忽然发现一个极其聪明的事情，如果在左右递归之前写的就是前序遍历，意思也就是测试结点的顺序就是前序遍历的结果
    //中序遍历和后序遍历同理
    getTreeDepath(node->left, iDepath+1, maxDepath);
    getTreeDepath(node->right, iDepath+1, maxDepath);
}

void traversalTree(struct TreeNode* node, int *maxWidth, int depath, int index, int a[])
{
    if(NULL == node) 
        return;
    
    //因为是前序遍历，所以在depath还没有存值的时候让它保存的肯定是每一行的第一个
    if(a[depath] == 0)
    {
        //这个数组的目的就是记录每一行第一个结点的下标
        a[depath] = index;
    }
    
    /*
            1
          /  \
         2   3     3 - 2 = 1    1 + 1 = 2
    */
    int width = index - a[depath] + 1;
    
    //f更新最大宽度
    *maxWidth = (*maxWidth) > width ? (*maxWidth):width;


    //这个的目的是控制树的最大范围，如果它是有左孩子的，说明它底下还有一层，这一层最大是Max_INT,但它比这个还大m，就不符合题意返回
    if(NULL != node->left && index > (MAX_INT/2)) 
        return;
    if(NULL != node->right && index > ((MAX_INT)/2)) 
        return;

    traversalTree(node->left, maxWidth, depath+1, 2*index, a);
    traversalTree(node->right, maxWidth, depath+1, 2*index + 1, a);
}

int widthOfBinaryTree(struct TreeNode* root)
{
    int maxWidth = 0;
    int depath = 0;
    int index = 1;
    int *a = NULL;
    unsigned int maxDepath = 0; //深度是从0开始

    //下面这个函数完成之后就知道了maxDepath，知道maxdepth的目的主要是为了分配内存
    getTreeDepath(root, depath, &maxDepath);

    
    //最大深度是从0开始的
	a = (int *)malloc((maxDepath+1)*sizeof(int));

    if(NULL == a) 
        return 0;

    //将a数组中(maxDepath+1)*sizeof(int)大小的内存全部初始化为0，就是数组的初始值都是0
    memset(a, 0, (maxDepath+1)*sizeof(int));

    traversalTree(root, &maxWidth, depath, index, a);

    return maxWidth;
}

=====================================================================================================================
修剪搜索二叉树
把不在L R范围内的结点修剪掉
//记住：这是一棵搜索二叉树，可以利用搜索二叉树的性质
/*
    搜索二叉树分为三个部分，分别是父结点，左孩子，右孩子
    这个函数的目的就是去掉不在范围内的
    首先判断父结点在不在范围内f，如果父结点比范围小，只有它右边才可能在范围里，返回右边，左边同理

*/

又是典型的左右非裸露函数
struct TreeNode* trimBST(struct TreeNode* root, int L, int R)
{
    //要处理好两个过程，一个是结点向下遍历的过程，也就是两个递归，前序遍历的过程
	//一个是递归结果返回，也就是后序遍历的过程
	if(root == NULL)
        return NULL;
		
    if(root->val < L)
        return trimBST(root->right, L, R);
		
    else if(root->val > R)
        return trimBST(root->left, L, R);
		
    root->left = trimBST(root->left, L, R);
    root->right = trimBST(root->right, L, R);

    return root;
}

=====================================================================================================================
二叉树中第二小的结点
且父结点的值小于等于左右儿子的值

/*
	不说啦，老泪纵横，我终于懂了递归了、
	                   1
                     /   \
                    2     5
                  /  \  /  \
                3    6 4    9
                           / \
                          10 12

            中间竖杠的目的是把它分为左子树和右子树
            前序遍历：1 2 3 6 5  4  9  10 12      
            后序遍历：3 6 2 4 10 12 9  5  1			
			中序遍历：3 2 6 1 4  5  10 9 12
	
	咱们先把递归分成三部分：前序遍历的样子  中序遍历的样子  后序遍历的样子
	遍历的结果只是代表结点遍历的顺序，跟val的值无关，返回值的意思就是从这个结点返回到遍历的上一个结点中
	前序遍历只是测试顺序  后序遍历是定值返回顺序，也就体现一种从底层到上头的思想将底层的每一个都处理了
	返回到最高统治者的就是结果	
*/

int findSecondMinimumValue(struct TreeNode* root)
{
    return myfun(root, root->val);
}

int myfun(struct TreeNode* root, int val)
{
    //其实下面这个判断是否为空就包含两层含义，一层是这个根节点就为空，返回-1表示出错
	//如果是在遍历过程中，表示这一支没找到
	//这一支代表以一个结点开始，到它的左孩子为空或右孩子为空  或  左右孩子为空 时结束
	//这时候需要返回值，代表的意思就是这一支寻找的结果，如果一直都没有找到，就会一直返回=1
	//如果期间找到了，就会返回一个特定的值
	
	//当左边的左孩子为空时将要返回上一个结点，这个结点又要寻找它的右孩子
	//这时后序遍历就开始出现，所以先开始测试的两个值就是结点3和结点6，也就是l的值就是结点3测试的结果，r就是结点6测试的结果
	//这两个结点完成比较的结果之后返回给2，则下一个测试的l和r就是2和4，直到返回到1结束


    //所以俺的得出一个结论：前序遍历的目的就是给left一个值，相当于一个	
	if(root == NULL)
        return -1;  //表示错误
		
	//只要有一个比val大，那它肯定是第一个大于val的数
	
	///写在非裸露函数前面的是条件满足什么条件，返回什么值
    if(root->val > val)
        return root->val;
    
    /*
        卧槽，我滴娘嘞，我终于知道了，原来递归这么难
        在这两个递归前面的是先序遍历，先序遍历的目的就是为了找出这两个子树中
        比父结点大的

    */
    int l = myfun(root->left, val);
    int r = myfun(root->right, val);
    //这个是后序遍历，后序遍历的目的就是返回第二小的结点
    if(l > val && r > val)
    {
        return l > r ? r : l;
    }
    //如果没有找到是返回-1的，所以要取两个里面较大的
	//就是结点的左边全是1，右边有比结点大的
    return l > r ? l : r;
}






=====================================================================================================================

亢余连接
在本问题中, 树指的是一个连通且无环的无向图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。

示例 1：

输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3


示例 2：

输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3


注意:


	输入的二维数组大小在 3 到 1000。
	二维数组中的整数在1到N之间，其中N是输入数组的大小。

#define MAXNUM 10001
int UF[MAXNUM];
int UFSize[MAXNUM];

void initialUF(int *UF, int num) 
{
    int i = 0;
    for (i = 0; i < MAXNUM; i++) 
    {
        UF[i] = i;
        UFSize[i] = 0;
    }
}

int root(int num) 
{
    while(UF[num] != num) 
    {
        num = UF[num];
    }
    return num;
}

int Find(int a, int b) 
{
    return root(a) == root (b);
}

void Union(int a, int b) 
{   
    /*
        我大概懂了：
        我当时困扰的点就是如何表示树的双向问题，其实大可不必关心双向，直接把它改成单向
             1
            / \
          2    3

        接下来的问题就是单向是2指向1还是1指向2，是3指向1还是1指向3  看图来说是1指向2，1指向3
        所以UFSize的意思就是这个结点的儿子个数，让儿子个数多的指向儿子个数少的，同时儿子把它的UF设置成根节点
        只要有环，根节点就会重合，输出这个点 
    
    */
    a = root(a);
    b = root(b);
    if (UFSize[a] < UFSize[b]) 
    {
        UF[a] = b;
        UFSize[b] += UFSize[a];
    } 
    else 
    {
        UF[b] = a;
        UFSize[a] += UFSize[b];
    }
}

int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize)
{
    int i = 0;

    //返回最后数组的大小是2
    * returnSize = 2;
    //因为最后返回数组的大小是2，所以分配的大小也是2
    int *ret = malloc(sizeof(int) * 2);

    //初始化UF[i] = i;   UFSize[i] = 0;
    initialUF(UF, MAXNUM);
    int a = 0;
    int b = 0;

    //edgesSize是数组的行数
    for (i = 0; i < edgesSize; i++) 
    {
        //a分别是每一行第一个和第二个数字
        a = edges[i][0];
        b = edges[i][1];

        if (!Find(a, b)) //如果这两个的根不是一个根
        {
            Union(a, b);
        } 
        else 
        {
            ret[0] = a;
            ret[1] = b;
            return ret;
        }
    }
    return ret;
}

=====================================================================================================================
给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

注意：两个节点之间的路径长度由它们之间的边数表示。

示例 1:

输入:

              5
             / \
            4   5
           / \   \
          1   1   5


输出:

2


示例 2:

输入:

              1
             / \
            4   5
           / \   \
          4   4   5


输出:

2

int ans;

int longestUnivaluePath(struct TreeNode* root) 
{
        ans = 0;
        arrowLength(root);
        return ans;
}
int arrowLength(struct TreeNode* node) 
{
        if (node == NULL) 
            return 0;
			
        int left = arrowLength(node->left);
        int right = arrowLength(node->right);
		
        int arrowLeft = 0, arrowRight = 0;
        /*
                 5
                / \
               4   5

            left的意思是左边的路径长 ， + 1的意思是加上5-4
			我懂啦，像这种写在左右非裸露递归下面的是从下头往上推，就是已知右边和左边
			如何推出root，而这个root又作为上一个的left或right
			
			arrowLeft 和 arrowRight 是临时变量，用来表示回到root时连续路径的长度
			如果不连续为0，连续为  left / right + 1
        */

        if (node->left != NULL && node->left->val == node->val) 
            arrowLeft += left + 1;
        
        if (node->right != NULL && node->right->val == node->val) 
        {
            arrowRight += right + 1;
        }
		
		//更新ans的值
        ans = ans > (arrowLeft + arrowRight) ? ans : (arrowLeft + arrowRight);
		
		//记住这个是求左边或者右边的最大值，因为路径肯定是一条线，只能取左边或者右边
        return arrowLeft > arrowRight ? arrowLeft : arrowRight;
}






————————————————————————————————————————————————————————————————————————————————————



=====================================================================================================================
另一个树的子树
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

示例 1:
给定的树 s:

     3
    / \
   4   5
  / \
 1   2


给定的树 t：

   4 
  / \
 1   2


返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

bool a_gain(struct TreeNode* s,struct TreeNode* t) //判同
{
    if(s == NULL && t == NULL) 
        return true;
		
    if(s == NULL || t == NULL) 
        return false;
		
    if(s->val != t->val) 
        return false;
		
    return a_gain(s->left,t->left) && a_gain(s->right,t->right);
}

bool isSubtree(struct TreeNode* s, struct TreeNode* t)
{
    if((s == NULL && t != NULL) || (s != NULL && t == NULL)) 
        return false;
	
    //这个的意思就是有可能它符合题意  有可能它的儿子符合题意  如果只写a_gain表明只有他的根节点符合题意
    return a_gain(s,t) || isSubtree(s->left,t) || isSubtree(s->right,t);  //判同 判左 判右
}



————————————————————————————————————————————————————————————————————————————————————
bool isSubtree(struct TreeNode* s, struct TreeNode* t)
{
    if(s == NULL && t == NULL)
        return true;
    if(s == NULL || t == NULL)
        return false;

	return ( (s->val == t->val) && isSubtree(s->left, t->left) && isSubtree(s->right, t->right) ) || (isSubtree(s->left, t) || isSubtree(s->right, t));
    
   
}

===========================================================================================================================
根据二叉树创建字符串
就是括号形式的二叉树
void travel(struct TreeNode* node, char *val)
{
    char buf[100];
    
    if(!node) 
        return;

    //咱先不用去深究sprinf和strcat是啥意思，咱只要知道他是把val输进去就行了
    sprintf(buf, "%d", node->val);
    strcat(val, buf);
	
    //process left child and right child
    if(node->left || node->right)
    {
        //如果左边存在或左边不存在都是下面这个样子的
        strcat(val, "(");
        travel(node->left, val);
        strcat(val, ")");

        //right() is optional
        if(node->right)
		{
            strcat(val, "(");
            travel(node->right, val);
            strcat(val, ")");
        }
    }
}
char * tree2str(struct TreeNode* t)
{
    char *result = (char*)malloc(32768);
    result[0] = 0;

    travel(t, result);
    
    return result;
}

===========================================================================================================================
合并二叉树
把两个二叉树重叠，重合部分相加
struct TreeNode* mergeTrees(struct TreeNode* t1, struct TreeNode* t2)
{
    
	if(t1 == NULL)
        return t2;
    if(t2 == NULL)
        return t1;

    t1->val += t2->val;
    
    if(t1->left != NULL && t2->left != NULL)
    {
        mergeTrees(t1->left, t2->left);
    }
    else if(t1->left == NULL && t2->left != NULL)
    {
        t1->left = t2->left;
    }

    if(t1->right != NULL && t2->right != NULL)
    {
        mergeTrees(t1->right, t2->right);
    }
    else if(t1->right == NULL && t2->right != NULL)
    {
        t1->right = t2->right;
    }

    return t1;

}

===========================================================================================================================
在二叉树中添加一行
示例 1:

输入: 
二叉树如下所示:
       4
     /   \
    2     6
   / \   / 
  3   1 5   

v = 1

d = 2

输出: 
       4
      / \
     1   1
    /     \
   2       6
  / \     / 
 3   1   5   



示例 2:

输入: 
二叉树如下所示:
      4
     /   
    2    
   / \   
  3   1    

v = 1

d = 3

输出: 
      4
     /   
    2
   / \    
  1   1
 /     \  
3       1

void add(struct TreeNode* root, int v, int h,int d)
{
    if(root == NULL)
        return ;
    if(h + 1 == d)
    {
        struct TreeNode* l = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        struct TreeNode* r = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        l->val = v;
        l->left = root->left;
        l->right = NULL;
        r->val = v;
        r->left = NULL;
        r->right = root->right;
        root->left = l;
        root->right = r;
    }
    add(root->left,v,h+1,d);
    add(root->right,v,h+1,d);
}
struct TreeNode* addOneRow(struct TreeNode* root, int v, int d) //v是添加的数字，d是添加的行数
{
    //t如果要添加的数字就在第一行，把它左边设置成根节点，右边设置为空，直接返回a
    if(d == 1)
    {
        struct TreeNode* a = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        a->val = v;
        a->left = root;
        a->right = NULL;
        return a;
    }
    add(root,v,1,d);
    return root;
}

===========================================================================================================================
二叉树的层平均值
#define MAXSIZE 1024 
#define MAX(a,b) ((a) > (b) ? (a) : (b))

void dfs(struct TreeNode* root, double *res, int *cnt, int idx, int *returnSize) 
{
    if (root == NULL) 
        return;
    
    res[idx] += (double)root->val;
    cnt[idx]++;
	
	//这里的index = 0主要的目的就是为了和数组匹配，但是returnSize是个数得加1
    (*returnSize) = MAX(*returnSize, idx + 1);  //因为不但d要递归，还要回溯，回溯的时候returnsize就会变
    dfs(root->left, res, cnt, idx + 1, returnSize);
    dfs(root->right, res, cnt, idx + 1, returnSize);
}

double* averageOfLevels(struct TreeNode* root, int* returnSize)
{
    if (root == NULL) 
    {
        *returnSize = 0;
        return NULL;   //记着，假如这个二叉树是空的话，返回的类型是double*，所以是NULL
    }

    double *res = (double*)malloc(sizeof(double) * MAXSIZE);
    int *cnt = (int*)malloc(sizeof(int) * MAXSIZE);

    int i;
    for (i = 0; i < MAXSIZE; i++) 
    {
        res[i] = 0.0;
        cnt[i] = 0;
    }
    
    *returnSize = 0;
    dfs(root, res, cnt, 0, returnSize);
    for (i = 0; i < (*returnSize); i++) 
    {
        res[i] /= cnt[i];
    }
    free(cnt);
    return res;
}

===========================================================================================================================
最大二叉树


给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：


	二叉树的根是数组中的最大元素。
	左子树是通过数组中最大值左边部分构造出的最大二叉树。
	右子树是通过数组中最大值右边部分构造出的最大二叉树。


通过给定的数组构建最大二叉树，并且输出这个树的根节点。

 

示例 ：

输入：[3,2,1,6,0,5]
输出：返回下面这棵树的根节点：

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1



struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize)
{
    //当这个数组里没有数字的时候，返回空
    if(numsSize <= 0) 
    {
        return NULL;
    }
    struct TreeNode *root = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    //初始化指针数组就用这种方法
    memset(root, 0, sizeof(sizeof(struct TreeNode)));
    
    int max = 0;  //最大值的下标
    //寻找出最大值的下标
    for(int i=1; i<numsSize; i++) 
    {
        if(nums[max] < nums[i]) 
        {
            max = i;
        }
    }
    
    root->val = nums[max];
    root->left = constructMaximumBinaryTree(nums, max);
    root->right = constructMaximumBinaryTree(nums+max+1, numsSize-max-1);
    return root;    
}


===========================================================================================================================
输出二叉树
输入:
     1
    /
   2
输出:
[["", "1", ""],
 ["2", "", ""]]


示例 2:

输入:
     1
    / \
   2   3
    \
     4
输出:
[["", "", "", "1", "", "", ""],
 ["", "2", "", "", "", "3", ""],
 ["", "", "4", "", "", "", ""]]


示例 3:

输入:
      1
     / \
    2   5
   / 
  3 
 / 
4 
输出:
[["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]
 ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]
 ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]
 ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]

/*
    C语言版本，求树的高度m，矩阵的宽度n=2^（m - 1）-1； 创建初始化字符串，利用分制思想进行字符串处理
    这里的m是从1开始的
*/
int depthOfTree(struct TreeNode* root) 
{
    if (root == NULL) 
    {
        return 0;
    }
	
    int left  = depthOfTree(root->left);
    int right = depthOfTree(root->right);
	
    return left > right ? left + 1 : right + 1;
}

void dfs(struct TreeNode* root, char ***res, int idx, int start, int end) 
{
    if (root == NULL || start > end) 
    {
        return;
    }
    int mid = start + (end - start) / 2;
    sprintf(res[idx][mid], "%d", root->val);
    dfs(root->left, res, idx + 1, start, mid - 1);
    dfs(root->right, res, idx + 1, mid + 1, end);
}

char *** printTree(struct TreeNode* root, int* returnSize, int** returnColumnSizes)
{
    //当结点h是空的情况
    if (root == NULL) 
    {
        *returnSize = 0;
        return NULL;
    }

    //m是树的深度，是从1开始数的
    int m = depthOfTree(root);

    //这个是树的宽度，其实本来的算法公式是2^m-1
    //注意这个移动2 << 1, 就是4，所以本来的m变成了m - 1
    int n = (2 << (m - 1)) - 1;  
    *returnSize = m;

    //我实在是不理解她内存是如何分配的
    char ***res = (char***)malloc(sizeof(char**) * m);
    *returnColumnSizes = (int*)malloc(sizeof(int) * m);
    int i, j;
    for (i = 0; i < m; i++) 
    {
        (*returnColumnSizes)[i] = n;  
        res[i] = (char**)malloc(sizeof(char*) * n);
        for (j = 0; j < n; j++) 
        {
            res[i][j]    = (char*)malloc(sizeof(char) * 10);
            res[i][j][0] = '\0';
        }
    }

    //这里n - 1是指最后一个元素
    dfs(root, res, 0, 0, n - 1);
    return res;
}


===========================================================================================================================
两数之和
/*
    给定一个二叉搜索树和一个目标结果，看这个树里有没有两个数的和等于这个目标结果
    因为是二叉搜索树，所以中序遍历的结果就是从小到大的排列，这时候就可以使用双指针
	按照数组的方法做
*/



#define MAXSIZE 10000
void inorder(struct TreeNode* root, int *res, int *size) 
{
    if (root == NULL) 
    {
        return;
    }
    inorder(root->left, res, size);
    res[(*size)++] = root->val;
    inorder(root->right, res, size);
}

bool findTarget(struct TreeNode* root, int k)
{
    if (root == NULL) 
    {
        return false;
    }
    int *res = (int*)malloc(sizeof(int) * MAXSIZE);
    int size = 0;
    int i, j;
    inorder(root, res, &size);
    i = 0;
    j = size - 1;
    while (i < j) 
    {
        if (res[i] + res[j] == k) 
        {
            return true;
        } 
        else if (res[i] + res[j] > k) 
        {
            j--;
        } 
        else 
        {
            i++;
        }
    }
    free(res);
    return false;
}

===========================================================================================================================
找树左下角的值
//给定一个二叉树，在树的最后一行找到最左边的值
/*
        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

*/
int max = -999999;
int res;

void dfs(struct TreeNode* node, int depth)
{
    if(node != NULL)
    {
        if(node->left == NULL && node->right == NULL)
        {
            if(max < depth)
            {
                max = depth;
                res = node->val;
            }
        }

        dfs(node->left, depth + 1);
        dfs(node->right, depth + 1);
    }
}




int findBottomLeftValue(struct TreeNode* root)
{
    dfs(root, 0);
    return res;
}

===========================================================================================================================
在每一行中找出最大的值，输入到一个数组中
#define max(a,b)  (a)>(b)?(a):(b)

//树的高度未知，可以先求解树的高度，按照高度开数组对应存储每层max
int TreeHeight(struct TreeNode* node)
{
    if(node == NULL) 
        return 0;
    int lh = TreeHeight(node->left);
    // printf("%d--",node->val);
    int rh = TreeHeight(node->right);
    return (lh > rh ? lh : rh) + 1;
}

void bfs(struct TreeNode* node, int *res, int resLevel)
{
    if(node==NULL) 
        return;

    res[resLevel] = max(res[resLevel], node->val);
    
    bfs(node->left, res, resLevel+1);
    bfs(node->right, res, resLevel+1);
}

int* largestValues(struct TreeNode* root, int* returnSize){

    int h = TreeHeight(root); // 求树的高度
    *returnSize = h;
    // printf("\n%d",INT_MIN);
    int resLevel = 0;
    int *res = (int*)malloc(sizeof(int) * h); // 开个数组，对应记录每一层的最大值
    // (void)memset(res, 0, sizeof(int)*h);  // 初始化0不行，val可能为负数
	
    for(int i=0;i<h;i++) 
	{
        res[i] = INT_MIN;
    }
   
    bfs(root, res, resLevel);

	return res;
}

===========================================================================================================================
//二叉搜索树的最小绝对差
#define MIN(a,b) ((a) < (b) ? (a) : (b)) 
void inorder(struct TreeNode* root, int *pre, int *min) 
{
    if (root == NULL) 
    {
        return;
    }
    inorder(root->left, pre, min);
	
    if ((*pre) != -1) 
    {
        *min = MIN(*min, root->val - (*pre));
    }
    (*pre) = root->val;
	
    inorder(root->right, pre, min);
    return;
}

int getMinimumDifference(struct TreeNode* root)
{
    int min = INT_MAX;
    int pre = -1;
    inorder(root, &pre, &min);
    return min;
}

===========================================================================================================================
把二叉搜索树转化为累加树
给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

例如：

输入: 二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13

		  13 5 2
/*
    中序遍历是从小到大排列，反向中序遍历是从大到小排列，把之前的累加，加到这个结点上就可以
*/

void accBST(struct TreeNode *root, int *sum)
{
    if (NULL == root) 
        return;

    accBST(root->right, sum);

    *sum += root->val;
    root->val = *sum;

    accBST(root->left, sum);
}

struct TreeNode* convertBST(struct TreeNode* root)
{
    int sum = 0;
    accBST(root, &sum);
    return root;
}

===========================================================================================================================
二叉树的直径
/*
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    


返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。

*/

int calMaxRoot(struct TreeNode* root, int *maxRoot)
{
    if (NULL == root) 
        return 0;
    int lLen = calMaxRoot(root->left, maxRoot);
    int rLen = calMaxRoot(root->right, maxRoot);
    if (lLen + rLen > *maxRoot) 
        *maxRoot = lLen + rLen;
    //我懂了，为啥返回的是下面的这个，因为lLen = calMaxRoot(root->left, maxRoot);所以这个计算出的就是左边或右边长度的最大值
    return (lLen > rLen ? lLen : rLen) + 1;
}

int diameterOfBinaryTree(struct TreeNode* root)
{
    int maxRoot = 0;
    calMaxRoot(root, &maxRoot);
    return maxRoot;
}

===========================================================================================================================
二叉树的坡度
/*
给定一个二叉树，计算整个树的坡度。

一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。

【整个树的坡度】就是其所有节点的坡度之和。

示例:

输入: 
         1
       /   \
      2     3
输出: 1
解释: 
结点的坡度 2 : 0
结点的坡度 3 : 0
结点的坡度 1 : |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1

*/

#define ABS(a,b) ((a) > (b) ? ((a) - (b)) : ((b) - (a)))

int calcTilt(struct TreeNode* root, int *sum) 
{
    if (root == NULL) 
    {
        return 0;
    }
    int left  = calcTilt(root->left, sum);
    int right = calcTilt(root->right, sum);
    *sum += ABS(left, right);
    return root->val + left + right;
}

int findTilt(struct TreeNode* root)
{
    if (root == NULL) {
        return 0;
    }
    int sum = 0;
    calcTilt(root, &sum);
    return sum;
}

===========================================================================================================================
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
DFS
DFS(Depth-First-Search)深度优先搜索算法，是搜索算法的一种。
是一种在开发爬虫早期使用较多的方法。它的目的是要达到被搜索结构的叶结点 。

出现次数最多的子树元素和
/**
给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。

 

示例 1
输入:

  5
 /  \
2   -3


返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。

示例 2
输入:

  5
 /  \
2   -5


返回 [2]，只有 2 出现两次，-5 只出现 1 次。
 */
#define LEN sizeof(struct myHash)
struct myHash {
    int val;
    int num;
};
int maxNum = INT_MIN;

//哈希表的建立与输入
//最后得到的结果就是和  和  这个和所出现的次数

void PutInHash(int val, struct myHash *hashSet)
///下面的步骤主要是为了找到位置hash，和在这个位置添加值val
{
    //如果是正数的建立规则，直接等于val % 10000
    int hash = val % 10000;

    //如果是负数的建立规则
    if (val < 0) 
    {
        hash = (-(val + 1)) % 10000;
    }

    //这个位置以前已经添加过东西而且这个位置所包含的和不是val，处理冲突的方法
    while (hashSet[hash].num != 0 && hashSet[hash].val != val) 
    {
        hash++;
        if (hash >= 10000) 
        {
            hash = 0;
        }
    }

    //hash 是根据val（总和）所求的，hash表分成两部分 总和val 这个总和的个数
    hashSet[hash].val = val;
    hashSet[hash].num++;

    //更新最大次数的值
    maxNum = (maxNum < hashSet[hash].num ? hashSet[hash].num : maxNum);
}
int Dfs(struct TreeNode* root, struct myHash *hashSet)
{
    int left = 0;
    int right = 0;
    int sum = 0;

    if (root == NULL) 
    {
        return 0;
    }

    //这样遍历的末尾是根节点
    if (root->left != NULL) 
    {
        left = Dfs(root->left, hashSet);
    }
    if (root->right != NULL) 
    {
        right = Dfs(root->right, hashSet);
    }
    sum = root->val + left + right;
    PutInHash(sum, hashSet);
    return sum;
}
int* findFrequentTreeSum(struct TreeNode* root, int* returnSize)
{
    struct myHash *hashSet = NULL;
    int rootVal = 0;
    int *result = NULL;
    int resultLen = 0;
    
    if (root == NULL) 
    {
        *returnSize = 0;
        return NULL;
    }
    maxNum = INT_MIN;

    hashSet = (struct myHash *)malloc(LEN * 10000);
    //把hashSet结构当中 val 和 num 的值全部初始化为0
    memset(hashSet, 0x0, LEN * 10000);

    Dfs(root, hashSet);

    result = (int *)malloc(sizeof(int) * 10000);
    memset(result, 0x0, sizeof(int) * 10000);

    for (int i = 0; i < 10000; i++) 
    {
        if (hashSet[i].num == maxNum) 
        {
            result[resultLen++] = hashSet[i].val;
        }
    }
    free(hashSet);
    *returnSize = resultLen;
    return result;
}

===========================================================================================================================
二叉搜索树中的众数
/*
    大于更换，等于添加
*/

//目的是给array赋值
void find(struct TreeNode* root, int *array, int *max, int *count, int *data, int *i)
{
    if (!root)
        return ;
    else
    {
        //中序遍历的结果是从小到大的顺序
        find(root->left, array, max, count, data, i);

        //count最开始初始化为1，代表的是现有元素的个数，如果下一个和data的值相同，count递增
        if (root->val == *data) 
        {
            *count = *count + 1;
        }

        //data != -99999主要是为了防止最开始的时候执行这一条
        else if (root->val != *data && *data != -99999)
        {
            //当出现第一个不等于data的值的时候
            //如果count的值大于max，则需要更改之前的数据
            if (*count > *max)
            {
                *max = *count;
                *i = 0;
                array[*i] = *data;
                *i = *i + 1;
            }
            //如果count的值等于，说明不需要更改只需要把这个数据添后面
            else if (*count == *max)
            {
                array[*i] = *data;
                *i = *i + 1;
            }
            *count = 1;
        }

        //最开始的时候执行的是这一条，给data赋值
        *data = root->val;
        find(root->right, array, max, count, data, i);
    }
}

int* findMode(struct TreeNode* root, int* returnSize)
{
    //根节点为空的情况
    if (root == NULL)
    {
        *returnSize = 0;
        return NULL;
    }
    int *array = malloc(sizeof(int) * 10000);
    int i, max = 0, count = 1, data = -99999;
    find(root, array, &max, &count, &data, &i);

    //最后一次的输进去
    if (count == max)
    {
        array[i] = data;
        i++;
    }
    else if (count > max)
    {
        i = 0;
        array[i++] = data;
    }

    *returnSize = i;
    return array;
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
===========================================================================================================================
左子叶之和
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

int getLeftLeaves(struct TreeNode* root)
{
    if(root == 0)
        return 0;
    if(root->left != NULL)
    {
        if(root->left->left == NULL && root->left->right == NULL)
             return root->left->val + getLeftLeaves(root->left) + getLeftLeaves(root->right);
    }
    return getLeftLeaves(root->left) + getLeftLeaves(root->right);
}
__________________________________________________________________________________________________________________
我觉着这样写会好些

int sum;
void getLeftLeaves(struct TreeNode* root)
{
    if(root == 0)
        return 0;
    
    if(root->left != NULL && root->left->left == NULL && root->left->right == NULL)
    {
        sum += root->left->val;
    }
    
    getLeftLeaves(root->left);
    getLeftLeaves(root->right);
   
}





int sumOfLeftLeaves(struct TreeNode* root)
{
   sum = 0;
   getLeftLeaves(root);
   return sum;
}
===========================================================================================================================
路径总和
给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

示例：

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11


int pathnumber;
int pathSum(struct TreeNode* root, int sum)
{
    if(root == NULL)
        return 0;
    Sum(root,sum);
    pathSum(root->left, sum);
    pathSum(root->right, sum);
    return pathnumber;
}

void Sum(struct TreeNode* root, int sum)
{
    //注意：这个是有负数的
    if(root == NULL) 
        return;

    sum -= root->val;
    if(sum == 0)
        pathnumber++;           
    
    Sum(root->left,sum);
    Sum(root->right,sum);




===========================================================================================================================
/*
        删除二叉搜索树中的结点
给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：


	首先找到需要删除的节点；
	如果找到了，删除它。


说明： 要求算法时间复杂度为 O(h)，h 为树的高度。

示例:

root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7


*/

struct TreeNode* min(struct TreeNode* node) 
{
        if (node->left == NULL) 
        {
            return node;
        }
        return min(node->left);
}

struct TreeNode* deleteMin(struct TreeNode* node) 
{
    if (node->left == NULL) 
    {
        return node->right;
    }
    node->left = deleteMin(node->left);
    return node;
}

struct TreeNode* deleteNode(struct TreeNode* root, int key)
{
    /*
        啥意思：这不同于root->left = deleteNode(root->left, key);   root->right = deleteNode(root->right, key);
        如果写成上面那样，是上面两条都执行  如果按照下面的形式写，是只执行一条 其实就是找出一条从根结点开始一直到待删除结点的一条线
        返回就是  当作上一个结点的左子树或右子树  又因为类似于后序遍历，所以返回的是root结点
    
    */
    //待删除节点为空的情况
	
	//return应该是返回删除后的结果
    if (root == NULL) 
    {
        return NULL;
    } 

    if (key < root->val) 
    {
        // 待删除节点在左子树中
        root->left = deleteNode(root->left, key);
        return root;
    } 
    else if (key > root->val) 
    {
        // 待删除节点在右子树中
        root->right = deleteNode(root->right, key);
        return root;
    } 

    //找到了要删除的结点
    else 
    {
        // key == root.val，root 为待删除节点
        if (root->left == NULL) 
        {
            // 返回右子树作为新的根
            return root->right;
        } 
        else if (root->right == NULL) 
        {
            // 返回左子树作为新的根
            return root->left;
        } 
        else 
        {
            // 左右子树都存在，返回后继节点（右子树最左叶子）作为新的根
            struct TreeNode* successor = min(root->right);
            successor->right = deleteMin(root->right);
            successor->left = root->left;
            return successor;
        }
    }
}


===========================================================================================================================
打家劫舍

/*
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。
这个地区只有一个入口，我们称之为“根”。 
除了“根”之外，每栋房子有且只有一个“父“房子与之相连。
一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 
如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

示例 1:

输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

示例 2:

输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.

*/


#define MAX(a,b) (a>b?a:b)
int rob(struct TreeNode* root)
{
    //结点是空的情况
    if (root == NULL) 
    {
        return 0;
    }

    /*
        让聪明的姿姿解释一下这个是为什么？
        后序遍历按逻辑，假设这个递归是算钱数的
        算出爸爸的钱  和   爷爷和儿子的钱
        比较
        因为要偷最多的钱，所以要返回两者之间最大的那个
    */
    //爸爸的钱
    int notSteal = rob(root->left) + rob(root->right);
    int steal = 0;
    int stealLeft = 0;
    int stealRight = 0;

    
    if (root->left) 
    {
        stealLeft = rob(root->left->left) + rob(root->left->right);
    }
    if (root->right) 
    {
        stealRight = rob(root->right->left) + rob(root->right->right);
    }

    //爷爷和孙子的钱
    steal = root->val + stealLeft + stealRight;
    return MAX(notSteal, steal);
}


===========================================================================================================================

二叉搜索树中第k小的元素

int gret[10000],gnum,gk;
void dfs(struct TreeNode* root)
{
    if (root == NULL || gnum >= gk)
        return;
    dfs(root->left);
    gret[gnum++] = root->val;
    dfs(root->right);
}
int kthSmallest(struct TreeNode* root, int k)
{
    gnum = 0;
    gk = k;
    dfs(root);
    return gret[k-1];
}

===========================================================================================================================
/*
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

                 6
            /        \
          2           8
        /   \       /  \
      0     4      7   9
          /  \
        3    5

 

示例 1:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。


示例 2:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。


*/

/*
利用二叉搜索树的特点，如果p、q的值都小于root，说明p q 肯定在root的左子树中；如果p q都大于root，说明肯定在root的右子树中，如果一个在左一个在右 则说明此时的root记为对应的最近公共祖先
*/


struct TreeNode* res = NULL;
void lca(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q)
{
    if(root->val < p->val && root->val < q->val)
    {
        lca(root->right, p , q);
    }

    else if(root->val > p->val && root->val > q->val)
    {
        lca(root->left, p , q);
    }
    else  
        res = root;
}



struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) 
{
    lca(root, p, q);
    return res;
}

===========================================================================================================================
二叉树的最近公共祖先
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) 
{
    /*
        太难了，我再来解释以下，首先进入这个函数，是对h这个结点的判断，如果这个结点满足题意，直接返回
        如果这个结点不满足题意，去看看它左边和右边满不满足题意，，如果左边和右边都不满足，返回空
        如果一个存在，另一个空，说明这两个点都在存在的那边   
    */
	
    if (root == NULL) 
    {
        return NULL;
    }

    //如果左边找到了或右边找到了，返回找到了的根节点
    if (root == p || root == q) 
    {
        return root;
    }

    //找到这个点右边的  和  左边的， 递归函数上面写着的是递归终止条件  ， 递归函数下面写的是返回上一个结点的。
    struct TreeNode* left  = lowestCommonAncestor(root->left, p, q);
    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);

    //如果是NULL就代表没找到，意思就是left或right没找到，那么就在right或left
    if (left != NULL && right != NULL) 
    {
        return root;
    } 
    else if (left != NULL) 
    {
        return left;
    } 
    else if (right != NULL) 
    {
        return right;
    }
	
    //如果两边都没找到，返回空
    return NULL;
}


===========================================================================================================================
完全二叉树中结点的个数
int countNodes(struct TreeNode* root)
{
    if(root == NULL)
        return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);

}

===========================================================================================================================
二叉树的右视图

/*
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---


*/

void dfs(struct TreeNode* root, int* returnSize, int* res, int level)
{
    if(root == NULL)
    {
        return;
    }
    if(level >= *returnSize)
    {
        res[(*returnSize)++] = root->val;
    }
	
    dfs(root->right, returnSize, res, level + 1);
    dfs(root->left, returnSize, res, level + 1);
    return;
}

int* rightSideView(struct TreeNode* root, int* returnSize)
{
    int *res = (int *)malloc(sizeof(int) * 100);
    *returnSize = 0;
    dfs(root, returnSize, res, 0);
    return res;
}

===========================================================================================================================
二叉搜索树
/*
实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。

调用 next() 将返回二叉搜索树中的下一个最小的数。

示例：
          7
       /     \
     3       15
           /   \
          9    20



BSTIterator iterator = new BSTIterator(root);
iterator.next();    // 返回 3
iterator.next();    // 返回 7
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 9
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 15
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 20
iterator.hasNext(); // 返回 false


*/



typedef struct 
{
    int nums[10000];
    int top;
} BSTIterator;

void ReverseInOrder(struct TreeNode *root, BSTIterator *obj)
{
    if (root->right != NULL) 
    {
        ReverseInOrder(root->right, obj);
    }
	
    obj->nums[++obj->top] = root->val;
	
    if (root->left != NULL) 
    {
        ReverseInOrder(root->left, obj);
    }
}

//先看这个，这个和上面一步，目的就是创造了一个结构，保存了反向中序遍历的值和元素的个数
BSTIterator* bSTIteratorCreate(struct TreeNode* root) 
{
    if (root == NULL) 
    {
        return NULL;
    }
    BSTIterator *obj = (BSTIterator *)malloc(sizeof(BSTIterator));
    if (obj == NULL) 
    {
        return NULL;
    }
    obj->top = -1;
    ReverseInOrder(root, obj);
    return obj;
}

//实现栈顶元素的出栈
/** @return the next smallest number */
int bSTIteratorNext(BSTIterator* obj) 
{
    int num;
    num =  obj->nums[obj->top];
    --obj->top;
    return num;
}

/** @return whether we have a next smallest number */
bool bSTIteratorHasNext(BSTIterator* obj) 
{
    if (obj == NULL || obj->top < 0) 
    {
        return false;
    }
    
    return true;
}

void bSTIteratorFree(BSTIterator* obj) 
{
    free(obj);
}

===========================================================================================================================
二叉树的前序遍历
迭代算法
int* preorderTraversal(struct TreeNode* root, int* returnSize)
{
    int* res = (int*)malloc(sizeof(int) * 100),top = -1;
	
    struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 100);
    *returnSize = 0;
	
    if(!root) 
        return NULL;
    stack[++top] = root;
    while(top != -1)
    {
        root = stack[top--];
        res[(*returnSize)++] = root->val;
        if(root->right)
        {
            stack[++top] = root->right;
        }
        if(root->left)
        {
            stack[++top] = root->left;
        }
    }
    return res;
}

===========================================================================================================================

求根到叶子结点数字之和
/*
给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 1->2->3 代表数字 123。

计算从根到叶子节点生成的所有数字之和。

说明: 叶子节点是指没有子节点的节点。

示例 1:

输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.

示例 2:

输入: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
输出: 1026
解释:
从根到叶子节点路径 4->9->5 代表数字 495.
从根到叶子节点路径 4->0 代表数字 40.
因此，数字总和 = 495 + 491 + 40 = 1026.

*/


//n就是算出这个结点前面数字之和
int sum(struct TreeNode* root,int n)
{
    if(root == NULL)
        return 0;
    if(root->right == NULL && root->left == NULL)
        return (n * 10 + root->val);
    return sum(root->left,n * 10 + root->val) + sum(root->right,n * 10 + root->val);
}

int sumNumbers(struct TreeNode* root) 
{
    return sum(root,0);
}

===========================================================================================================================
从前序和中序遍历序列构造二叉树

/*
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7

*/

struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize)
{
    struct TreeNode* result = NULL;
    
    if(preorder == NULL || preorderSize == 0)   //preorder相当于每次递归的终止条件  preorderSize相当于如果本来这棵树就是空的情况
    {
        return NULL;
    }
   
    result = malloc(sizeof(struct TreeNode));
    if(result == NULL)
    {
        return NULL;
    }
    result->val = preorder[0];
    for(int i=0; i<inorderSize; i++)
    {
        if(inorder[i] == result->val)
        {
            result->left  = buildTree(preorder+1, i, inorder, i);
            result->right = buildTree(preorder+i+1, preorderSize - i - 1, inorder+i+1, inorderSize-i-1);
            break;
        }
    }
    return result;
}

===========================================================================================================================
从中序和后序遍历序列构造二叉树
struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize)
{
    struct TreeNode* result = NULL;
    
    if(postorder == NULL || postorderSize == 0)   //preorder相当于每次递归的终止条件  preorderSize相当于如果本来这棵树就是空的情况
    {
        return NULL;
    }
   
    result = malloc(sizeof(struct TreeNode));
    if(result == NULL)
    {
        return NULL;
    }
    result->val = postorder[postorderSize - 1];
    for(int i=0; i<inorderSize; i++)
    {
        if(inorder[i] == result->val)
        {
            result->left  = buildTree(inorder, i, postorder, i);
            result->right = buildTree(inorder+i+1, inorderSize-i-1, postorder + i, postorderSize - i - 1);
            break;
        }
    }
    return result;
}


===========================================================================================================================
路径总和
/*
给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。
*/

typedef struct TreeNode* Node;
//递归，先将临时路径保存在新数组temp中，如果该路径满足就是输入在结果中
void search(Node root,int sum,int* returnSize, int** returnColumnSizes,int **result,int *temp,int now)
{
    if(root == NULL)  
        return;     //递归结束条件
    if(root->left == NULL && root->right == NULL && sum == root->val)     //到达叶节点并满足条件的情况
    {
        temp[now++] = root->val;
        int c = *returnSize;
        (*returnColumnSizes)[*returnSize] = now;    //该行的列数
        result[c] = (int*)malloc(sizeof(int)*now);

        for(int i = 0 ;i < now ;++i)
            result[c][i] = temp[i];
        ++(*returnSize);    //行数加一
    }
    temp[now++] = root->val;
    sum -= root->val;
    search(root->left,sum,returnSize,returnColumnSizes,result,temp,now);    //递归
    search(root->right,sum,returnSize,returnColumnSizes,result,temp,now);
}
int** pathSum(struct TreeNode* root, int sum, int* returnSize, int** returnColumnSizes)
{
    int** result = (int**)malloc(sizeof(int*) * 1024);
    (*returnColumnSizes) = (int*)malloc(sizeof(int) * 1024);
    *returnSize = 0;
    if(root == NULL)  
        return result;
    int *temp = (int*)malloc(sizeof(int)*1024);
    search(root,sum,returnSize,returnColumnSizes,result,temp,0);
    return result;
}

===========================================================================================================================
二叉树展开为链表
/*
给定一个二叉树，原地将它展开为链表。

例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6

将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
*/




void flatten(struct TreeNode* root)
{
    if(root == NULL)
        return;
    flatten(root->left);
    flatten(root->right);
    struct TreeNode* tmp = root->right;
    root->right = root->left;
    root->left = NULL;
    while(root->right != NULL) 
        root = root->right;
    root->right = tmp;
}

===========================================================================================================================
//二叉树的层次遍历
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes)
{
    int **res = malloc(sizeof(int*) * 1000); //结果数组
    for(int i = 0; i < 1000; i++) //全部初始化为1个特殊的元素。以便后面统计每排有几个
    {
        res[i] = malloc(sizeof(int) * 200);
        for(int j = 0; j < 200; j++)
            res[i][j] = -929;
    }

    *returnColumnSizes = (int *)malloc(sizeof(int) * 1000);
    *returnSize = 0;
    order(root, 0, res); //递归


    for(int i = 0; i < 1000; i++) //确定返回元素每一层的宽度
    {
        if(res[i][0] == -929) //如果某一层第一个就是特殊元素，则这一层都没有存数据，即结束
        {
            *returnSize = i;
            break;
        }
        for(int j = 0; j < 200; j++) //统计每一层有多少元素存入
        {
            if(res[i][j] == -929)
            {
                (*returnColumnSizes)[i] = j;
                break;
            }
        }
    }
    return res;
}

//咱重点看这个步骤，这个步骤完成之后就可以把每一行的数字输入到数组中
void order(struct TreeNode* root,int k,int** res) 
{
    if(root == NULL)
        return;
		
    for(int i = 0; i < 1000; i++) //到第一个未填的位置填入当前值
    {
        if(res[k][i] == -929)
        {
            res[k][i] = (root->val);
            break;  //注意这个break
        }
    }
    order(root->left, k+1, res); //递归左子节点
    order(root->right, k+1, res);  //递归右子节点
}



===========================================================================================================================
验证搜索二叉树

//low和high是根节点root->val的范围
bool fun(struct TreeNode* root, long low, long high) 
{
    if (root == NULL) return true;
    long num = root->val;
    if (num <= low || num >= high) return false;
    return fun(root->left, low, num) && fun(root->right, num, high);
}
bool isValidBST(struct TreeNode* root)
{
    return fun(root, LONG_MIN, LONG_MAX);
}

===========================================================================================================================
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
===========
    堆
===========
1.最小堆：所有父节点都比子节点要小
从n / 2 个节点开始， 依次判断以这个节点为根的子树是否符合最小堆的性质，如果所有的子树都符合最小堆的性质，那么整棵树就是最小堆了

堆函数
void creat()
{
	int i; 
	for(i = n / 2; i >= 1; i--)
		siftdown(i);
	return;
}

2.最大堆：所有父节点都比子节点要大
3.向下调整的代码  最小堆
void siftdown(int i)    //传入一个节点编号i
{
	int t, flag = 0;  //flag是用来标记是否需要继续向下调整
	while(i * 2 <= n) 
	{
		if(h[i] > h[i * 2])
			t = i * 2;
		else
			t = i;
		
		if(i * 2 + 1 <= n)    //得先判断它有没有右节点
		{
			if(h[t] > h[i * 2 + 1])
				t = i * 2 + 1;
		}
		
		if(t != i)
		{
			swap(t, i);
			i = t;
		}
		else
			break;
	}
}
	
	/*
	    if(i * 2 + 1 <= n)    //得先判断它有没有右节点
		{
			if(h[2 * i] > h[i * 2 + 1])
				t = i * 2 + 1;
			else
				t = 2 * i;
		}
		else
			t = 2 * i;   
		if(h[i] > h[t])
			swap(h[i],h[t]);
			i = t;
		else
			break;
	
	*/
}

4.向上调整的代码
void siftup(int i)
{
	if(i == 1)
		return;
	while(i != 1)
	{
		if(h[i] < h[i / 2])
		{
			swap(i, i / 2);
			i = i / 2;
		}
		else
			break;
	}
}

  
5.最小堆——删除最小的数，并增加一个新数
把1号元素拿出，把新数放在树根上，从上往下比较

//删除最小的元素
int deletemin()
{
	int t;
	t = h[1];
	h[1] = h[n];
	n--;  //意思就是不管最后一个元素了
	siftdown(1);
	return;
}
6.如何在原有的堆上直接插入一个新元素
把元素插入到末尾，从n / 2 开始比较


  
7.如何排序
从小到大：从小到大排序的时候不建立最小堆而是最大堆，是最大堆建立好后，最大的元素在h[1]，因为我们需要的是从小到大排序
          希望最大排在最后，因此我们将h[1]和h[n]交换，此时h[n]就是数组中最大的元素
void heapsort()
{
	while(n > 1)
	{
		swap(1, n);
		n--;
		siftdown(1);
	}
}
  
8.支持插入元素和寻找最大值的数据结构称为优先队列

9.找一个数列中第K大的数
  建立一个大小为k的最小堆，堆顶就是第k大的数
//假设有10个数，要求第三大的数，第一步任意取三个数，比如说是前三个，将这三个简称最小堆，然后从第四个数开始，与堆顶的数比较
//如果说比堆顶的数要小，那么这个数就不要，如果说比堆顶的数要大，就舍弃这个堆顶而将这个数视为堆顶

  如果是找第k小的数，就是建立最大堆
  
***************
 找到第k大的数
***************
  void swap (int *h,int n,int m)
{
    int i;
    i = h[n];
    h[n] = h[m];
    h[m] = i;
}

//向下调整
void siftdown(int i, int n, int h[])
{
    int t;

    while((i * 2) <= n)
    {
        if((2 * i + 1) <= n)
        {
            if(h[2 * i] > h[i * 2 + 1])
                t = i * 2 + 1;
            else
                t = i * 2;
        }
        else
            t = 2 * i;

        if(h[i] > h[t])
        {
            swap(h,i,t);
            i = t;
        }
        else
            break;
    }
}


//建立一个只含n个元素的最小堆
int LittleHeap(int h[], int n, int num)
{
    int i;
    int m;

    for(i = 0; i <= num; i++)
    {
        siftdown(i,num,h);
    }
    
    for(i = num + 1; i <= n; i++)
    {
        if(h[i] > h[1])
        {
           h[1] = h[i];
           siftdown(1,num,h);
        }
    }

    return h[1];
}

int main(void)
{
    int h[] = {0,9,5,7,4,8,3};
    printf("%d",LittleHeap(h, 6, 2));

}

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
*******
并查集
*******
并查集主要有如下操作
1.合并两个集合（并）
2.判断两个元素是否属于同一个集合（查）

1.有n个强盗，求有多少个独立的犯罪团伙
  已知m条线索：x和y是同伙
  
int f[1001] = {0}, n, m, sum = 0;

//初始化数组的元素
void init()
{
    int i;
    for(i = 1; i <= n; i++)   //总共有n个强盗
        f[i] = i;
    return;
}

/**
    就是一个头领分为一串小弟和另一个头领，只有这两种情况
    这一串小弟可以不串，直接指向头领
**/

//找爹的递归函数，不停去找爹，直到找到祖宗为止，其实就是去找犯罪团伙最高领导人
//“擒贼先擒王”原则
//这个递归函数的意思是这个强盗的首领是最大头领，就是f[v] == v的
int getf(int v)   //刚开始初始化的时候，每个强盗的首领是自己
{
    /**
        这个递归函数的意思：
        4的直接领导是3，3的直接领导是2，2的直接领导是1，1的直接领导是1，1是最大领导，返回1
        f[2] = 1   返回1 ；  f[3] = 1   返回1 ；f[4] = 1   返回1
    **/
    if(f[v] == v)
        return v;
    else
    {
        ///简而言之就是把一根树枝分叉叉，
        /*这里是路径压缩，每次在函数返回的时候，顺带把路上遇到的人的boss改为最后找到的
          祖宗编号，也就是犯罪团伙最高领导人编号，这样可以提高今后找到犯罪团伙的最高领
          导人的速度*/
        f[v] = getf(f[v]);
        return f[v];
    } 
	/**
	我再来罗嗦一下，这个函数的目的就是找它的祖先，当f[v] == v的时候，它的祖先找到，如果没有
	他的祖先就是它数组里所存值的祖先，最后返回它的祖先f[v]	
	**/
}

///简而言之，就是把两个叉叉数连成一个大树
//统一首领的函数
void merge(int v, int u)  //v是u的直接领导
{
    int t1, t2;  //t1,t2储存的是v和u的首领
    
    t1 = getf(v);
    t2 = getf(u);
    
    if(t1 != t2)
        f[t2] = t1;
    return;
}

int main()
{
    int i, x, y;
    
    scanf("%d %d", &n, &m);  //总共有n个人，m条线索
    init();  //初始化，每个强盗的首领是自己
	
    for(i = 1; i <= m; i++)   //m是已经知道线索的条数
    {
        scanf("%d %d", &x, &y);   //x是y的首领
        merge(x, y);
    }
    
    
    for(i = 1; i <= n; i++)
    {
        if(f[i] == i)
            sum++;
    }
    
    printf("%d\n", sum);
}
  
2.生成最小树
//已知两个点之间的距离，要生成一个最小树
//有几个必须经过的点，选出经过所有点（只需连通就可以，没必要连一串）且 权值越小越好
//可以使w的值从小到大排序，一条一条连，且不出现环，n - 1个点都连好了就好了
struct edge
{
    int u;
    int v;
    int w;
};  //为了方便排序，这里使用了结构体来储存边的关系

struct edge e[10];

int n, m;
int f[7] = {10}, sum = 0;, count = 0;

void quicksort(int left, int right)    //  e uvw  按照权值的大小进行快速排序
{
    int i, j;
    struct edge t;
    if(left > right)
        return;
    i = left; 
    j = right;
    
    while(i != j)
    {
        while(e[j].w >= e[left].w && i < j)   //找出e[left]所在的位置，最后j指向右边小于e[left].w的
            j--;
        while(e[i].w <= e[left].w && i < j)   //最后最后i指向右边大于e[left].w的
            i++;
        if(i < j)
        {
            t = e[i];   //如果使用结构，这样就把那一行全都交换了
            e[i] = e[j];
            e[j] = t;
        }
    }
    
    //最终i = j 就是 e[left]所在的位置
    t = e[left];
    e[left] = e[i];
    e[i] = t;
    
    quicksort(left, i - 1);
    quicksort(i + 1, right);
    
    return;
}
/**
            并查集
      1.如果给出一个(u, v, w)  意思就是通过这个将u和v联系起来
      2.u可能是一个二叉树中的某一点(这个二叉树有可能是一串，还没分叉)   也有可能就是一个头；  v同理
      3.通过并查集  可以找到u和v的祖先（也有可能这个祖先就是他们自己），在找他们祖先的过程中，可以把一个串
        变成二叉树的形式
      4.如何将u和v连接，就是将v的祖先设成u的祖先，因为u和v都是他们祖先的手下
      5.并查集可以检测树中是否有环
      6.如果按二叉树的形式连好之后，又说11和2之间的距离是6，此时就连成了一个环，通过并查集找出2和11的祖先都
        是1，所以无法连接，返回0
                        1
            2                       3
       4         5             6          7
    8     9    10  11        12  13     14  15
**/


//并查集寻找祖先的函数
int getf(int v)
{
    if(f[v] == v)
        return v;
    else
    {
        //这里是路径压缩
        f[v] = getf(f[v]);  //f[v]最终的值是它的祖先   getf()就是寻找祖先
        return f[v];
    }
}

//并查集合并两子集合的函数
int merge(int v, int u)   //v 和 u是两个点
{
    int t1,t2;
	
    t1 = getf(v);
    t2 = getf(u);
	
    if(t1 != t2) //判断两个点是否在一个集合中，意思就是t1和t2的祖先不是一个，也就是根节点不是一个
    {
        f[t2] = t1;  //把t2的祖先设成t1        
        return 1;
    }
	
    return 0;
}

int main()
{
    int i;
    
    //n表示顶点个数，m表示边的条数
    scanf("%d %d", &n, &m);
    
    //读入边，这里用一个结构体来储存边的关系
    for(i = 1; i <= m; i++)
        scanf("%d %d %d", &e[i].u, &e[i].v, &e[i].w);
        
    quicksort(1, m);  //按照权值的大小对边进行排序
    
    //并查集初始化
    for(i = 1; i <= n; i++)
        f[i] = i;     //就相当于之前每个坏蛋都是自己的老大
        
    //kruskal算法核心部分
    for(i = 1; i <= m; i++)   //m条边
    {
        if(merge(e[i].u, e[i].v))   //如果目前尚未连通，则选用这条边
        {
            count++;
            sum = sum + e[i].w;  //既可以连通，且输出经过所有点的最小距离
        }
        
        if(count == n - 1)   //必须把所有的n - 1个点都连起来，如果是两个点，是一条边，所以是n - 1条边
            break;
    }
    
    printf("%d", sum);
}

  
3.

/**
    在一个带有环的图中生成最小树
    1.选择1号顶点（涂黑），更新它所对应的边，选出这些边中的最小值，记录下边的最小值所对应顶点（涂黑）
    2.重复上述过程，每次选出的都是最小值
**/
int main()
{
    int n, m, i, j, k, min, t1, t2, t3;
    int e[7][7], dis[7], book[7] = {0};
    int inf = 99999999;
    int count = 0, sum = 0;
    
    //n表示顶点个数，m表示边的条数
    //我所需要的东西，一个二维数组所储存所有顶点和边之间的关系，一个book数组所储存所有用过的顶点
	
    for(i = 1 ;i <= n; i++)  //初始化这个图
    {
        for(j = 1; j <= n; j++)
        {
            if(i == j)
                e[i][j] = 0;
            else
                e[i][j] = inf;
        }
    }
	
    //输入这个图中的数据
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d %d", &t1, &t2, &t3);
        //注意这里是无向图，所以需要将边反向再存一次
        e[t1][t2] = t3;
        e[t2][t1] = t3;
    }
    
    //初始化dis数组，这里是1号顶点到各个顶点的初始距离，因为当前生成树中只有一号顶点
    for(i = 1; i <= n; i++)
        dis[i] = e[1][i];
    
    book[1] = 1;
    count++;  //count是计算用过几个顶点
    
    while(count < n)
    {
        min = inf;
        for(i = 1; i <= n; i++)     //这一步是选出这些数据里的最小值
        {
            if(book[i] == 0 && dis[i] < min)
            {
                min = dis[i];
                j = i;
            }
        }
		//每次找出的这个点一定是最小值，是每个边上对应权值的最小值
		//啥意思了，就是根据1找出234，假如2是边的权值最小的，更新2所对应边的权值，再在这些数据里找出最小值
		//1和2就book了，不看了
        book[j] = 1;
        count++;
        sum = sum + dis[j];
        
        for(k = 1; k <= n; k++)   //更新这个点所对应的数据
        {
            if(book[k] == 0 && dis[k] > e[j][k])
                dis[k] = e[j][k];
        }
    }
    
    //输出的最后结果是一条单链  
    printf("%d", sum);
}

4.
int dis[7], book[7] = {0};  //dis是生成树到各个顶点的距离
int h[7], pos[7], size;  //h用来保存堆,堆里面储存的是顶点编号，pos（输入一个值，可以找到在堆中的位置），size为堆的大小
/**

    我看看凭借我强大的记忆力能不能把它复述出来
    开始：
    首先，我要完成的任务将一个有环的图变为二叉树，要求选择值里面最小的，简称：生成最小树
    1.我需要一个dis数组，这个数组的目的就是不断更新里面的值，使之最小
    2.首先将顶点1所对应的值初始化到dis数组中，并将1涂为蓝色，表示选过这个点，我要在1所对
      应的边中选择最小的，并把这个最小的假若2号顶点涂成蓝色，表示2号顶点的dis值已经确定，
      根据2号顶点找出2号顶点所对应的边，再一次更新dis数组里的值......
      重复上述过程，总共n - 1次
    3.根据以上叙述，需要的算法：
      1>涂蓝操作：就是标记，需要book[]数组
      2>找出顶点所对应的边：如果每次都遍历找这个顶点对应的边，次数增加，可以使用uvw first 
                             next来找边
      3>找出顶点所对应边的最小值操作：可以使用树，将每次的最小值排在顶点
                树：如果储存的是值的话，没办法储存无穷大，所以储存的是dis数组的顶点
                     同时使用pos保存顶点在树中的位置，就是使树永远都是按  12345  那个排的
                     要不之后如果说让一个值上移下移，连这个点的位置都找不到，可以根据值找到位置
                     上移下移
                     
**/

void swap(int x, int y)
{
    int t;
    t = h[x];
    h[x] = h[y];
    h[y] = t;
    
    //同步更新pos
    t = pos[h[x]];
    pos[h[x]] = pos[h[y]];
    pos[h[y]] = t;
    
    return;
}

void siftdown(int i)    //传入一个需要向下调整的节点编号
{
    int t, flag = 0;
    
    while(2 * i < size && flag == 0)
    {
        if(dis[h[i]] > dis[h[i * 2]])
            t = i * 2;
        else
            t = i;
        if(i * 2 + 1 <= size)
        {
            if(dis[h[t]] > dis[h[i * 2 + 1]])
                t = i * 2 + 1;
        }
        if(t != i)
        {
            swap(t, i);
        }
        else
            flag = 1;
    }
    return;
}

void siftup(int i)   //传入一个需要向上调整的节点编号，就是调整这个点到达最高能到达的节点
{
    if(i == 1)
        return;
    
    while(i != 1)   //h就是这个堆
    {
        if(dis[h[i]] < dis[h[i / 2]])
            swap(i, i / 2);
        else
            break;
        i = i / 2;
    }
    return;
}

//从堆顶取出一个元素
int pop(void)
{
    int t;
    t = h[1];
    pos[t] = 0;  //表示这个位置没东西了
    h[1] = h[size];
    pos[h[1]] = 1;  //把这个点的位置改为1
    
    size--;
    siftdown(1);  //向下调整
    return t;   //返回之前记录的对顶点
}

int main()
{
    int n, m, i, j, k;
    int u[19], v[19], w[19], first[7], next[19];
    int inf = 99999999;
    int count = 0, sum = 0;
    
    //n表示顶点个数，m表示边的条数
    scanf("%d %d", &n, &m);
    
    for(i = 1; i <= m; i++)
        scanf("%d %d %d", &u[i], &v[i], &w[i]);
    
    //这里是无向图，所以需要将所有的边反向储存一次
    for(i = m + 1; i <= 2 * m; i++)
    {
        u[i] = v[i - m];
        v[i] = u[i - m];
        w[i] = w[i - m];
    }
    
    //开始使用邻接表来存储边
    for(i = 1; i <= n; i++)
        first[i] = -1;
    
    for(i = 1; i <= 2 * m; i++)
    {
        next[i] = first[u[i]];
        first[u[i]] = i;
    }
    
    //prim核心部分开始
    //将1号顶点加入生成树
    
    book[1] = 1;
    count++;
    
    //初始化dis数组，这里是1号顶点到其余各个顶点的初始距离
    dis[1] = 0;
    for(i = 2; i <= n; i++)
        dis[i] = inf;
    k = first[1];
    
    while(k != -1)  //uvw
    {
        dis[v[k]] = w[k];
        k = next[k];
    }
    
    //初始化堆，堆里面保存的是顶点
    size = n;
    //这个只是暂时把堆设成这样
    for(i = 1; i <= size; i++)
    {
        h[i] = i;
        pos[i] = i;   //为什么要有这个pos数组，h只能储存对应的值，pos要储存这个点所对应的位置
    }
    //向下一个一个调整
    for(i = size / 2; i >= 1; i--)
        siftdown(i);
    pop();  //先弹出一个堆顶元素，因为此时堆顶是1号顶点，因为它的值最小，为0
    
    while(count < n)
    {
        j = pop();    //目前dis里最小的权值所对应的顶点
        book[j] = 1;
        count++;
        sum = sum + dis[j];
        
        //扫描当前顶点为j所有的边，再以j为中间顶点，进行松弛
        k = first[j];
		
		//把这个顶点对应所有的dis值插入树中，并排好顺序
        while(k != -1)
        {
            if(book[v[k]] == 0 && dis[v[k]] > w[k])
            {
                dis[v[k]] = w[k];   //改变了原来的值，所以需要调整
                siftup(pos[v[k]]); //传入一个需要向上调整的节点编号
            }
            k = next[k];
        }
    }
    printf("%d", sum);
}
========================================================================================================================================
——————————————————————————————————————————
               求图的割点
——————————————————————————————————————————
/**
    Tarjan算法：求图的割点（割点就是如果这个点没了，图将被分为不连通的两部分）
    首先你得有一个图，这个图里有环，且图里面的路线全是无向图
    使用的算法：深度遍历num[]（是指某个点是第几个访问的）      递归       
                 low[]:可以直接访问到的最早顶点（就是从这个点可以用箭头指向的最早顶点）
    过程：首先把所有无向图的路线画为灰色（无向！！！！！）   
          选中1号顶点，找出他众多直接相连点中的一个，且这个点没有直接访问过，更新num的值
          用带箭头的线将1->2连起来........
          找出一条线，假设末尾的点为7，下一个应该连2，但2之前访问过，所以更新low的值为2，
          再看看末尾有没有别的直接相连的边   重复上述过程更新
**/
int n, m, e[9][9], root;
int num[9], low[9], index;  //index用来进行时间戳的递增

int min(int a, int b)   //找出a和b中的最小值
{
    return a < b ? a > b;
}

void dfs(int cur, int father)   //当前顶点编号cur  和   父顶点的编号
{
    int child = 0, i;
    index++;   //时间戳：就是这个顶点可以用带箭头的线可以直接指向的顶点你最小值
    
    //因为刚开始，就是一条线，箭头都是往下指的，所以就是本身
    num[cur] = index;  //第几个点访问的
    low[cur] = index;  //可以访问到的最早顶点
    
    
    for(i = 1; i <= n; i++)   //不断找出cur所对应的边
    {
        if(e[cur][i] == 1)    //等于1就说明是cur所对应的边了
        {
            if(num[i] == 0)   //如果这个顶点之前没有访问过
            {
                child++;   //cur多了一个孩子
                /**
					递归分为递归之前和递归之后，递归之前要完成的事情就是让这个cur顶点入num和low
					同时找这个顶点所对应的边（for循环），而递归是在下一个点确定之后调用的，递归之后
					需要完成的事情，说明不满足递归的条件，啥时候就停止了，就是这个点之前访问过
					而num中记录的是这个顶点被访问的时间戳，，所以递归函数应该包含在一个if的截至条件下
					调用完函数之后，下一步就是更新时间戳的值，相当于回溯，更新low数组之后，就要判断是不是割点
					就是判断这个点的孩子所对应的时间戳如果比这个点大或等于，就说明这个点是时间戳，同时要判断
					这个点是否为根节点的情况
				**/			
                dfs(i, cur);   //递归一直往下遍历，直到不满足num[i] == 0，dis返回上一次调用的下一条语句的地址
							   //就是low.....
                
                low[cur] = min(low[cur], low[i]);   //刚才最底下的点不是7嘛，更新low为2（else if），返回到这里，更新上一个数
                                                    //low为2
                //cur里面存的是顶点的时间戳
				//low里面存的是顶点的最早时间戳
                if(cur != root && low[i] >= num[cur])    //如果它不是根节点且low[i] >= num[cur]说明cur直接访问到的点
                                                        //在自己后头，没有环
                    flag[cur] = 1;   //就说明这个点是一个割点
                
                if(cur == root && child == 2)     //如果它是一个根节点且它有两个孩子，他要没了，这个树就分成两部分了
                    flag[cur] = 1;    //就说明这个点是一个割点
            }
            else if(i != fater)    //如果cur所对应下一个顶点i不是它爸爸，且之前访问过，就说明和除了它爸爸之外的点相连
                low[cur] = min(low[cur], num[i]);     //更新low值，就是它本来的low值和num值（i所对应的点是第几次访问的）
        }
    }
    return;  //如果这个顶点所对应的边都访问完，就返回上一个点
}

int main()
{
    int i, j, x, y;
    scanf("%d %d", &n, &m);
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= n; j++)
            e[i][j] = 0;
    }
    
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d", &x, &y);
        e[x][y] = 1;
        e[y][x] = 1;
    }
    root = 1;
    dfs(1, root);
    
    for(i = 1; i <= n; i++)
    {
        if(flag[i] == 1)
            printf("%d", i);
    }
}

========================================================================================================================================
——————————————————————————————————————————
               求图的割边（桥）
——————————————————————————————————————————
int n, m, e[9][9], root;
int num[9], low[9], index;
int min(int a, int b)
{
    return a < b ? a : b;
}

void dfs(int cur, int father)
{
    int i; 
    
    index++;
    num[cur] = index;
    low[cur] = index;
	//上面的求割点主要是判断点的情况，说是要考虑特殊点，就是根节点
	//这个是边，就没有特殊的边
	//啥是割点，就是这个点下面的点不能超过这个点，等于可以
	//啥是割边，就是cur这个点的儿子下面的点都回不去cur，则cur这个点和它儿子之间的那条边就是割边
    for(i = 1; i <= n; i++)
    {
        if(e[cur][i] == 1)
        {
            if(num[i] == 0)
            {
                dfs(i, cur);
                low[cur] = min(low[i], low[cur]);
                if(low[i] > num[cur])     //之前是>=   就说明它是一个串串，串串断了就断了，
				                      //low[i] >= num[cur]   说明i是不可能在不经过cur的情况下回到祖先（包括父亲）
									  //如果去掉等号，是说它连父亲也回不去，如果i回不到祖先，也回不到父亲，那么它就是割边
                    printf("%d-%d\n", cur, i);
            }
            else if(i != father)
            {
                low[cur] = min(low[cur], low[i]);
            }
        }
    }
    return;
}

int main()
{
    int i, j, x, y;
    scanf("%d %d", &n, &m);
    for(i = 1; i <= n; j++)
    {
        for(j = 1; j <= n; j++)
            e[i][j] = 0;
    }
    
    for(i = 1; i <= m; i++)
    {
        scanf("%d %d", &x, &y);
        e[x][y] = 1;
        e[y][x] = 1;
    }
    root = 1;
    dfs(1, root);
}

========================================================================================================================================
——————————————————————————————————————————
               二分图（男女配对）
——————————————————————————————————————————
int e[101][101];   //e中横行元素可以看成男生，纵行元素可以看成女生
int match[101];    //match是标记配对关系，比如i和u配对了match[i] = u;
int book[101];
int n, m;
/**
                 二分图
    1.类似于映射，两个集合互相有关联，但是集合内部没有任何关系
    2.假设有n个男生和n个女生，男生和女生之间有n条关系，要使男生尽可能多和女生配对
    3.伪算法：
              二维数组，女生横坐标，男生纵坐标，如果之间有关系为1，没关系为0
              从第一行开始遍历，找到最先为1的值，使这个男生和这个女生配对，标记这个男生(book)，说明这个男生不看他了
              更新book数组的值全为0，同时遍历第二行元素，找到第一个为1的元素，让这个男生和这个女生配对，标记这个男生
                     这时候出现了一个问题：如何判断这个男生是否之前跟某女生配对过，所以要用一个数组记录下所有配对的
                                            关系(match)   判断这个男生i是否配过对  就是判断match[i]等于0是否成立，如果
                                            成立match[i] = u， mathch是通过男生找女生
                            这就又出现了一个问题：如果男生i配过对,就要看配过对的match[i]是否还可以找到其他人
                                                   把book[i]设为1，不看i
                                               1>  原配还可以找到男人dfs match[i]，既然book[i] = 1，那就不看这个人了
                                                   我要找到下一个跟我配对的男人，找到了返回1，新来的就可以和i配对了
                                                   ，不可以返回0
                                                   
                                              
                                                   
                                
**/
int dfs(int u)   //寻找一个数的增广路，就是e中的横行元素，dfs的目的就是寻找这个数是否有配对元素，有返回1，没有返回0
{
    int i; 
    for(i = 1; i <= n; i++) //遍历u所有的配对关系
    {
        if(book[i] == 0 && e[u][i] == 1)    //e是判断u和i是否具有配对关系，book是标记i是否配对，
        {
            book[i] = 1;   //先把未婚夫设为1，成不成不一定
            //如果i未配对或者找到了新的配对
            if(match[i] == 0 || dfs(match[i]))   //如果match[i] == 0成了，dfs(match[i])返回1，就是看看原配是否可以找到 
                                                //别的人，找到了，成了
            {
                match[i] = u;
                return 1;
            }
        }
    }
    
    return 0;
}

int main()
{
    int i, j, t1, t2, sum = 0;
    scanf("%d %d", &n, &m);     //n表示男生和女生的人数都是n，m表示接下来有m条关系，例如2号男生可以和3号女生坐在一起
    
    for(i = 1; i <= m; i++)
    {
        scanf("%d%d", &t1, t2);
        e[t1][t2] = 1;
    }
    
    for(i = 1; i <= n; i++)
        match[i] = 0;
    
    for(i = 1; i <= n; i++)
    {
        for(j = 1; j <= n; i++)
            book[j] = 0;     //清空上次搜索时的标记
        if(dfs(i))
            sum++;           //寻找增广路，如果找到，配对数增加1
    }
    printf("%d", sum);
}


========================================================================================================================================
1.和数字有关的，需要标记一个数字之前是否出现过，可以用类似桶排序的方法，初始化book[]数组全为0，出现一个数字标记为1

========================================================================================================================================
*文件
1.保存程序就是将编辑好的从语言程序以文件的形式储存在计算机的外储存器上，比如磁盘上，形成源程序文件
2.文件的基本概念
  磁盘文件 
			磁盘文件是储存在磁盘上的信息的集合
  设备文件 
			所有能进行输入/输出的终端设备都被视为设备文件
3.可以把文件分为文本文件和二进制文件
  文本文件中的每个字节存放一个ASCII码，代表一个字符：2012保存的是四个字符，一个字符占1个字节，一个字节占8位，总共有32位
          文本文件中一个字节对应一个字符，便于对字符逐个处理，也便于输出字符，但占用较多的磁盘空间，而且在读入内存或写入文件时要进行格式
		  转化，就是你可以看的懂的文件
  二进制文件中的数据以数据在内存中的形式存放：就是2012对应的二进制数，你看不懂的文件
            数据格式与数据在内存的储存形式相同，占用较小的磁盘空间，读入内存或写入文件时也不进行格式转化，数据输入/输出速度较快
4.缓冲文件既用于处理文本文件，又用于处理二进制文件
5.为标准设备定义的文件型指针
  stdin  键盘   标准输入设备
  sdtout 显示器 标准输出设备
  stderr 显示器 标准错误输出设备
  stdaux 串行口 标准串行输出设备
  stdprn 打印机 标准打印设备
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
*文件的打开与关闭
1.打开文件：建立程序和文件之间的通信通道，并为文件操作建立缓冲区
FILM *fopen(char *filmname, char *mode)   //filmname 磁盘文件名    |     mode指名文件的使用方式
该函数的功能是按指定的使用方式打开指定的文件，并为其分配缓冲区，若文件打开成功，函数返回FILE类型指针，否则，返回空指针NULL
2.文件使用方式串
"r"   以读方式打开文本文件
"w"   以写方式打开新文本文件
"wb"  以写方式打开新二进制文件
"rb"  以读方式打开二进制文件

2.关闭文件：释放相关的资源，如缓冲区
3.
int main()
{
    char ch;
    FILE *fp;
    if(fp = fopen("C:\\anita.txt", "w") == NULL)
    {
        printf("Can not open file\n");
        exit(1);    //exit带参数值0表示正常结束，非0表示出错后结束
    }

    ch = getchar();      //可以改成ch = fgetc(stdin); 
    while(ch != EOF)
    {
        fputc(ch, fp);   //将ch中的字符写入文件fp中。若写入成功，函数返回所写字符，否则，函数返回EOF
        ch = getchar();
    }
    fclose(fp);   //关闭文件，同时释放分配给文件的缓冲区，若正确关闭文件，函数返回0，否则返回非0

    if((fp = fopen("C:\\anita.txt","r")) == NULL)
    {
        printf("Can not open file\n");
        exit(1);
    }

    ch = fgetc(fp);    //从文件fp中读取一个字符。函数以整数形式返回所读取的字符，若遇文件尾，则函数返回文件结束标志EOF

    while(ch != EOF)
    {
        putchar(ch);    //可以写成fputc(ch, stdout)
        ch = fgetc(fp);
    }
    fclose(fp);*/
}

4.
常用函数
1）int feof(FILE *fp);  //功能是测试文件fp的读写位置指针是否指向文件尾，若指向文件尾，函数返回非0，否则返回0
   while(!feof(fp))
   {......}
   
2）fgets(str2, N, fp);  //从文件读取N - 1个字符保存在数组str2中
   fputs(str2,stdout);  //将数组str2中的字符串输出至显示器

  
=======================================================================================================================================
****
向量
****
1.接口与实现
2.向量是数组的抽象与泛化，由一组元素按线性次序封装而成，元素的类型不限于基本类型，可更为便捷的参与复杂数据结构的定制与实现

  
  
Map.Entry firstEntry()：最小key所对应的key-value对
Object firstKey()：返回该Map中的最小key值
Map.Entry lastEntry()：最大key所对应的key-value对
Object lastKey()：最大key值
Map.Entry higherEntry(Object key)：大于指定key的最小key所对应的key-value对
Object higherKey(Object key)：大于指定key的最小key值
Map.Entry lowerEntry(Object key)：小于指定key的最大key所对应的key-value对
Object lowerKey(Object key)：即小于指定key的最大key值
NavigableMap subMap(Object fromKey, boolean fromInclusive, Object toKey, boolean toInclusive)：key的范围是从fromKey（是否包括取决于第二个参数）到toKey（是否包括取决于第四个参数）。
SortedMap subMap([, ))
SortedMap tailMap( [ )：大于fromKey（包括）的所有key。
NavigableMap tailMap(Object fromKey,boolean inclusive)：
SortedMap headMap( ) )：
NavigableMap headMap(Object toKey,boolean inclusive)：

  
  
  
  
  
  C:\Users\小可爱\Documents\Tencent Files\2659580957\FileRecv
  
  
  

  
  
  
  
  
  
  
  
  
  